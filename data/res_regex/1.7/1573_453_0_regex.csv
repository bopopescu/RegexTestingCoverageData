"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_approveForDeliveryTeam(aaron.test.test.ClaimsReceivedByMonitoringOfficerTest)')","[10756, 14104, 25197, 29944, 37281, 52605, 56385, 69062, 79447, 93837, 97401, 109286, 120090, 136348, 140344, 153813, 166045, 183704, 188024, 202681, 215637, 234230, 238766, 296951, 298753]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p.test;\nimport p.*;\nimport org.junit.*;\n\n/**\n * tests for TestStateMachine\n */\n@Ignore(""base class"")\nabstract class AbstractTestTest \n{\n    /**\n     *\n     */\n    protected TestStateMachine newStateMachine()\n    {\n        final TestStateMachine fsm = TestStateMachine.createAndStart(); \n        Assert.assertNotNull(fsm);\n        return fsm;\n    }\n}\n')",[287083]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_moveToClaimsPaymentRejected(aaron.test.test.ClaimsReadyForPaymentTest)')","[8183, 8214, 8245, 11903, 11934, 11965, 24261, 24285, 24309, 35974, 36004, 36034, 49700, 49735, 49770, 53900, 53935, 53970, 67970, 67998, 68026, 78228, 78256, 78284, 91098, 91131, 91164, 95058, 95091, 95124, 108272, 108298, 108324, 118695, 118727, 118759, 133277, 133314, 133351, 137717, 137754, 137791, 152643, 152673, 152703, 164518, 164553, 164588, 180384, 180424, 180464, 185184, 185224, 185264, 201394, 201427, 201460, 214022, 214059, 214096, 230744, 230786, 230828, 235784, 235826, 235868, 293953, 293993, 294033, 295261, 295303, 295345]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_moveToClaimsReceivedByDeliveryTeam(aaron.test.test.ClaimsReceivedByHeadOfDeliveryTest)')","[12647, 12678, 12709, 15995, 16026, 16057, 25893, 25917, 25941, 38288, 38318, 38348, 54740, 54775, 54810, 58520, 58555, 58590, 69874, 69902, 69930, 80386, 80414, 80442, 95850, 95883, 95916, 99414, 99447, 99480, 110040, 110066, 110092, 121165, 121197, 121229, 138605, 138642, 138679, 142601, 142638, 142675, 154683, 154713, 154743, 167222, 167257, 167292, 186144, 186184, 186224, 190464, 190504, 190544, 203638, 203671, 203704, 216882, 216919, 216956, 236792, 236834, 236876, 241328, 241370, 241412, 300053, 300093, 300133, 301345, 301387, 301429]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsMarkPaymentAsComplete extends AbstractTransition<ClaimsPaymentReceived, ClaimsPaymentComplete>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""mark payment as complete"";\n\n    TransitionClaimsMarkPaymentAsComplete(final ClaimsPaymentReceived from, final ClaimsPaymentComplete to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[266710]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsRejectPayment extends AbstractTransition<ClaimsReadyForPayment, ClaimsPaymentRejected>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""reject payment"";\n\n    TransitionClaimsRejectPayment(final ClaimsReadyForPayment from, final ClaimsPaymentRejected to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[264354]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.HashMap;\n        \nabstract class AbstractClaimsState implements State\n{\n    private final Map<String, Transition> transitionsByName;\n\n    private final ClaimsStateMachine stateMachine;\n    private final StateNotifier notifier;\n    \n    AbstractClaimsState(final ClaimsStateMachine fsm)\n    {\n        if (fsm == null)\n        {\n            throw new NullPointerException(""state machine cannot be null"");\n        }\n        this.stateMachine = fsm;\n        this.notifier = fsm.newNotifier();\n        this.transitionsByName = new HashMap<String, Transition>();\n    }\n    \n    public ClaimsStateMachine getStateMachine()\n    {\n        return this.stateMachine;\n    }\n\n\n    /**\n     * @param fsm\n     */\n    void initialise()\n    {\n        for(final Transition transition  : initialiseTransitions())\n        {\n            this.transitionsByName.put(transition.getName(), transition);\n        }    \n    }\n    \n    Collection<Transition> getTransitions()\n    {\n        return this.transitionsByName.values();\n    }\n\n    Collection<String> getTransitionNames()\n    {\n        return this.transitionsByName.keySet();\n    }\n    \n    final Transition getTransitionForName(final String name)\n    {\n        return this.transitionsByName.get(name);\n    }\n\n    abstract Collection<Transition> initialiseTransitions();\n\n    /**\n     * @return true if the listener was successfully registered\n     */\n    public <T extends StateListener> T registerListener(final T listener)\n    {\n        final boolean registered = this.notifier.registerListener(listener);\n        assert registered : ""listener not registered: "" + listener;\n        return listener;\n    }\n\n    public boolean unregisterListener(final StateListener listener)\n    {\n        return this.notifier.unregisterListener(listener);\n    }\n\n    final TransitionGuard onExit(final Transition transition)\n    {\n        return this.notifier.onBeforeTransition(transition);\n    }\n\n    final TransitionGuard onEnter(final Transition transition)\n    {\n        return this.notifier.onAfterTransition(transition);\n    }\n\n    /**\n     * @param the target state\n     * @return the transition paths\n     */\n    public TransitionPaths getPaths(final State toState)\n    {\n        final TransitionPaths paths = new TransitionPaths();\n        final TransitionPath path = new TransitionPath(this);\n\n        appendPathRecursive(paths, path, toState);\n\n        return paths;\n    }\n\n    private void appendPathRecursive(final TransitionPaths paths, final TransitionPath srcPath, final State goal)\n    {\n        for (final Transition transition : getTransitions())\n        {\n            final TransitionPath path = srcPath.clonePath();\n            final AbstractClaimsState targetState = (AbstractClaimsState) transition.getTarget();\n\n            final boolean notRecursivePathLoop = path.add(targetState, transition);\n\n            if (notRecursivePathLoop)\n            {\n                if (targetState.equals(goal))\n                {\n                   paths.add(path); \n                }\n                else\n                {\n                    targetState.appendPathRecursive(paths, path, goal);\n                }\n            }\n        }\n    }\n    \n    /**\n     *\n     */\n    @Override\n    public String toString()\n    {\n        final StringBuilder builder = new StringBuilder();\n        final String newLine = String.format(""%n"");\n        builder.append(getName()).append(newLine);\n        for (final Transition transition : getTransitions())\n        {\n            builder.append(""\\t"").append(transition).append(newLine);\n        }\n        builder.append(""\\t"").append(this.notifier).append(newLine);\n        return builder.toString();\n    }\n}\n')",[263010]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getStateForName(aaron.test.test.ClaimsStartStateTest)')","[1622, 16832, 18568, 27309, 30446, 40332, 40955, 59465, 61425, 71526, 82292, 82873, 100305, 102153, 111574, 123347, 124012, 143600, 145672, 156453, 169611, 170339, 191544, 193784, 205585, 219409, 220179, 242462, 244814, 305289, 306091]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'com.porpoise.fsm.model.StateMachineTest')","[310976, 310996, 311017, 311037]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsSubmitToDeliveryTeam extends AbstractTransition<ClaimsNotReceived, ClaimsReceivedByDeliveryTeam>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""submit to delivery team"";\n\n    TransitionClaimsSubmitToDeliveryTeam(final ClaimsNotReceived from, final ClaimsReceivedByDeliveryTeam to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[266071]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_init(aaron.test.test.ClaimsStartStateTest)')","[17359, 17390, 17421, 19095, 19126, 19157, 27717, 27741, 27765, 40842, 40872, 40902, 60060, 60095, 60130, 62020, 62055, 62090, 72002, 72030, 72058, 82768, 82796, 82824, 100866, 100899, 100932, 102714, 102747, 102780, 112016, 112042, 112068, 123891, 123923, 123955, 144229, 144266, 144303, 146301, 146338, 146375, 156963, 156993, 157023, 170206, 170241, 170276, 192224, 192264, 192304, 194464, 194504, 194544, 206146, 206179, 206212, 220038, 220075, 220112, 243176, 243218, 243260, 245528, 245570, 245612, 305969, 306009, 306049, 306805, 306847, 306889]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\n/**\n * represents the state in a state machine\n */\npublic interface State extends NamedObject\n{\n    /**\n     * Return a unique name for this state.\n     * \n     * A state may need to be persisted, a common way to do this is \n     * to persist an enumeration of state values.\n     *   \n     * @return the unique name of this state\n     */\n    @Override\n    public String getName();\n    \n    /**\n     * allow callbacks to register their interest\n     * @param listener the listener to register\n     * @return true if the listener was registered successfully\n     */\n    <T extends StateListener> T registerListener(final T listener);\n\n    /**\n     * allow callbacks (listeners) to unregister their interest\n     * @param listener the listener to unregister\n     * @return true if the listener was unregistered successfully\n     */\n    boolean unregisterListener(final StateListener listener);\n    \n    /**\n     * @return an object representing all paths to the given state from this state\n     */\n    TransitionPaths getPaths(final State to);\n}\n')",[254551]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_executeToClaimsStartState(aaron.test.test.ClaimsStartStateTest)')","[17111, 17142, 17173, 18847, 18878, 18909, 27525, 27549, 27573, 40602, 40632, 40662, 59780, 59815, 59850, 61740, 61775, 61810, 71778, 71806, 71834, 82544, 82572, 82600, 100602, 100635, 100668, 102450, 102483, 102516, 111808, 111834, 111860, 123635, 123667, 123699, 143933, 143970, 144007, 146005, 146042, 146079, 156723, 156753, 156783, 169926, 169961, 169996, 191904, 191944, 191984, 194144, 194184, 194224, 205882, 205915, 205948, 219742, 219779, 219816, 242840, 242882, 242924, 245192, 245234, 245276, 305649, 305689, 305729, 306469, 306511, 306553]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_executeToClaimsPaymentComplete(aaron.test.test.ClaimsPaymentCompleteTest)')","[920, 5672, 7532, 22701, 29318, 33750, 34013, 46865, 48965, 66150, 76154, 76399, 88425, 90405, 106582, 116321, 116602, 130280, 132500, 150693, 161919, 162227, 177144, 179544, 199249, 211273, 211599, 227342, 229862, 288981, 289303]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_moveToClaimsReceivedByMonitoringOfficer(aaron.test.test.ClaimsNotReceivedTest)')","[6664, 9268, 23277, 29484, 34607, 47985, 50925, 66822, 76953, 89481, 92253, 107206, 117236, 131464, 134572, 151413, 162921, 178424, 181784, 200041, 212333, 228686, 232214, 290371, 292165]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'com.porpoise.fsm.model.StartStateTest')","[250620, 250643, 250667, 250690]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\n/**\n * if you use google collections, refactor to use that instead \n */\npublic enum StateLog\n{\n    ;// uninstantiable\n\n    public static String error(final String format, final Object... args)\n    {\n        final String log = ""_error:"" + String.format(format, args);\n        System.out.println(log);\n        return log;\n    }\n\n    public static String info(final String format, final Object... args)\n    {\n        final String log = ""_info:"" + String.format(format, args);\n        System.out.println(log);\n        return log;\n    }\n\n    public static String debug(final String format, final Object... args)\n    {\n        final String log = ""_debug:"" + String.format(format, args);\n        System.out.println(log);\n        return log;\n    }\n    \n    public static String trace(final String format, final Object... args)\n    {\n        return ""_trace:"" + String.format(format, args);\n    }\n}\n')",[254801]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class TestStartState extends AbstractTestState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""start-state"";\n\n    \n    /**\n     * @param fsm\n     */\n    TestStartState(final TestStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        return allTransitions;    \n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[286707]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\n\n/**\n * A holder for \'paths\' -- chains of transitions through the state machine\n */\npublic final class TransitionPaths implements Iterable<TransitionPath>\n{\n    private final Collection<TransitionPath> paths;\n\n    TransitionPaths()\n    {\n        this.paths = new ArrayList<TransitionPath>();\n    }\n\n    boolean add(final TransitionPath path)\n    {\n        if (!this.paths.contains(path))\n        {\n            return this.paths.add(path);\n        }\n        return false;\n    }\n \n    /** \n     * @return the paths\n     */\n    public Collection<TransitionPath> getPaths()\n    {\n        return Collections.unmodifiableCollection(this.paths);\n    }\n\n    /** \n     * get the path at index i\n     */\n    public TransitionPath getPath(final int i)\n    {\n        if (i < 0 || i > getPaths().size())\n        {\n            return null;\n        }\n        int index = 0;\n        for (final TransitionPath path : getPaths())\n        {\n            if (index == i)\n                return path;\n            index++;\n        }\n        return null;\n    }\n\n    /**\n     * return the shorted path. Multiple paths may exist with the same length\n     * \n     * @return the shorted path\n     */\n    public TransitionPath getShortestPath()\n    {\n        if (getPaths().isEmpty())\n            return null;\n        return getPathsAsSortedList().get(0);\n    }\n\n    /**\n     * @return a list of paths, shortest first\n     */\n    public List<TransitionPath> getPathsAsSortedList()\n    {\n        final LinkedList<TransitionPath> pathList = new LinkedList<TransitionPath>(getPaths());\n        Collections.sort(pathList);\n        return pathList;\n    }\n\n    /**\n     * @return the number of paths available between two states\n     */\n    public int size()\n    {\n        return this.paths.size();\n    }\n    \n    /**\n     * @return true if there are no paths between the two states\n     */\n    public boolean isEmpty()\n    {\n        return size() == 0;\n    }\n\n\n    /**\n     * @return the iterator\n     */\n    @Override\n    public Iterator<TransitionPath> iterator()\n    {\n        return getPathsAsSortedList().iterator();\n    }\n\n    /**\n     * @param names the name(s) of the transition(s) to include\n     * @return a {@link TransitionPaths} object which contains a subset of this paths object which contain the transition identified by the given name \n     */\n    public final TransitionPaths getPathsWithTransitions(final String ... names)\n    {\n        return filterPaths(PathFilters.byNames(names));\n    }\n\n    /**\n     * @name the name of the transition\n     * @return a {@link TransitionPaths} object which contains a subset of this paths object which does NOT contain the transition identified by the given name \n     */\n    public final TransitionPaths getPathsAvoidingTransitions(final String ... names)\n    {\n        final Predicate<TransitionPath> filter = PathFilters.byNames(names); \n        return filterPaths(Predicates.not(filter));\n    }\n    \n    /**\n     * @param filter the filter to apply to child paths\n     * @return a new TransitionPaths object which only contains TransitionPaths which match the given filter \n     */\n    public TransitionPaths filterPaths(final Predicate<TransitionPath> filter)\n    {\n        final TransitionPaths matchingPaths = new TransitionPaths();\n        for (final TransitionPath path : this)\n        {\n            if (filter.apply(path))\n            {\n                matchingPaths.add(path);\n            }\n        }\n        return matchingPaths;\n    }\n    \n    /**\n     * @return a string representation\n     */\n    @Override\n    public String toString()\n    {\n        final String newLine = String.format(""%n"");\n        final StringBuilder b = new StringBuilder();\n        for (final Object path : this.paths)\n        {\n            b.append(path).append(newLine);\n        }\n        return b.toString();\n    }\n    \n}')",[282007]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_submitToHeadOfDelivery(aaron.test.test.ClaimsNotReceivedTest)')","[7284, 9888, 23757, 29589, 35207, 48685, 51625, 67382, 77513, 90141, 92913, 107726, 117876, 132204, 135312, 152013, 163621, 179224, 182584, 200701, 213073, 229526, 233054, 291171, 293005]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', ""package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsPaymentComplete\n */\npublic class ClaimsPaymentCompleteTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the 'ClaimsPaymentComplete' state\n     */\n    @Test\n    public void test_executeToClaimsPaymentComplete()\n    {\n        Assert.assertNotNull(moveToClaimsPaymentComplete());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for 'paymentComplete' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.paymentComplete().getName();\n        Assert.assertEquals(fsm.paymentComplete(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the paymentComplete state\n     */\n    final ClaimsPaymentComplete moveToClaimsPaymentComplete()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsPaymentComplete paymentComplete = fsm.paymentComplete();\n\n        // call the method under test\n        fsm.executeToState(paymentComplete);\n\n        Assert.assertSame(paymentComplete, fsm.getCurrentState());\n        Assert.assertEquals(paymentComplete.getName(), fsm.getCurrentStateName());\n        \n        return paymentComplete;\n    }\n\n}\n"")",[274493]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n *\n */\nclass StateNotifier\n{\n    private final List<StateListener> listeners;\n    \n    private enum TransitionType {\n        ENTER {\n            @Override\n            public TransitionGuard fire(final StateListener listener, final Transition transition)\n            {\n                return listener.onEnter(transition);\n            }\n        },\n        EXIT {\n            @Override\n            public TransitionGuard fire(final StateListener listener, final Transition transition)\n            {\n                return listener.onExit(transition);\n            }\n        };\n        \n        public abstract TransitionGuard fire(StateListener listener, Transition trans);\n    }\n\n    /**\n     */\n    StateNotifier()\n    {\n        super();\n        this.listeners = new CopyOnWriteArrayList<StateListener>();\n    }\n\n    /**\n     * @param listener the listener\n     * @return true if the listener was registered\n     */\n    public boolean registerListener(final StateListener listener)\n    {\n        if (listener == null)\n            return false;\n        return this.listeners.add(listener);\n    }\n\n    /**\n     * @param listener the listener\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterListener(final StateListener listener)\n    {\n        if (listener == null)\n            return false;\n        return this.listeners.remove(listener);\n    }\n\n\n    final TransitionGuard onBeforeTransition(final Transition transition)\n    {\n        return fireTransition(transition, TransitionType.EXIT);\n    }\n\n    final TransitionGuard onAfterTransition(final Transition transition)\n    {\n        return fireTransition(transition, TransitionType.ENTER);\n    }\n\n    final TransitionGuard fireTransition(final Transition transition, final TransitionType type)\n    {\n        TransitionGuard result = TransitionGuard.ok();\n\n        //\n        // fire general-purpose listeners\n        //\n        for (final StateListener listener : this.listeners)\n        {\n            final TransitionGuard condition = type.fire(listener, transition);\n            if (condition.stop())\n            {\n                StateLog.debug(""asked to stop immediately by listener \'%s\' for transition \'%s\'. Reason=%s"", listener, transition, condition.getReason());\n                return condition;\n            }\n            else if (!condition.continueProcessing())\n            {\n                StateLog.debug(""asked to stop eventually by listener \'%s\' for transition \'%s\'. Reason=%s"", listener, transition, condition.getReason());\n                // if *any* listener asks to stop, then set the result to stop\n                result = condition;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @return the string representation\n     */\n    @Override\n    public String toString()\n    {\n        final String newLine = String.format(""%n"");\n        final StringBuilder b = new StringBuilder();\n        for (final StateListener listener : this.listeners)\n        {\n            b.append(listener).append(newLine);\n        }\n        return String.format(""Listeners: %s"", b);\n    }\n}\n')",[261573]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsInit extends AbstractTransition<ClaimsStartState, ClaimsNotReceived>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""init"";\n\n    TransitionClaimsInit(final ClaimsStartState from, final ClaimsNotReceived to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[268150]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'aaron.test.test.ClaimsPaymentRejectedTest')","[310894, 310914, 310935, 310955]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\n/**\n * if you use google collections, refactor to use that instead \n */\npublic enum StateLog\n{\n    ;// uninstantiable\n\n    public static String error(final String format, final Object... args)\n    {\n        final String log = ""_error:"" + String.format(format, args);\n        System.out.println(log);\n        return log;\n    }\n\n    public static String info(final String format, final Object... args)\n    {\n        final String log = ""_info:"" + String.format(format, args);\n        System.out.println(log);\n        return log;\n    }\n\n    public static String debug(final String format, final Object... args)\n    {\n        final String log = ""_debug:"" + String.format(format, args);\n        System.out.println(log);\n        return log;\n    }\n    \n    public static String trace(final String format, final Object... args)\n    {\n        return ""_trace:"" + String.format(format, args);\n    }\n}\n')",[254984]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport com.google.common.base.Predicate;\n\n/**\n * A collection of useful implementations of StateListener\n */\npublic enum StateListeners \n{\n    ;//uninstantiable\n    \n    static class BlockEntryListener extends ListenerAdapter\n    {\n        private final Enum<?> reason;\n        public BlockEntryListener(final Enum<?> reason)\n        {\n            super(TransitionGuard.stopEventually(reason), TransitionGuard.ok());\n            this.reason = reason;\n        }\n        public BlockEntryListener()\n        {\n            this(null);\n        }\n\n        @Override\n        public String toString()\n        {\n            return String.format(""block entry (reason=%s)"", this.reason);\n        }\n    }\n\n    static class BlockExitListener extends ListenerAdapter\n    {\n        private final Enum<?> reason;\n        public BlockExitListener(final Enum<?> reason)\n        {\n            super(TransitionGuard.ok(), TransitionGuard.stopEventually(reason));\n            this.reason = reason;\n        }\n        public BlockExitListener()\n        {\n            this(null);\n        }\n\n        @Override\n        public String toString()\n        {\n            return String.format(""block exit (reason=%s)"", this.reason);\n        }\n    }\n\n    /**\n     */\n    public static RecordingListener recordingListener()\n    {\n        return new RecordingListener();\n    }\n\n    /**\n     * a listener which records the transitions\n     */\n    public static class RecordingListener extends ListenerAdapter\n    {\n        private final List<Transition> enterTransitions = new ArrayList<Transition>();\n        private final List<Transition> exitTransitions  = new ArrayList<Transition>();\n\n        @Override\n        public TransitionGuard onExit(final Transition transition)\n        {\n            this.exitTransitions.add(transition);\n            return TransitionGuard.ok();\n        }\n\n        @Override\n        public TransitionGuard onEnter(final Transition transition)\n        {\n            this.enterTransitions.add(transition);\n            return TransitionGuard.ok();\n        }\n\n        /**\n         * @return the exit transitions\n         */\n        public List<Transition> getExitTransitions()\n        {\n            return Collections.unmodifiableList(this.exitTransitions);\n        }\n\n        /**\n         * @return the enter transitions\n         */\n        public List<Transition> getEnterTransitions()\n        {\n            return Collections.unmodifiableList(this.enterTransitions);\n        }\n\n        @Override\n        public String toString()\n        {\n            return ""recording listener"";\n        }\n    }\n\n    /**\n     */\n    public static class EchoListener extends ListenerAdapter\n    {\n        private final PrintStream out;\n\n        public EchoListener(final PrintStream outStream)\n        {\n            if (outStream == null)\n            {\n                throw new NullPointerException();\n            }\n            this.out = outStream;\n        }\n\n        @Override\n        public TransitionGuard onEnter(final Transition transition)\n        {\n            this.out.println(String.format(""enter \'%s\' via \'%s\'"", transition.getTarget().getName(), transition.getName()));\n            return TransitionGuard.ok();\n        }\n\n        @Override\n        public TransitionGuard onExit(final Transition transition)\n        {\n            this.out.println(String.format(""exit \'%s\' via \'%s\'"", transition.getSource().getName(), transition.getName()));\n            return TransitionGuard.ok();\n        }\n        @Override\n        public String toString()\n        {\n            return ""echo listener"";\n        }\n    }\n\n    public static EchoListener echoListener(final PrintStream out)\n    {\n        return new EchoListener(out);\n    }\n\n    /**\n     * @return the registered listener\n     */\n    public static StateListener blockEntryListener()\n    {\n        return blockEntryListener(null);\n    }\n\n    /**\n     * @return the registered listener\n     */\n    public static StateListener blockEntryListener(final Enum<?> reason)\n    {\n        return new BlockEntryListener(reason);\n    }\n\n    /**\n     * @return the listener\n     */\n    public static StateListener blockExitListener()\n    {\n        return blockExitListener(null);\n    }\n\n    /**\n     * @return the listener\n     */\n    public static StateListener blockExitListener(final Enum<?> reason)\n    {\n        return new BlockExitListener(reason);\n    }\n\n    /**\n     * @param state\n     *            the state to match\n     * @return a predicate which will return true for transitions whos target state matches the given state\n     */\n    public static Predicate<Transition> targetStateEquals(final State state)\n    {\n        if (state == null)\n        {\n            throw new NullPointerException(""state cannot be null"");\n        }\n        return new Predicate<Transition>() {\n\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return value.getTarget().equals(state);\n            }\n        };\n    }\n\n    /**\n     * @param state\n     *            the state to match\n     * @return a predicate which will return true for transitions whos source state matches the given state\n     */\n    public static Predicate<Transition> sourceStateEquals(final State state)\n    {\n        if (state == null)\n        {\n            throw new NullPointerException(""state cannot be null"");\n        }\n        return new Predicate<Transition>() {\n\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return value.getSource().equals(state);\n            }\n        };\n    }\n\n    /**\n     * @param the reason\n     * @return the registered listener\n     */\n    public static StateListener blockEntry(final State state, final Enum<?> reason)\n    {\n        final StateListener listener = filter(targetStateEquals(state), blockEntryListener(reason));\n        return listener;\n    }\n\n    /**\n     * @param the reason\n     * @return the registered listener\n     */\n    public static StateListener blockExit(final State state, final Enum<?> reason)\n    {\n        final StateListener listener = filter(sourceStateEquals(state), blockExitListener(reason));\n        return listener;\n    }\n\n    /**\n     * @param filter\n     *            the filter to apply to the given listener\n     * @param listener\n     *            the listener to wrap\n     * @return the wrapped listener\n     */\n    public static ConditionalStateListener filter(final Predicate<Transition> filter, final StateListener listener)\n    {\n        return new ConditionalStateListener(filter, listener);\n    }\n\n    /**\n     * @param listeners\n     *            the listeners to treat as a single group\n     * @return the grouped listener\n     */\n    public static GroupStateListener group(final StateListener... listeners)\n    {\n        return new GroupStateListener(listeners);\n    }\n\n    /**\n     * @param listeners\n     *            the listeners to treat as a single group\n     * @return the group listener which you can turn on and off\n     */\n    public static ConditionalStateListener group(final Predicate<Transition> predicate, final StateListener... listeners)\n    {\n        return filter(predicate, group(listeners));\n    }\n }')",[260837]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_moveToClaimsReceivedByHeadOfDelivery(aaron.test.test.ClaimsReceivedByDeliveryTeamTest)')","[15127, 15158, 15189, 17731, 17762, 17793, 26757, 26781, 26805, 39505, 39535, 39565, 57540, 57575, 57610, 60480, 60515, 60550, 70882, 70910, 70938, 81521, 81549, 81577, 98490, 98523, 98556, 101262, 101295, 101328, 110976, 111002, 111028, 122464, 122496, 122528, 141565, 141602, 141639, 144673, 144710, 144747, 155763, 155793, 155823, 168644, 168679, 168714, 189344, 189384, 189424, 192704, 192744, 192784, 204826, 204859, 204892, 218386, 218423, 218460, 240152, 240194, 240236, 243680, 243722, 243764, 302931, 302971, 303011, 304231, 304273, 304315]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsRejectToMo extends AbstractTransition<ClaimsReceivedByDeliveryTeam, ClaimsReceivedByMonitoringOfficer>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""reject to mo"";\n\n    TransitionClaimsRejectToMo(final ClaimsReceivedByDeliveryTeam from, final ClaimsReceivedByMonitoringOfficer to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[267301]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsNotReceived\n */\npublic class ClaimsNotReceivedTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the \'ClaimsNotReceived\' state\n     */\n    @Test\n    public void test_executeToClaimsNotReceived()\n    {\n        Assert.assertNotNull(moveToClaimsNotReceived());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for \'notReceived\' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.notReceived().getName();\n        Assert.assertEquals(fsm.notReceived(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the notReceived state\n     */\n    final ClaimsNotReceived moveToClaimsNotReceived()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsNotReceived notReceived = fsm.notReceived();\n\n        // call the method under test\n        fsm.executeToState(notReceived);\n\n        Assert.assertSame(notReceived, fsm.getCurrentState());\n        Assert.assertEquals(notReceived.getName(), fsm.getCurrentStateName());\n        \n        return notReceived;\n    }\n\n    \n    @Test\n    public void test_getPathBetweenClaimsNotReceivedAndClaimsReceivedByMonitoringOfficer()\n    {\n\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'notReceived\'"", notReceived, fsm.getCurrentState());\n\n        final TransitionPaths paths = notReceived.getPaths(fsm.receivedByMonitoringOfficer());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        notReceived.registerSubmitToMonitoringOfficerListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'notReceived\'"", notReceived, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.receivedByMonitoringOfficer(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'submitToMonitoringOfficer\' transition \n     */\n    @Test\n    public void test_submitToMonitoringOfficer()\n    {\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        notReceived.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        notReceived.submitToMonitoringOfficer();\n\n        //\n        // assert the current state is now ClaimsReceivedByMonitoringOfficer\n        //\n        Assert.assertEquals(fsm.receivedByMonitoringOfficer(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.receivedByMonitoringOfficer().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsSubmitToMonitoringOfficer.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsSubmitToMonitoringOfficer.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(notReceived.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsNotReceived\' can be moved into the ClaimsReceivedByMonitoringOfficer state\n     */\n    @Test\n    public void test_moveToClaimsReceivedByMonitoringOfficer()\n    {\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n        notReceived.getPaths(fsm.receivedByMonitoringOfficer());\n        \n    }\n    \n    @Test\n    public void test_getPathBetweenClaimsNotReceivedAndClaimsReceivedByDeliveryTeam()\n    {\n\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'notReceived\'"", notReceived, fsm.getCurrentState());\n\n        final TransitionPaths paths = notReceived.getPaths(fsm.receivedByDeliveryTeam());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        notReceived.registerSubmitToDeliveryTeamListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'notReceived\'"", notReceived, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.receivedByDeliveryTeam(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'submitToDeliveryTeam\' transition \n     */\n    @Test\n    public void test_submitToDeliveryTeam()\n    {\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        notReceived.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        notReceived.submitToDeliveryTeam();\n\n        //\n        // assert the current state is now ClaimsReceivedByDeliveryTeam\n        //\n        Assert.assertEquals(fsm.receivedByDeliveryTeam(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.receivedByDeliveryTeam().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsSubmitToDeliveryTeam.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsSubmitToDeliveryTeam.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(notReceived.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsNotReceived\' can be moved into the ClaimsReceivedByDeliveryTeam state\n     */\n    @Test\n    public void test_moveToClaimsReceivedByDeliveryTeam()\n    {\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n        notReceived.getPaths(fsm.receivedByDeliveryTeam());\n        \n    }\n    \n    @Test\n    public void test_getPathBetweenClaimsNotReceivedAndClaimsReceivedByHeadOfDelivery()\n    {\n\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'notReceived\'"", notReceived, fsm.getCurrentState());\n\n        final TransitionPaths paths = notReceived.getPaths(fsm.receivedByHeadOfDelivery());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        notReceived.registerSubmitToHeadOfDeliveryListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'notReceived\'"", notReceived, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'submitToHeadOfDelivery\' transition \n     */\n    @Test\n    public void test_submitToHeadOfDelivery()\n    {\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        notReceived.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        notReceived.submitToHeadOfDelivery();\n\n        //\n        // assert the current state is now ClaimsReceivedByHeadOfDelivery\n        //\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsSubmitToHeadOfDelivery.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsSubmitToHeadOfDelivery.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(notReceived.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsNotReceived\' can be moved into the ClaimsReceivedByHeadOfDelivery state\n     */\n    @Test\n    public void test_moveToClaimsReceivedByHeadOfDelivery()\n    {\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n        notReceived.getPaths(fsm.receivedByHeadOfDelivery());\n        \n    }\n}\n')",[272882]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_moveToClaimsReceivedByDeliveryTeam(aaron.test.test.ClaimsReceivedByMonitoringOfficerTest)')","[10260, 13608, 24813, 29860, 36801, 52045, 55825, 68614, 78999, 93309, 96873, 108870, 119578, 135756, 139752, 153333, 165485, 183064, 187384, 202153, 215045, 233558, 238094, 296311, 298081]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_submitToDeliveryTeam(aaron.test.test.ClaimsNotReceivedTest)')","[6912, 9516, 23469, 29526, 34847, 48265, 51205, 67046, 77177, 89745, 92517, 107414, 117492, 131760, 134868, 151653, 163201, 178744, 182104, 200305, 212629, 229022, 232550, 290691, 292501]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_generalListeners(aaron.test.test.ClaimsStateMachineTest)')","[1739, 18444, 19808, 27789, 30571, 41069, 41212, 61285, 62825, 72086, 82979, 83112, 102021, 103473, 112094, 124134, 124287, 145524, 147152, 157053, 170473, 170641, 193624, 195384, 206245, 220321, 220499, 244646, 246494, 307023, 307185]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.HashMap;\n        \nabstract class AbstractClaimsState implements State\n{\n    private final Map<String, Transition> transitionsByName;\n\n    private final ClaimsStateMachine stateMachine;\n    private final StateNotifier notifier;\n    \n    AbstractClaimsState(final ClaimsStateMachine fsm)\n    {\n        if (fsm == null)\n        {\n            throw new NullPointerException(""state machine cannot be null"");\n        }\n        this.stateMachine = fsm;\n        this.notifier = fsm.newNotifier();\n        this.transitionsByName = new HashMap<String, Transition>();\n    }\n    \n    public ClaimsStateMachine getStateMachine()\n    {\n        return this.stateMachine;\n    }\n\n\n    /**\n     * @param fsm\n     */\n    void initialise()\n    {\n        for(final Transition transition  : initialiseTransitions())\n        {\n            this.transitionsByName.put(transition.getName(), transition);\n        }    \n    }\n    \n    Collection<Transition> getTransitions()\n    {\n        return this.transitionsByName.values();\n    }\n\n    Collection<String> getTransitionNames()\n    {\n        return this.transitionsByName.keySet();\n    }\n    \n    final Transition getTransitionForName(final String name)\n    {\n        return this.transitionsByName.get(name);\n    }\n\n    abstract Collection<Transition> initialiseTransitions();\n\n    /**\n     * @return true if the listener was successfully registered\n     */\n    public <T extends StateListener> T registerListener(final T listener)\n    {\n        final boolean registered = this.notifier.registerListener(listener);\n        assert registered : ""listener not registered: "" + listener;\n        return listener;\n    }\n\n    public boolean unregisterListener(final StateListener listener)\n    {\n        return this.notifier.unregisterListener(listener);\n    }\n\n    final TransitionGuard onExit(final Transition transition)\n    {\n        return this.notifier.onBeforeTransition(transition);\n    }\n\n    final TransitionGuard onEnter(final Transition transition)\n    {\n        return this.notifier.onAfterTransition(transition);\n    }\n\n    /**\n     * @param the target state\n     * @return the transition paths\n     */\n    public TransitionPaths getPaths(final State toState)\n    {\n        final TransitionPaths paths = new TransitionPaths();\n        final TransitionPath path = new TransitionPath(this);\n\n        appendPathRecursive(paths, path, toState);\n\n        return paths;\n    }\n\n    private void appendPathRecursive(final TransitionPaths paths, final TransitionPath srcPath, final State goal)\n    {\n        for (final Transition transition : getTransitions())\n        {\n            final TransitionPath path = srcPath.clonePath();\n            final AbstractClaimsState targetState = (AbstractClaimsState) transition.getTarget();\n\n            final boolean notRecursivePathLoop = path.add(targetState, transition);\n\n            if (notRecursivePathLoop)\n            {\n                if (targetState.equals(goal))\n                {\n                   paths.add(path); \n                }\n                else\n                {\n                    targetState.appendPathRecursive(paths, path, goal);\n                }\n            }\n        }\n    }\n    \n    /**\n     *\n     */\n    @Override\n    public String toString()\n    {\n        final StringBuilder builder = new StringBuilder();\n        final String newLine = String.format(""%n"");\n        builder.append(getName()).append(newLine);\n        for (final Transition transition : getTransitions())\n        {\n            builder.append(""\\t"").append(transition).append(newLine);\n        }\n        builder.append(""\\t"").append(this.notifier).append(newLine);\n        return builder.toString();\n    }\n}\n')",[263336]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsRejectToDeliveryTeam extends AbstractTransition<ClaimsReceivedByHeadOfDelivery, ClaimsReceivedByDeliveryTeam>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""reject to delivery team"";\n\n    TransitionClaimsRejectToDeliveryTeam(final ClaimsReceivedByHeadOfDelivery from, final ClaimsReceivedByDeliveryTeam to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[265157]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\n/**\n * if you use google collections, refactor to use that instead \n */\npublic enum StateLog\n{\n    ;// uninstantiable\n\n    public static String error(final String format, final Object... args)\n    {\n        final String log = ""_error:"" + String.format(format, args);\n        System.out.println(log);\n        return log;\n    }\n\n    public static String info(final String format, final Object... args)\n    {\n        final String log = ""_info:"" + String.format(format, args);\n        System.out.println(log);\n        return log;\n    }\n\n    public static String debug(final String format, final Object... args)\n    {\n        final String log = ""_debug:"" + String.format(format, args);\n        System.out.println(log);\n        return log;\n    }\n    \n    public static String trace(final String format, final Object... args)\n    {\n        return ""_trace:"" + String.format(format, args);\n    }\n}\n')",[278102]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsApproveForHeadOfDelivery extends AbstractTransition<ClaimsReceivedByMonitoringOfficer, ClaimsReceivedByHeadOfDelivery>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""approve for head of delivery"";\n\n    TransitionClaimsApproveForHeadOfDelivery(final ClaimsReceivedByMonitoringOfficer from, final ClaimsReceivedByHeadOfDelivery to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[269064]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_rejectPayment(aaron.test.test.ClaimsReadyForPaymentTest)')","[8028, 11748, 24141, 29693, 35824, 49525, 53725, 67830, 78088, 90933, 94893, 108142, 118535, 133092, 137532, 152493, 164343, 180184, 184984, 201229, 213837, 230534, 235574, 293753, 295051]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_cannotAddTwoStatesWithTheSameName(com.porpoise.fsm.model.StateMachineTest)')","[2448, 3564, 21549, 28966, 31488, 43225, 44485, 64806, 74048, 84993, 86181, 105334, 113903, 126432, 127764, 149253, 159267, 172984, 174424, 197665, 208465, 222974, 224486, 249148, 250134]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p.test;\nimport p.*;\nimport org.junit.*;\n\n/**\n * tests for TestStateMachine\n */\n@Ignore(""base class"")\nabstract class AbstractTestTest \n{\n    /**\n     *\n     */\n    protected TestStateMachine newStateMachine()\n    {\n        final TestStateMachine fsm = TestStateMachine.createAndStart(); \n        Assert.assertNotNull(fsm);\n        return fsm;\n    }\n}\n')",[287037]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsMarkAsReadyForPayment extends AbstractTransition<ClaimsReceivedByHeadOfDelivery, ClaimsReadyForPayment>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""mark as ready for payment"";\n\n    TransitionClaimsMarkAsReadyForPayment(final ClaimsReceivedByHeadOfDelivery from, final ClaimsReadyForPayment to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[265210]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_generalListeners(aaron.test.test.ClaimsStateMachineTest)')","[1763, 1787, 1811, 18475, 18506, 18537, 19839, 19870, 19901, 27813, 27837, 27861, 30591, 41099, 41129, 41159, 41240, 41268, 41296, 61320, 61355, 61390, 62860, 62895, 62930, 72114, 72142, 72170, 83007, 83035, 83063, 83138, 83164, 83190, 102054, 102087, 102120, 103506, 103539, 103572, 112120, 112146, 112172, 124166, 124198, 124230, 124317, 124347, 124377, 145561, 145598, 145635, 147189, 147226, 147263, 157083, 157113, 157143, 170508, 170543, 170578, 170674, 170707, 170740, 193664, 193704, 193744, 195424, 195464, 195504, 206278, 206311, 206344, 220358, 220395, 220432, 220534, 220569, 220604, 244688, 244730, 244772, 246536, 246578, 246620, 307063, 307103, 307143, 307227, 307269, 307311]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * A PathEntry represents a link in the chain of a \'path\' from one state to another.\n * Each link in a path denotes a new target state and the transition used to get there. \n */\nfinal class PathEntry\n{\n    private final State      state;\n    private final Transition viaTransition;\n\n    PathEntry(final State stateValue, final Transition transitionValue)\n    {\n        this.state = stateValue;\n        this.viaTransition = transitionValue;\n    }\n\n    PathEntry(final State startState)\n    {\n        this(startState, null);\n    }\n\n    /**\n     * @return the state from this transition\n     */\n    public State getState()\n    {\n        return this.state;\n    }\n\n    /**\n     * @return the transition used to arrive at the next state\n     */\n    public Transition getTransition()\n    {\n        return this.viaTransition;\n    }\n\n    /**\n     * execute the given path. Return true if all transitions executed successfully\n     * \n     * @return a non-null collection of reasons should the transition fail\n     */\n    final Collection<Enum<?>> execute()\n    {\n        if (getTransition() != null)\n        {\n            return getTransition().execute();\n        }\n        return Collections.emptyList();\n    }\n\n    @Override\n    public int hashCode()\n    {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((this.state == null) ? 0 : this.state.hashCode());\n        result = prime * result + ((this.viaTransition == null) ? 0 : this.viaTransition.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(final Object obj)\n    {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        final PathEntry other = (PathEntry) obj;\n        if (this.state == null)\n        {\n            if (other.state != null)\n                return false;\n        }\n        else if (!this.state.equals(other.state))\n            return false;\n        if (this.viaTransition == null)\n        {\n            if (other.viaTransition != null)\n                return false;\n        }\n        else if (!this.viaTransition.equals(other.viaTransition))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString()\n    {\n        if (this.viaTransition == null)\n            return this.state.getName();\n        return String.format(""--[%s]-->%s"", this.viaTransition.getName(), this.state.getName());\n    }\n}')",[282565]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsReceivedByMonitoringOfficerAndClaimsNotReceived(aaron.test.test.ClaimsReceivedByMonitoringOfficerTest)')","[11128, 14476, 25485, 30007, 37641, 53025, 56805, 69398, 79783, 94233, 97797, 109598, 120474, 136792, 140788, 154173, 166465, 184184, 188504, 203077, 216081, 234734, 239270, 297431, 299257]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_executeToClaimsReceivedByHeadOfDelivery(aaron.test.test.ClaimsReceivedByHeadOfDeliveryTest)')","[12771, 12802, 12833, 16119, 16150, 16181, 25989, 26013, 26037, 38408, 38438, 38468, 54880, 54915, 54950, 58660, 58695, 58730, 69986, 70014, 70042, 80498, 80526, 80554, 95982, 96015, 96048, 99546, 99579, 99612, 110144, 110170, 110196, 121293, 121325, 121357, 138753, 138790, 138827, 142749, 142786, 142823, 154803, 154833, 154863, 167362, 167397, 167432, 186304, 186344, 186384, 190624, 190664, 190704, 203770, 203803, 203836, 217030, 217067, 217104, 236960, 237002, 237044, 241496, 241538, 241580, 300213, 300253, 300293, 301513, 301555, 301597]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\binterface (\\w+).*', 'package p;\n\n/**\n * represents the state in a state machine\n */\npublic interface State extends NamedObject\n{\n    /**\n     * Return a unique name for this state.\n     * \n     * A state may need to be persisted, a common way to do this is \n     * to persist an enumeration of state values.\n     *   \n     * @return the unique name of this state\n     */\n    @Override\n    public String getName();\n    \n    /**\n     * allow callbacks to register their interest\n     * @param listener the listener to register\n     * @return true if the listener was registered successfully\n     */\n    <T extends StateListener> T registerListener(final T listener);\n\n    /**\n     * allow callbacks (listeners) to unregister their interest\n     * @param listener the listener to unregister\n     * @return true if the listener was unregistered successfully\n     */\n    boolean unregisterListener(final StateListener listener);\n    \n    /**\n     * @return an object representing all paths to the given state from this state\n     */\n    TransitionPaths getPaths(final State to);\n}\n')",[277915]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'aaron.test.test.ClaimsReceivedByMonitoringOfficerTest')","[302461, 302484, 302508, 302531]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\nimport java.util.Collection;\n\n/**\n * Transition represents a transition between two states \n */\npublic interface Transition extends NamedObject\n{\n    /**\n     * General failure reasons for transitions\n     */\n    enum Reasons\n    {\n        /** \n         * The current state of the state machine does not match the source state of the transition\n         */\n        INVALID_SOURCE_STATE;\n    }\n\n    /** \n     * execute the transition\n     * @return the new state\n     */\n    Collection<Enum<?>> execute();\n     \n    /**\n     * @return the source state\n     */\n    State getSource();\n     \n    /**\n     * @return the target state\n     */\n    State getTarget();\n\n    /**\n     * @param listener\n     * @return the registered listener\n     */\n    <T extends TransitionListener> T registerListener(final T listener);\n\n    /**\n     * @param listener\n     * @return true if the listener was removed successfully\n     */\n    boolean unregisterListener(final TransitionListener listener);\n}\n')",[285372]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'aaron.test.test.ClaimsReadyForPaymentTest')","[299743, 299766, 299790, 299813]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsReceivedByDeliveryTeamAndClaimsReceivedByHeadOfDelivery(aaron.test.test.ClaimsReceivedByDeliveryTeamTest)')","[15623, 15654, 15685, 18227, 18258, 18289, 27141, 27165, 27189, 39985, 40015, 40045, 58100, 58135, 58170, 61040, 61075, 61110, 71330, 71358, 71386, 81969, 81997, 82025, 99018, 99051, 99084, 101790, 101823, 101856, 111392, 111418, 111444, 122976, 123008, 123040, 142157, 142194, 142231, 145265, 145302, 145339, 156243, 156273, 156303, 169204, 169239, 169274, 189984, 190024, 190064, 193344, 193384, 193424, 205354, 205387, 205420, 218978, 219015, 219052, 240824, 240866, 240908, 244352, 244394, 244436, 303571, 303611, 303651, 304903, 304945, 304987]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_executeToClaimsPaymentRejected(aaron.test.test.ClaimsPaymentRejectedTest)')","[20180, 28557, 30799, 42303, 63245, 72982, 84129, 103869, 112926, 125452, 147596, 158013, 171917, 195864, 207301, 221849, 246998, 309499, 310317]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsMarkPaymentAsReceived extends AbstractTransition<ClaimsReadyForPayment, ClaimsPaymentReceived>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""mark payment as received"";\n\n    TransitionClaimsMarkPaymentAsReceived(final ClaimsReadyForPayment from, final ClaimsPaymentReceived to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[264566]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\n/**\n * listener callback interface \n */\npublic interface TransitionListener\n{\n\n    /**\n     * fired when a transition is executed\n     * @return the transition guard\n     */\n    TransitionGuard onTransition(final Transition transition);\n}\n')",[256840]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getStateForName(aaron.test.test.ClaimsReceivedByHeadOfDeliveryTest)')","[1388, 12492, 15840, 25773, 30070, 38138, 39121, 54565, 58345, 69734, 80246, 81163, 95685, 99249, 109910, 121005, 122054, 138420, 142416, 154533, 167047, 168195, 185944, 190264, 203473, 216697, 217911, 236582, 241118, 299853, 301135]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'aaron.test.test.ClaimsNotReceivedTest')","[296041, 296064, 296088, 296111]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_moveToClaimsReceivedByDeliveryTeam(aaron.test.test.ClaimsReceivedByHeadOfDeliveryTest)')","[12616, 15964, 25869, 30111, 38258, 54705, 58485, 69846, 80358, 95817, 99381, 110014, 121133, 138568, 142564, 154653, 167187, 186104, 190424, 203605, 216845, 236750, 241286, 300013, 301303]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsSubmitToMonitoringOfficer extends AbstractTransition<ClaimsNotReceived, ClaimsReceivedByMonitoringOfficer>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""submit to monitoring officer"";\n\n    TransitionClaimsSubmitToMonitoringOfficer(final ClaimsNotReceived from, final ClaimsReceivedByMonitoringOfficer to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[265912]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\npublic interface NamedObject\n{\n    /**\n     * @return a name for the object\n     */\n    public String getName();\n}\n')",[254383]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'com.porpoise.fsm.generator.context.ContextTest')","[779, 33608, 76022, 116169, 161752, 211096]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_create(com.porpoise.fsm.model.StateMachineTest)')","[2231, 2262, 2293, 3347, 3378, 3409, 21381, 21405, 21429, 31278, 31308, 31338, 42980, 43015, 43050, 44240, 44275, 44310, 64610, 64638, 64666, 73852, 73880, 73908, 84762, 84795, 84828, 85950, 85983, 86016, 105152, 105178, 105204, 113679, 113711, 113743, 126173, 126210, 126247, 127505, 127542, 127579, 149043, 149073, 149103, 159022, 159057, 159092, 172704, 172744, 172784, 174144, 174184, 174224, 197434, 197467, 197500, 208206, 208243, 208280, 222680, 222722, 222764, 224192, 224234, 224276, 248868, 248908, 248948, 249840, 249882, 249924]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsStartState extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""start-state"";\n\n    private TransitionClaimsInit init; \n    \n    /**\n     * @param fsm\n     */\n    ClaimsStartState(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        // Transition init\n        this.init = new TransitionClaimsInit(this, getStateMachine().notReceived());\n        allTransitions.add(this.init); \n\n        return allTransitions;    \n    }\n    \n    /**\n     * execute the init transition\n     * @return true if the transition was successful\n     */\n    public boolean init() {\n        this.init.execute();\n        return this.init.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerInitListener(final T listener)\n    {\n        return this.init.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterInitListener(final TransitionListener listener)\n    {\n        return this.init.unregisterListener(listener);\n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[267990]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\n/**\n * a listener which groups other listeners\n */\npublic class GroupStateListener implements StateListener \n{\n    private final StateNotifier notifier;\n\n    /**\n     */\n    public GroupStateListener(final StateListener ... listeners)\n    {\n        this.notifier = new StateNotifier();\n        for (final StateListener listener : listeners)\n        {\n            this.notifier.registerListener(listener);\n        }\n    }\n   \n    @Override\n    public TransitionGuard onExit(final Transition transition)\n    {\n        return this.notifier.onBeforeTransition(transition);\n    }\n\n    @Override\n    public TransitionGuard onEnter(final Transition transition)\n    {\n        return this.notifier.onAfterTransition(transition);\n    }\n\n    /**\n     * @return the string representation of this listener\n     */\n    @Override\n    public String toString()\n    {\n        return String.format(""group listener {%s}"", this.notifier);\n    }\n}\n')",[279862]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getStateForName(aaron.test.test.ClaimsNotReceivedTest)')","[1037, 6168, 8772, 22893, 29380, 34127, 35470, 47425, 50365, 66374, 76505, 77758, 88953, 91725, 106790, 116724, 118157, 130872, 133980, 150933, 162361, 163929, 177784, 181144, 199513, 211741, 213399, 228014, 231542, 289731, 291493]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_join(com.porpoise.fsm.model.StateTest)')","[335, 2944, 4060, 21837, 29029, 31985, 32248, 43785, 45045, 65142, 74511, 74756, 85521, 86709, 105646, 114434, 114715, 127024, 128356, 149613, 159849, 160157, 173624, 175064, 198061, 209081, 209407, 223646, 225158, 250730, 251052]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsReadyForPaymentAndClaimsPaymentReceived(aaron.test.test.ClaimsReadyForPaymentTest)')","[8307, 8338, 8369, 12027, 12058, 12089, 24357, 24381, 24405, 36094, 36124, 36154, 49840, 49875, 49910, 54040, 54075, 54110, 68082, 68110, 68138, 78340, 78368, 78396, 91230, 91263, 91296, 95190, 95223, 95256, 108376, 108402, 108428, 118823, 118855, 118887, 133425, 133462, 133499, 137865, 137902, 137939, 152763, 152793, 152823, 164658, 164693, 164728, 180544, 180584, 180624, 185344, 185384, 185424, 201526, 201559, 201592, 214170, 214207, 214244, 230912, 230954, 230996, 235952, 235994, 236036, 294113, 294153, 294193, 295429, 295471, 295513]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getStateForName(aaron.test.test.ClaimsPaymentRejectedTest)')","[1997, 2021, 2045, 19963, 19994, 20025, 28389, 28413, 28437, 30757, 42093, 42123, 42153, 42714, 42742, 42770, 63000, 63035, 63070, 72786, 72814, 72842, 83933, 83961, 83989, 84512, 84538, 84564, 103638, 103671, 103704, 112744, 112770, 112796, 125228, 125260, 125292, 125891, 125921, 125951, 147337, 147374, 147411, 157803, 157833, 157863, 171672, 171707, 171742, 172398, 172431, 172464, 195584, 195624, 195664, 207070, 207103, 207136, 221590, 221627, 221664, 222358, 222393, 222428, 246704, 246746, 246788, 309219, 309259, 309299, 310023, 310065, 310107]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport com.google.common.base.Predicate;\n\n/** \n */\npublic final class ConditionalTransitionListener implements TransitionListener\n{\n    private final  TransitionGuard onFalseResult;\n    private final Predicate<Transition> filter;\n    private final TransitionListener delegate;    \n    /**\n     * @param predicate\n     */\n    public ConditionalTransitionListener(final Predicate<Transition> predicate, final TransitionListener wrappedListener)\n    {\n        this(predicate, wrappedListener, TransitionGuard.ok());\n    }\n    \n    /**\n     * @param predicate\n     */\n    public ConditionalTransitionListener(final Predicate<Transition> predicate, final TransitionListener wrappedListener, final TransitionGuard onFalseResultParam)\n    {\n        if (predicate == null)\n        {\n            throw new NullPointerException(""predicate cannot be null"");        \n        }\n        if (wrappedListener == null)\n        {\n            throw new NullPointerException(""wrappedListener cannot be null"");        \n        }\n        if (onFalseResultParam == null)\n        {\n            throw new NullPointerException(""onFalseResultParam cannot be null"");        \n        }\n        this.filter = predicate;\n        this.onFalseResult = onFalseResultParam;\n        this.delegate = wrappedListener; \n    }\n    \n    /**\n     * fired when a transition is executed\n     * \n     * @return the transition guard\n     */\n    @Override\n    public TransitionGuard onTransition(final Transition transition)\n    {\n        if (this.filter.apply(transition))\n        {\n            return this.delegate.onTransition(transition);\n        }\n        return this.onFalseResult;\n    }\n}\n')",[256060]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsMarkPaymentAsReceived extends AbstractTransition<ClaimsReadyForPayment, ClaimsPaymentReceived>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""mark payment as received"";\n\n    TransitionClaimsMarkPaymentAsReceived(final ClaimsReadyForPayment from, final ClaimsPaymentReceived to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[264513]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\n\n/**\n * A collection of useful implementations of TransitionListener\n */\npublic enum TransitionListeners \n{\n    ;//uninstantiable\n\n    /**\n     * a listener which records the transitions\n     */\n    public static class RecordingTransitionListener implements TransitionListener\n    {\n        private final List<Transition> transitions = new ArrayList<Transition>();\n\n        @Override\n        public TransitionGuard onTransition(final Transition transition)\n        {\n            this.transitions.add(transition);\n            return TransitionGuard.ok();\n        }\n\n        /**\n         * @return the enter transitions\n         */\n        public List<Transition> getTransitions()\n        {\n            return Collections.unmodifiableList(this.transitions);\n        }\n    }\n    \n    private static class BlockingListener implements TransitionListener\n    {\n        private final Enum<?> reason;\n        public BlockingListener(final Enum<?> reasonValue)\n        {\n            this.reason = reasonValue;\n        }\n    \n        @Override\n        public TransitionGuard onTransition(final Transition transition)\n        {\n            return TransitionGuard.stopEventually(this.reason);\n        }\n    }\n    \n    private static TransitionListener BLOCKING_INSTANCE = new BlockingListener(null); \n\n    /**\n     * @return a new recording transition listener\n     */\n    public static RecordingTransitionListener recordingListener()\n    {\n        return new RecordingTransitionListener();\n    }\n    /**\n     * @return a listener which returns @{code TransitionGuard.stopEventually()}\n     */\n    public static TransitionListener blockingListener()\n    {\n        return BLOCKING_INSTANCE;\n    }\n    /**\n     * @return a listener which returns @{code TransitionGuard.stopEventually()}\n     */\n    public static TransitionListener blockingListener(final Enum<?> reason)\n    {\n        return new BlockingListener(reason);\n    }\n    \n    /**\n     * @return a listener which disallows transitions when the given condition returns false\n     */\n    public static TransitionListener blockOnFalse(final Predicate<Transition> condition, final Enum<?> reason)\n    {\n        final TransitionListener delegate = TransitionListeners.blockingListener(reason);\n        final TransitionListener listener = filter(condition, delegate);\n        return listener;\n    }\n\n    /**\n     * @param condition\n     *            the condition (predicate) used to evaluate whether or not the given listener should be invoked\n     * @param delegate\n     *            the listener to invoke when the condition returns true\n     * @return the conditional listener which wraps the given listener\n     */\n    public static ConditionalTransitionListener filter(final Predicate<Transition> condition, final TransitionListener delegate)\n    {\n        final ConditionalTransitionListener listener = new ConditionalTransitionListener(condition, delegate);\n        return listener;\n    }    \n    /**\n     * @return a listener which disallows transitions when the given condition returns true\n     */\n    public static TransitionListener blockOnTrue(final Predicate<Transition> condition, final Enum<?> reason)\n    {\n        return blockOnFalse(Predicates.not(condition), reason);\n    }\n\n }')",[255252]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_moveToClaimsNotReceived(aaron.test.test.ClaimsReceivedByMonitoringOfficerTest)')","[11376, 14724, 25677, 30049, 37881, 53305, 57085, 69622, 80007, 94497, 98061, 109806, 120730, 137088, 141084, 154413, 166745, 184504, 188824, 203341, 216377, 235070, 239606, 297751, 299593]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsNotReceivedAndClaimsReceivedByMonitoringOfficer(aaron.test.test.ClaimsNotReceivedTest)')","[6447, 6478, 6509, 9051, 9082, 9113, 23109, 23133, 23157, 34397, 34427, 34457, 47740, 47775, 47810, 50680, 50715, 50750, 66626, 66654, 66682, 76757, 76785, 76813, 89250, 89283, 89316, 92022, 92055, 92088, 107024, 107050, 107076, 117012, 117044, 117076, 131205, 131242, 131279, 134313, 134350, 134387, 151203, 151233, 151263, 162676, 162711, 162746, 178144, 178184, 178224, 181504, 181544, 181584, 199810, 199843, 199876, 212074, 212111, 212148, 228392, 228434, 228476, 231920, 231962, 232004, 290091, 290131, 290171, 291871, 291913, 291955]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_markAsReadyForPayment(aaron.test.test.ClaimsReceivedByHeadOfDeliveryTest)')","[13236, 16584, 26349, 30216, 38858, 55405, 59185, 70406, 80918, 96477, 100041, 110534, 121773, 139308, 143304, 155253, 167887, 186904, 191224, 204265, 217585, 237590, 242126, 300813, 302143]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\n/**\n * represents the state in a state machine\n */\npublic interface State extends NamedObject\n{\n    /**\n     * Return a unique name for this state.\n     * \n     * A state may need to be persisted, a common way to do this is \n     * to persist an enumeration of state values.\n     *   \n     * @return the unique name of this state\n     */\n    @Override\n    public String getName();\n    \n    /**\n     * allow callbacks to register their interest\n     * @param listener the listener to register\n     * @return true if the listener was registered successfully\n     */\n    <T extends StateListener> T registerListener(final T listener);\n\n    /**\n     * allow callbacks (listeners) to unregister their interest\n     * @param listener the listener to unregister\n     * @return true if the listener was unregistered successfully\n     */\n    boolean unregisterListener(final StateListener listener);\n    \n    /**\n     * @return an object representing all paths to the given state from this state\n     */\n    TransitionPaths getPaths(final State to);\n}\n')",[254677]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_addState(com.porpoise.fsm.model.StateMachineTest)')","[2696, 3812, 21741, 29008, 31728, 43505, 44765, 65030, 74272, 85257, 86445, 105542, 114159, 126728, 128060, 149493, 159547, 173304, 174744, 197929, 208761, 223310, 224822, 249468, 250470]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_multipleOccurrences(com.porpoise.fsm.generator.FilenameHelperTest)')","[4835, 4866, 4897, 5579, 5610, 5641, 22437, 22461, 22485, 33146, 33176, 33206, 45920, 45955, 45990, 46760, 46795, 46830, 65842, 65870, 65898, 75592, 75620, 75648, 87534, 87567, 87600, 88326, 88359, 88392, 106296, 106322, 106348, 115675, 115707, 115739, 129281, 129318, 129355, 130169, 130206, 130243, 150363, 150393, 150423, 161210, 161245, 161280, 176064, 176104, 176144, 177024, 177064, 177104, 198886, 198919, 198952, 210522, 210559, 210596, 226208, 226250, 226292, 227216, 227258, 227300, 287612, 287652, 287692, 287944, 287986, 288028]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_moveToClaimsNotReceived(aaron.test.test.ClaimsReceivedByMonitoringOfficerTest)')","[11407, 11438, 11469, 14755, 14786, 14817, 25701, 25725, 25749, 37911, 37941, 37971, 53340, 53375, 53410, 57120, 57155, 57190, 69650, 69678, 69706, 80035, 80063, 80091, 94530, 94563, 94596, 98094, 98127, 98160, 109832, 109858, 109884, 120762, 120794, 120826, 137125, 137162, 137199, 141121, 141158, 141195, 154443, 154473, 154503, 166780, 166815, 166850, 184544, 184584, 184624, 188864, 188904, 188944, 203374, 203407, 203440, 216414, 216451, 216488, 235112, 235154, 235196, 239648, 239690, 239732, 297791, 297831, 297871, 299635, 299677, 299719]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\n/**\n * represents the state in a state machine\n */\npublic interface State extends NamedObject\n{\n    /**\n     * Return a unique name for this state.\n     * \n     * A state may need to be persisted, a common way to do this is \n     * to persist an enumeration of state values.\n     *   \n     * @return the unique name of this state\n     */\n    @Override\n    public String getName();\n    \n    /**\n     * allow callbacks to register their interest\n     * @param listener the listener to register\n     * @return true if the listener was registered successfully\n     */\n    <T extends StateListener> T registerListener(final T listener);\n\n    /**\n     * allow callbacks (listeners) to unregister their interest\n     * @param listener the listener to unregister\n     * @return true if the listener was unregistered successfully\n     */\n    boolean unregisterListener(final StateListener listener);\n    \n    /**\n     * @return an object representing all paths to the given state from this state\n     */\n    TransitionPaths getPaths(final State to);\n}\n')",[277978]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsReceivedByMonitoringOfficer\n */\npublic class ClaimsReceivedByMonitoringOfficerTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the \'ClaimsReceivedByMonitoringOfficer\' state\n     */\n    @Test\n    public void test_executeToClaimsReceivedByMonitoringOfficer()\n    {\n        Assert.assertNotNull(moveToClaimsReceivedByMonitoringOfficer());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for \'receivedByMonitoringOfficer\' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.receivedByMonitoringOfficer().getName();\n        Assert.assertEquals(fsm.receivedByMonitoringOfficer(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the receivedByMonitoringOfficer state\n     */\n    final ClaimsReceivedByMonitoringOfficer moveToClaimsReceivedByMonitoringOfficer()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = fsm.receivedByMonitoringOfficer();\n\n        // call the method under test\n        fsm.executeToState(receivedByMonitoringOfficer);\n\n        Assert.assertSame(receivedByMonitoringOfficer, fsm.getCurrentState());\n        Assert.assertEquals(receivedByMonitoringOfficer.getName(), fsm.getCurrentStateName());\n        \n        return receivedByMonitoringOfficer;\n    }\n\n    \n    @Test\n    public void test_getPathBetweenClaimsReceivedByMonitoringOfficerAndClaimsReceivedByDeliveryTeam()\n    {\n\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'receivedByMonitoringOfficer\'"", receivedByMonitoringOfficer, fsm.getCurrentState());\n\n        final TransitionPaths paths = receivedByMonitoringOfficer.getPaths(fsm.receivedByDeliveryTeam());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        receivedByMonitoringOfficer.registerApproveForDeliveryTeamListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'receivedByMonitoringOfficer\'"", receivedByMonitoringOfficer, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.receivedByDeliveryTeam(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'approveForDeliveryTeam\' transition \n     */\n    @Test\n    public void test_approveForDeliveryTeam()\n    {\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        receivedByMonitoringOfficer.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        receivedByMonitoringOfficer.approveForDeliveryTeam();\n\n        //\n        // assert the current state is now ClaimsReceivedByDeliveryTeam\n        //\n        Assert.assertEquals(fsm.receivedByDeliveryTeam(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.receivedByDeliveryTeam().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsApproveForDeliveryTeam.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsApproveForDeliveryTeam.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(receivedByMonitoringOfficer.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReceivedByMonitoringOfficer\' can be moved into the ClaimsReceivedByDeliveryTeam state\n     */\n    @Test\n    public void test_moveToClaimsReceivedByDeliveryTeam()\n    {\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n        receivedByMonitoringOfficer.getPaths(fsm.receivedByDeliveryTeam());\n        \n    }\n    \n    @Test\n    public void test_getPathBetweenClaimsReceivedByMonitoringOfficerAndClaimsReceivedByHeadOfDelivery()\n    {\n\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'receivedByMonitoringOfficer\'"", receivedByMonitoringOfficer, fsm.getCurrentState());\n\n        final TransitionPaths paths = receivedByMonitoringOfficer.getPaths(fsm.receivedByHeadOfDelivery());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        receivedByMonitoringOfficer.registerApproveForHeadOfDeliveryListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'receivedByMonitoringOfficer\'"", receivedByMonitoringOfficer, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'approveForHeadOfDelivery\' transition \n     */\n    @Test\n    public void test_approveForHeadOfDelivery()\n    {\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        receivedByMonitoringOfficer.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        receivedByMonitoringOfficer.approveForHeadOfDelivery();\n\n        //\n        // assert the current state is now ClaimsReceivedByHeadOfDelivery\n        //\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsApproveForHeadOfDelivery.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsApproveForHeadOfDelivery.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(receivedByMonitoringOfficer.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReceivedByMonitoringOfficer\' can be moved into the ClaimsReceivedByHeadOfDelivery state\n     */\n    @Test\n    public void test_moveToClaimsReceivedByHeadOfDelivery()\n    {\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n        receivedByMonitoringOfficer.getPaths(fsm.receivedByHeadOfDelivery());\n        \n    }\n    \n    @Test\n    public void test_getPathBetweenClaimsReceivedByMonitoringOfficerAndClaimsNotReceived()\n    {\n\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'receivedByMonitoringOfficer\'"", receivedByMonitoringOfficer, fsm.getCurrentState());\n\n        final TransitionPaths paths = receivedByMonitoringOfficer.getPaths(fsm.notReceived());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        receivedByMonitoringOfficer.registerRejectToParticipantListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'receivedByMonitoringOfficer\'"", receivedByMonitoringOfficer, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.notReceived(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'rejectToParticipant\' transition \n     */\n    @Test\n    public void test_rejectToParticipant()\n    {\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        receivedByMonitoringOfficer.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        receivedByMonitoringOfficer.rejectToParticipant();\n\n        //\n        // assert the current state is now ClaimsNotReceived\n        //\n        Assert.assertEquals(fsm.notReceived(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.notReceived().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsRejectToParticipant.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsRejectToParticipant.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(receivedByMonitoringOfficer.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReceivedByMonitoringOfficer\' can be moved into the ClaimsNotReceived state\n     */\n    @Test\n    public void test_moveToClaimsNotReceived()\n    {\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n        receivedByMonitoringOfficer.getPaths(fsm.notReceived());\n        \n    }\n}\n')",[276155]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsApproveForHod extends AbstractTransition<ClaimsReceivedByDeliveryTeam, ClaimsReceivedByHeadOfDelivery>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""approve for hod"";\n\n    TransitionClaimsApproveForHod(final ClaimsReceivedByDeliveryTeam from, final ClaimsReceivedByHeadOfDelivery to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[267513]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsRejectToParticipant extends AbstractTransition<ClaimsReceivedByMonitoringOfficer, ClaimsNotReceived>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""reject to participant"";\n\n    TransitionClaimsRejectToParticipant(final ClaimsReceivedByMonitoringOfficer from, final ClaimsNotReceived to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[269223]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'aaron.test.test.ClaimsStateMachineTest')","[1715, 41184, 83086, 124257, 170608, 220464]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsPaymentReceivedAndClaimsPaymentComplete(aaron.test.test.ClaimsPaymentReceivedTest)')","[19467, 19498, 19529, 20831, 20862, 20893, 28101, 28125, 28149, 41596, 41626, 41656, 62440, 62475, 62510, 63980, 64015, 64050, 72450, 72478, 72506, 83470, 83498, 83526, 103110, 103143, 103176, 104562, 104595, 104628, 112432, 112458, 112484, 124697, 124729, 124761, 146745, 146782, 146819, 148373, 148410, 148447, 157443, 157473, 157503, 171090, 171125, 171160, 194944, 194984, 195024, 196704, 196744, 196784, 206674, 206707, 206740, 220974, 221011, 221048, 246032, 246074, 246116, 247880, 247922, 247964, 307805, 307845, 307885, 308625, 308667, 308709]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsPaymentRejected extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""Payment Rejected"";\n\n    private TransitionClaimsResubmitForPayment resubmitForPayment; \n    \n    /**\n     * @param fsm\n     */\n    ClaimsPaymentRejected(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        // Transition resubmit for payment\n        this.resubmitForPayment = new TransitionClaimsResubmitForPayment(this, getStateMachine().readyForPayment());\n        allTransitions.add(this.resubmitForPayment); \n\n        return allTransitions;    \n    }\n    \n    /**\n     * execute the resubmit for payment transition\n     * @return true if the transition was successful\n     */\n    public boolean resubmitForPayment() {\n        this.resubmitForPayment.execute();\n        return this.resubmitForPayment.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerResubmitForPaymentListener(final T listener)\n    {\n        return this.resubmitForPayment.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterResubmitForPaymentListener(final TransitionListener listener)\n    {\n        return this.resubmitForPayment.unregisterListener(listener);\n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[263550]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * <p>\n * A TransitionPathResult represents the result of trying to execute a {@link TransitionPath}.\n * You can query the result, asking if it was successful or not. In the case where it was not\n * successful, you can retrieve a collection of \'reason\' enumerations, which indicate why the\n * path was not successful. The reasons given will be those from the exit/enter state guards or \n * transition guards. \n * </p>\n * See {@link TransitionPath#execute()}.\n */\npublic final class TransitionPathResult\n{\n    private Collection<Enum<?>> reasons;\n    private PathEntry failedEntry;\n    \n    private TransitionPathResult(final PathEntry failedEntryValue, final Collection<Enum<?>> reasonValues)\n    {\n        this.reasons = reasonValues;\n        this.failedEntry = failedEntryValue;\n    }\n    \n    /**\n     * @return the failure reasons\n     */\n    public Collection<Enum<?>> getFailureReasons()\n    {\n        return Collections.unmodifiableCollection(this.reasons);\n    }\n    \n    /**\n     * @return the failed path entry\n     */\n    public PathEntry getFailedEntry()\n    {\n        return this.failedEntry;\n    }\n    \n    /**\n     * @return true if the transition was successful\n     */\n    public boolean isSuccess()\n    {\n        return this.reasons.isEmpty();\n    }\n    \n    /**\n     * @return true if the transition failed\n     */\n    public boolean isFail()\n    {\n        return !isSuccess();\n    }\n    \n    /**\n     * factory method for success results\n     * @return a new success result\n     */\n    static TransitionPathResult success()\n    {\n        final Collection<Enum<?>> r = Collections.emptyList();\n        return new TransitionPathResult(null, r);\n    }\n\n    /**\n     * factory method for failure results\n     * @return a new failure result\n     */\n    static TransitionPathResult fail(final PathEntry failedEntryValue, final Collection<Enum<?>> reasonValues)\n    {\n        return new TransitionPathResult(failedEntryValue, reasonValues);\n    }\n\n    /**\n     * factory method for failure results\n     * @return a new failure result\n     */\n    static TransitionPathResult fail(final Enum<?> ... reasonValues)\n    {\n        final Collection<Enum<?>> r = new ArrayList<Enum<?>>();\n        if (reasonValues == null || reasonValues.length == 0)\n        {\n            r.add(TransitionGuard.Reasons.NO_REASON_GIVEN);\n        }\n        else\n        {\n            r.addAll(Arrays.asList(reasonValues));\n        }\n        return new TransitionPathResult(null, r);\n    }\n    \n    /** \n     * @return the string representation\n     */\n    @Override\n    public String toString()\n    {\n        if(isSuccess())\n        {\n            return ""SUCCESS"";\n        }\n        return String.format(""FAIL: entry=%s reasons=%s"", this.failedEntry, this.reasons);\n    }\n}\n')",[260162]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\binterface (\\w+).*', 'package aaron.test;\n\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\n\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Set;\nimport java.util.HashSet;\n\n/**\n * A TransitionPath represents a chain of transitions from one state to another\n */\nenum PathFilters\n{\n    ; // uninstantiable\n\n    /**\n     * @return a TransitionPath filter which returns \'true\' when a path contains a transition\n     * with the given name\n     */\n    public static final Predicate<TransitionPath> byName(final String name)\n    {\n        return new Predicate<TransitionPath>() {\n            public boolean apply(final TransitionPath path) {\n                return path.containsTransition(name);\n            }\n        };\n    }\n\n    /**\n     * @return a TransitionPath filter which returns \'true\' when a path contains a transition with one of the given names\n     */\n     @SuppressWarnings(""unchecked"")\n    public static final Predicate<TransitionPath> byNames(final String ... names)\n    {\n        final Set<String> uniqueNames = new HashSet<String>(Arrays.asList(names));\n        final Collection<Predicate<TransitionPath>> filters = new ArrayList<Predicate<TransitionPath>>(uniqueNames.size());\n        for (final String name : uniqueNames)\n        {\n            if (name != null)\n            {\n                filters.add(byName(name));\n            }\n        }\n        Predicate<TransitionPath>[] filtersArray = new Predicate[filters.size()];\n        filtersArray = filters.toArray(filtersArray);\n        return Predicates.or(filtersArray);\n    }\n}\n')",[258860]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsStartState\n */\npublic class ClaimsStartStateTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the \'ClaimsStartState\' state\n     */\n    @Test\n    public void test_executeToClaimsStartState()\n    {\n        Assert.assertNotNull(moveToClaimsStartState());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for \'startState\' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.startState().getName();\n        Assert.assertEquals(fsm.startState(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the startState state\n     */\n    final ClaimsStartState moveToClaimsStartState()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsStartState startState = fsm.startState();\n\n        // call the method under test\n        fsm.executeToState(startState);\n\n        Assert.assertSame(startState, fsm.getCurrentState());\n        Assert.assertEquals(startState.getName(), fsm.getCurrentStateName());\n        \n        return startState;\n    }\n\n    \n    @Test\n    public void test_getPathBetweenClaimsStartStateAndClaimsNotReceived()\n    {\n\n        final ClaimsStartState startState = moveToClaimsStartState();\n        final ClaimsStateMachine fsm = startState.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'startState\'"", startState, fsm.getCurrentState());\n\n        final TransitionPaths paths = startState.getPaths(fsm.notReceived());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        startState.registerInitListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'startState\'"", startState, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.notReceived(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'init\' transition \n     */\n    @Test\n    public void test_init()\n    {\n        final ClaimsStartState startState = moveToClaimsStartState();\n        final ClaimsStateMachine fsm = startState.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        startState.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        startState.init();\n\n        //\n        // assert the current state is now ClaimsNotReceived\n        //\n        Assert.assertEquals(fsm.notReceived(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.notReceived().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsInit.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsInit.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(startState.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsStartState\' can be moved into the ClaimsNotReceived state\n     */\n    @Test\n    public void test_moveToClaimsNotReceived()\n    {\n        final ClaimsStartState startState = moveToClaimsStartState();\n        final ClaimsStateMachine fsm = startState.getStateMachine();\n        startState.getPaths(fsm.notReceived());\n        \n    }\n}\n')",[275030]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsReceivedByMonitoringOfficerAndClaimsReceivedByDeliveryTeam(aaron.test.test.ClaimsReceivedByMonitoringOfficerTest)')","[10632, 13980, 25101, 29923, 37161, 52465, 56245, 68950, 79335, 93705, 97269, 109182, 119962, 136200, 140196, 153693, 165905, 183544, 187864, 202549, 215489, 234062, 238598, 296791, 298585]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport com.google.common.base.Predicate;\n\n/**\n * A PredicateToggle provides a means for toggling a {@link Predicate}\n */\npublic final class PredicateToggle\n{\n    private final AtomicBoolean     enabled;\n    private final Predicate<Object> predicate;\n\n    private PredicateToggle(final boolean firstValue)\n    {\n        this.enabled = new AtomicBoolean(firstValue);\n        this.predicate = new Predicate<Object>() {\n            @Override\n            public boolean apply(final Object value)\n            {\n                return isEnabled();\n            }\n\n            @Override\n            public String toString()\n            {\n                return String.format(""Toggle %b"", Boolean.valueOf(isEnabled()));\n            }\n        };\n    }\n\n    /**\n     * @return a new enabled toggle\n     */\n    public static PredicateToggle on()\n    {\n        return new PredicateToggle(true);\n    }\n\n    /**\n     * @return a new disabled toggle\n     */\n    public static PredicateToggle off()\n    {\n        return new PredicateToggle(false);\n    }\n\n    /**\n     * enable the toggle\n     * \n     * @return true if this method call changed the toggle value\n     */\n    public boolean enable()\n    {\n        return this.enabled.compareAndSet(false, true);\n    }\n\n    /**\n     * disable the toggle\n     * \n     * @return true if this method call changed the toggle value\n     */\n    public boolean disable()\n    {\n        return this.enabled.compareAndSet(true, false);\n    }\n\n    /**\n     * switch the toggle value - going from off to on or from on to off.\n     */\n    public void toggle()\n    {\n        this.enabled.set(!isEnabled());\n    }\n\n    /**\n     * @return true if the toggle is currently enabled\n     */\n    public boolean isEnabled()\n    {\n        return this.enabled.get();\n    }\n\n    /**\n     * @return a transition filter representing the current state of the toggle\n     */\n    @SuppressWarnings(""unchecked"")\n    public <T> Predicate<T> predicate()\n    {\n        return (Predicate<T>) this.predicate;\n    }\n}\n')",[280499]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsInit extends AbstractTransition<ClaimsStartState, ClaimsNotReceived>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""init"";\n\n    TransitionClaimsInit(final ClaimsStartState from, final ClaimsNotReceived to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[268256]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsReceivedByDeliveryTeamAndClaimsReceivedByMonitoringOfficer(aaron.test.test.ClaimsReceivedByDeliveryTeamTest)')","[15375, 15406, 15437, 17979, 18010, 18041, 26949, 26973, 26997, 39745, 39775, 39805, 57820, 57855, 57890, 60760, 60795, 60830, 71106, 71134, 71162, 81745, 81773, 81801, 98754, 98787, 98820, 101526, 101559, 101592, 111184, 111210, 111236, 122720, 122752, 122784, 141861, 141898, 141935, 144969, 145006, 145043, 156003, 156033, 156063, 168924, 168959, 168994, 189664, 189704, 189744, 193024, 193064, 193104, 205090, 205123, 205156, 218682, 218719, 218756, 240488, 240530, 240572, 244016, 244058, 244100, 303251, 303291, 303331, 304567, 304609, 304651]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsNotReceived\n */\npublic class ClaimsNotReceivedTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the \'ClaimsNotReceived\' state\n     */\n    @Test\n    public void test_executeToClaimsNotReceived()\n    {\n        Assert.assertNotNull(moveToClaimsNotReceived());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for \'notReceived\' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.notReceived().getName();\n        Assert.assertEquals(fsm.notReceived(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the notReceived state\n     */\n    final ClaimsNotReceived moveToClaimsNotReceived()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsNotReceived notReceived = fsm.notReceived();\n\n        // call the method under test\n        fsm.executeToState(notReceived);\n\n        Assert.assertSame(notReceived, fsm.getCurrentState());\n        Assert.assertEquals(notReceived.getName(), fsm.getCurrentStateName());\n        \n        return notReceived;\n    }\n\n    \n    @Test\n    public void test_getPathBetweenClaimsNotReceivedAndClaimsReceivedByMonitoringOfficer()\n    {\n\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'notReceived\'"", notReceived, fsm.getCurrentState());\n\n        final TransitionPaths paths = notReceived.getPaths(fsm.receivedByMonitoringOfficer());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        notReceived.registerSubmitToMonitoringOfficerListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'notReceived\'"", notReceived, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.receivedByMonitoringOfficer(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'submitToMonitoringOfficer\' transition \n     */\n    @Test\n    public void test_submitToMonitoringOfficer()\n    {\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        notReceived.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        notReceived.submitToMonitoringOfficer();\n\n        //\n        // assert the current state is now ClaimsReceivedByMonitoringOfficer\n        //\n        Assert.assertEquals(fsm.receivedByMonitoringOfficer(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.receivedByMonitoringOfficer().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsSubmitToMonitoringOfficer.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsSubmitToMonitoringOfficer.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(notReceived.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsNotReceived\' can be moved into the ClaimsReceivedByMonitoringOfficer state\n     */\n    @Test\n    public void test_moveToClaimsReceivedByMonitoringOfficer()\n    {\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n        notReceived.getPaths(fsm.receivedByMonitoringOfficer());\n        \n    }\n    \n    @Test\n    public void test_getPathBetweenClaimsNotReceivedAndClaimsReceivedByDeliveryTeam()\n    {\n\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'notReceived\'"", notReceived, fsm.getCurrentState());\n\n        final TransitionPaths paths = notReceived.getPaths(fsm.receivedByDeliveryTeam());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        notReceived.registerSubmitToDeliveryTeamListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'notReceived\'"", notReceived, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.receivedByDeliveryTeam(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'submitToDeliveryTeam\' transition \n     */\n    @Test\n    public void test_submitToDeliveryTeam()\n    {\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        notReceived.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        notReceived.submitToDeliveryTeam();\n\n        //\n        // assert the current state is now ClaimsReceivedByDeliveryTeam\n        //\n        Assert.assertEquals(fsm.receivedByDeliveryTeam(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.receivedByDeliveryTeam().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsSubmitToDeliveryTeam.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsSubmitToDeliveryTeam.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(notReceived.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsNotReceived\' can be moved into the ClaimsReceivedByDeliveryTeam state\n     */\n    @Test\n    public void test_moveToClaimsReceivedByDeliveryTeam()\n    {\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n        notReceived.getPaths(fsm.receivedByDeliveryTeam());\n        \n    }\n    \n    @Test\n    public void test_getPathBetweenClaimsNotReceivedAndClaimsReceivedByHeadOfDelivery()\n    {\n\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'notReceived\'"", notReceived, fsm.getCurrentState());\n\n        final TransitionPaths paths = notReceived.getPaths(fsm.receivedByHeadOfDelivery());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        notReceived.registerSubmitToHeadOfDeliveryListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'notReceived\'"", notReceived, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'submitToHeadOfDelivery\' transition \n     */\n    @Test\n    public void test_submitToHeadOfDelivery()\n    {\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        notReceived.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        notReceived.submitToHeadOfDelivery();\n\n        //\n        // assert the current state is now ClaimsReceivedByHeadOfDelivery\n        //\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsSubmitToHeadOfDelivery.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsSubmitToHeadOfDelivery.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(notReceived.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsNotReceived\' can be moved into the ClaimsReceivedByHeadOfDelivery state\n     */\n    @Test\n    public void test_moveToClaimsReceivedByHeadOfDelivery()\n    {\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n        notReceived.getPaths(fsm.receivedByHeadOfDelivery());\n        \n    }\n}\n')",[272507]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsReceivedByMonitoringOfficer extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""Received By Monitoring Officer"";\n\n    private TransitionClaimsApproveForDeliveryTeam approveForDeliveryTeam; \n    private TransitionClaimsApproveForHeadOfDelivery approveForHeadOfDelivery; \n    private TransitionClaimsRejectToParticipant rejectToParticipant; \n    \n    /**\n     * @param fsm\n     */\n    ClaimsReceivedByMonitoringOfficer(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        // Transition approve for delivery team\n        this.approveForDeliveryTeam = new TransitionClaimsApproveForDeliveryTeam(this, getStateMachine().receivedByDeliveryTeam());\n        allTransitions.add(this.approveForDeliveryTeam); \n\n        // Transition approve for head of delivery\n        this.approveForHeadOfDelivery = new TransitionClaimsApproveForHeadOfDelivery(this, getStateMachine().receivedByHeadOfDelivery());\n        allTransitions.add(this.approveForHeadOfDelivery); \n\n        // Transition reject to participant\n        this.rejectToParticipant = new TransitionClaimsRejectToParticipant(this, getStateMachine().notReceived());\n        allTransitions.add(this.rejectToParticipant); \n\n        return allTransitions;    \n    }\n    \n    /**\n     * execute the approve for delivery team transition\n     * @return true if the transition was successful\n     */\n    public boolean approveForDeliveryTeam() {\n        this.approveForDeliveryTeam.execute();\n        return this.approveForDeliveryTeam.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerApproveForDeliveryTeamListener(final T listener)\n    {\n        return this.approveForDeliveryTeam.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterApproveForDeliveryTeamListener(final TransitionListener listener)\n    {\n        return this.approveForDeliveryTeam.unregisterListener(listener);\n    }\n    \n    /**\n     * execute the approve for head of delivery transition\n     * @return true if the transition was successful\n     */\n    public boolean approveForHeadOfDelivery() {\n        this.approveForHeadOfDelivery.execute();\n        return this.approveForHeadOfDelivery.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerApproveForHeadOfDeliveryListener(final T listener)\n    {\n        return this.approveForHeadOfDelivery.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterApproveForHeadOfDeliveryListener(final TransitionListener listener)\n    {\n        return this.approveForHeadOfDelivery.unregisterListener(listener);\n    }\n    \n    /**\n     * execute the reject to participant transition\n     * @return true if the transition was successful\n     */\n    public boolean rejectToParticipant() {\n        this.rejectToParticipant.execute();\n        return this.rejectToParticipant.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerRejectToParticipantListener(final T listener)\n    {\n        return this.rejectToParticipant.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterRejectToParticipantListener(final TransitionListener listener)\n    {\n        return this.rejectToParticipant.unregisterListener(listener);\n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[268799]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_submitToMonitoringOfficer(aaron.test.test.ClaimsNotReceivedTest)')","[6540, 9144, 23181, 29463, 34487, 47845, 50785, 66710, 76841, 89349, 92121, 107102, 117108, 131316, 134424, 151293, 162781, 178264, 181624, 199909, 212185, 228518, 232046, 290211, 291997]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getStateForName(aaron.test.test.ClaimsPaymentReceivedTest)')","[1880, 1904, 1928, 19219, 19250, 19281, 20583, 20614, 20645, 27909, 27933, 27957, 30632, 41356, 41386, 41416, 41977, 42005, 42033, 62160, 62195, 62230, 63700, 63735, 63770, 72226, 72254, 72282, 83246, 83274, 83302, 83825, 83851, 83877, 102846, 102879, 102912, 104298, 104331, 104364, 112224, 112250, 112276, 124441, 124473, 124505, 125104, 125134, 125164, 146449, 146486, 146523, 148077, 148114, 148151, 157203, 157233, 157263, 170810, 170845, 170880, 171536, 171569, 171602, 194624, 194664, 194704, 196384, 196424, 196464, 206410, 206443, 206476, 220678, 220715, 220752, 221446, 221481, 221516, 245696, 245738, 245780, 247544, 247586, 247628, 307485, 307525, 307565, 308289, 308331, 308373]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_executeToClaimsReadyForPayment(aaron.test.test.ClaimsReadyForPaymentTest)')","[8648, 12368, 24621, 29798, 36424, 50225, 54425, 68390, 78648, 91593, 95553, 108662, 119175, 133832, 138272, 153093, 165043, 180984, 185784, 201889, 214577, 231374, 236414, 294553, 295891]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\n/**\n * if you use google collections, refactor to use that instead \n */\npublic enum StateLog\n{\n    ;// uninstantiable\n\n    public static String error(final String format, final Object... args)\n    {\n        final String log = ""_error:"" + String.format(format, args);\n        System.out.println(log);\n        return log;\n    }\n\n    public static String info(final String format, final Object... args)\n    {\n        final String log = ""_info:"" + String.format(format, args);\n        System.out.println(log);\n        return log;\n    }\n\n    public static String debug(final String format, final Object... args)\n    {\n        final String log = ""_debug:"" + String.format(format, args);\n        System.out.println(log);\n        return log;\n    }\n    \n    public static String trace(final String format, final Object... args)\n    {\n        return ""_trace:"" + String.format(format, args);\n    }\n}\n')",[278224]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsApproveForHeadOfDelivery extends AbstractTransition<ClaimsReceivedByMonitoringOfficer, ClaimsReceivedByHeadOfDelivery>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""approve for head of delivery"";\n\n    TransitionClaimsApproveForHeadOfDelivery(final ClaimsReceivedByMonitoringOfficer from, final ClaimsReceivedByHeadOfDelivery to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[269011]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsPaymentComplete extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""Payment Complete"";\n\n    \n    /**\n     * @param fsm\n     */\n    ClaimsPaymentComplete(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        return allTransitions;    \n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[267706]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_removeTransition(com.porpoise.fsm.model.StateTest)')","[3068, 4184, 21933, 29070, 32105, 43925, 45185, 65254, 74623, 85653, 86841, 105750, 114562, 127172, 128504, 149733, 159989, 173784, 175224, 198193, 209229, 223814, 225326, 250890, 251220]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\n\n\n/**\n * Representation of the state machine. Through a ClaimsStateMachine instance you can:\n * <ul>\n * <li>Create a new instance (see @{link createAndStart()} and @{link create()})</li>\n * <li>Access all states by their names</li>\n * <li>register and unregister listeners which will be notified of every state transition</li>\n * <li>navigate to (execute) states via transitions</li>\n * <li>retrieve state instances by their names</li>\n * </ul>\n *\n * States returned via this state machine may *only* be used in this state machine.\n * For example, this is not valid:\n * <pre>\n * ClaimsStateMachine fsmOne = ClaimsStateMachine.createAndStart();\n * ClaimsStateMachine fsmTwo = ClaimsStateMachine.createAndStart();\n * Object stateA = fsmOne.<some state>();\n * fsmTwo.executeToState(stateA); // invalid  -- cannot share state instances between state machines\n * </pre>\n */\npublic class ClaimsStateMachine\n{\n    private StateNotifier notifier;\n    private State                     currentState;\n    private final Map<String, AbstractClaimsState>  stateByName;\n\n    private ClaimsPaymentRejected claimspaymentrejected;\n    private ClaimsReadyForPayment claimsreadyforpayment;\n    private ClaimsReceivedByHeadOfDelivery claimsreceivedbyheadofdelivery;\n    private ClaimsNotReceived claimsnotreceived;\n    private ClaimsPaymentReceived claimspaymentreceived;\n    private ClaimsReceivedByDeliveryTeam claimsreceivedbydeliveryteam;\n    private ClaimsPaymentComplete claimspaymentcomplete;\n    private ClaimsStartState claimsstartstate;\n    private ClaimsReceivedByMonitoringOfficer claimsreceivedbymonitoringofficer;\n\n    /**\n     *\n     */\n    private ClaimsStateMachine()\n    {\n        super();\n        this.stateByName = new HashMap<String, AbstractClaimsState>();\n    }\n\n    /**\n     * @return a new notifier\n     */\n    final StateNotifier newNotifier()\n    {\n        return new StateNotifier();\n    }\n\n    /**\n     * state machines need to be explicitly started.\n     * This is a convenience method for returning a new state machine which is \n     * already in the start state\n     *\n     * @return the new state machine\n     */\n    public static ClaimsStateMachine createAndStart()\n    {\n        ClaimsStateMachine instance = create();\n        instance.start();\n        return instance;\n    }\n\n    /**\n     * factory method used to create state machines\n     *\n     * @return a new state machine instance\n     */\n    public static ClaimsStateMachine create()\n    {\n        final ClaimsStateMachine fsm = new ClaimsStateMachine();\n\n        fsm.notifier = fsm.newNotifier();\n        \n        //\n        // Create states\n        //\n        fsm.claimspaymentrejected = new ClaimsPaymentRejected(fsm);\n        final State oldClaimsPaymentRejectedEntry = fsm.stateByName.put(fsm.claimspaymentrejected.getName(), fsm.claimspaymentrejected);\n        assert oldClaimsPaymentRejectedEntry == null : ""duplicate state names: "" + fsm.claimspaymentrejected.getName();\n\n        fsm.claimsreadyforpayment = new ClaimsReadyForPayment(fsm);\n        final State oldClaimsReadyForPaymentEntry = fsm.stateByName.put(fsm.claimsreadyforpayment.getName(), fsm.claimsreadyforpayment);\n        assert oldClaimsReadyForPaymentEntry == null : ""duplicate state names: "" + fsm.claimsreadyforpayment.getName();\n\n        fsm.claimsreceivedbyheadofdelivery = new ClaimsReceivedByHeadOfDelivery(fsm);\n        final State oldClaimsReceivedByHeadOfDeliveryEntry = fsm.stateByName.put(fsm.claimsreceivedbyheadofdelivery.getName(), fsm.claimsreceivedbyheadofdelivery);\n        assert oldClaimsReceivedByHeadOfDeliveryEntry == null : ""duplicate state names: "" + fsm.claimsreceivedbyheadofdelivery.getName();\n\n        fsm.claimsnotreceived = new ClaimsNotReceived(fsm);\n        final State oldClaimsNotReceivedEntry = fsm.stateByName.put(fsm.claimsnotreceived.getName(), fsm.claimsnotreceived);\n        assert oldClaimsNotReceivedEntry == null : ""duplicate state names: "" + fsm.claimsnotreceived.getName();\n\n        fsm.claimspaymentreceived = new ClaimsPaymentReceived(fsm);\n        final State oldClaimsPaymentReceivedEntry = fsm.stateByName.put(fsm.claimspaymentreceived.getName(), fsm.claimspaymentreceived);\n        assert oldClaimsPaymentReceivedEntry == null : ""duplicate state names: "" + fsm.claimspaymentreceived.getName();\n\n        fsm.claimsreceivedbydeliveryteam = new ClaimsReceivedByDeliveryTeam(fsm);\n        final State oldClaimsReceivedByDeliveryTeamEntry = fsm.stateByName.put(fsm.claimsreceivedbydeliveryteam.getName(), fsm.claimsreceivedbydeliveryteam);\n        assert oldClaimsReceivedByDeliveryTeamEntry == null : ""duplicate state names: "" + fsm.claimsreceivedbydeliveryteam.getName();\n\n        fsm.claimspaymentcomplete = new ClaimsPaymentComplete(fsm);\n        final State oldClaimsPaymentCompleteEntry = fsm.stateByName.put(fsm.claimspaymentcomplete.getName(), fsm.claimspaymentcomplete);\n        assert oldClaimsPaymentCompleteEntry == null : ""duplicate state names: "" + fsm.claimspaymentcomplete.getName();\n\n        fsm.claimsstartstate = new ClaimsStartState(fsm);\n        final State oldClaimsStartStateEntry = fsm.stateByName.put(fsm.claimsstartstate.getName(), fsm.claimsstartstate);\n        assert oldClaimsStartStateEntry == null : ""duplicate state names: "" + fsm.claimsstartstate.getName();\n\n        fsm.claimsreceivedbymonitoringofficer = new ClaimsReceivedByMonitoringOfficer(fsm);\n        final State oldClaimsReceivedByMonitoringOfficerEntry = fsm.stateByName.put(fsm.claimsreceivedbymonitoringofficer.getName(), fsm.claimsreceivedbymonitoringofficer);\n        assert oldClaimsReceivedByMonitoringOfficerEntry == null : ""duplicate state names: "" + fsm.claimsreceivedbymonitoringofficer.getName();\n\n\n        //\n        // Initialise transitions\n        //\n        fsm.claimspaymentrejected.initialise();\n        fsm.claimsreadyforpayment.initialise();\n        fsm.claimsreceivedbyheadofdelivery.initialise();\n        fsm.claimsnotreceived.initialise();\n        fsm.claimspaymentreceived.initialise();\n        fsm.claimsreceivedbydeliveryteam.initialise();\n        fsm.claimspaymentcomplete.initialise();\n        fsm.claimsstartstate.initialise();\n        fsm.claimsreceivedbymonitoringofficer.initialise();\n        return fsm;\n    }\n\n    /**\n     * @return the current state\n     */\n    public State getCurrentState()\n    {\n        return this.currentState;\n    }\n    \n    /**\n     * @param goal the target state\n     * @return a TransitionPaths object from the current state to the given goal state\n     */\n    public TransitionPaths getPaths(final State goal)\n    {\n        return getCurrentState().getPaths(goal);\n    }\n\n    /**\n     * @param goal\n     *            the target state\n     * @return a TransitionPaths object from the current state to the given goal state\n     */\n    public TransitionPaths getSuccessfulPaths(final State goal)\n    {\n        final TransitionPaths allPaths = getCurrentState().getPaths(goal);\n        final TransitionPaths successfulPaths = new TransitionPaths();\n        if (allPaths != null)\n        {\n            for (final TransitionPath path : allPaths)\n            {\n                final TransitionPathResult result = executePathDryRun(path);\n                if (result != null && result.isSuccess())\n                {\n                    successfulPaths.add(path);\n                }\n            }\n        }\n        return successfulPaths;\n    }\n\n    /**\n     * @param path\n     *            the path to execute w/o affecting the current state. All registered listeners however will be notified.\n     * @return the result\n     */\n    public final TransitionPathResult executePathDryRun(final TransitionPath path)\n    {\n        final State beforeState = getCurrentState();\n        TransitionPathResult result;\n        try\n        {\n            result = path.execute();\n        }\n        finally\n        {\n            setCurrentState(beforeState);\n        }\n        return result;\n    }\n\n    /**\n     * @param path\n     *            the path to execute\n     * @return the result\n     */\n    public final TransitionPathResult executePath(final TransitionPath path)\n    {\n        return path.execute();\n    }\n\n    /**\n     * @param the given state name\n     * @return the result\n     */\n    public TransitionPathResult executeToState(final String name)\n    {   \n        final State state = getStateForName(name);\n        if (state == null)\n        {\n            throw new IllegalArgumentException(String.format(""No state exists with the name \'%s\'"", name));\n        }\n        return executeToState(state);\n    }\n\n    /**\n     * @param the given state name\n     * @return the result\n     */\n    public TransitionPathResult executeToStateDryRun(final String name)\n    {   \n        final State state = getStateForName(name);\n        if (state == null)\n        {\n            throw new IllegalArgumentException(String.format(""No state exists with the name \'%s\'"", name));\n        }\n        return executeToStateDryRun(state);\n    }\n    \n    /**\n     * After calling, the state will be reset its current state see {@link #executeToState(State)}\n     * \n     * @param to\n     *            the goal state\n     * @return the result of executing to the given state via the shorted available path\n     */\n    public TransitionPathResult executeToStateDryRun(final State to)\n    {\n        final State beforeState = getCurrentState();\n        TransitionPathResult result;\n        try\n        {\n            result = executeToState(to);\n        }\n        finally\n        {\n            setCurrentState(beforeState);\n        }\n        return result;\n    }\n\n\n    /**\n     * jump to the given state via the shortest \'path\'.\n     * \n     * @param to\n     *            the goal state\n     * @return the result of trying to move to the given state via the shortest available path, or null if no path was found. If the state machine was already in the given state it returns false. If the state\n     *         machine has now moved into the given state it returns true.\n     */\n    public TransitionPathResult executeToState(final State to)\n    {\n        if (to == getCurrentState())\n        {\n            return TransitionPathResult.fail(TransitionGuard.Reasons.ALREADY_IN_TARGET_STATE);\n        }\n\n        final TransitionPath path = getShortestSuccessfulPath(to);\n        \n        if (path != null)\n        {\n            return path.execute();\n        }\n\n        return TransitionPathResult.fail(TransitionGuard.Reasons.TARGET_STATE_UNREACHABLE);\n    }\n\n    /**\n     * @param to\n     *            the target (goal) state\n     * @return the first path available which can transition to the given state\n     */\n    public TransitionPath getShortestSuccessfulPath(final State to)\n    {\n        final State beforeState = getCurrentState();\n        TransitionPath path;\n        try\n        {\n            path = getShortestSuccessfulPathInternal(to);\n        }\n        finally\n        {\n            setCurrentState(beforeState);\n        }\n\n        return path;\n    }\n\n    private TransitionPath getShortestSuccessfulPathInternal(final State to)\n    {\n        final TransitionPaths paths = getPaths(to);\n        boolean success = false;\n        final State beforeState = getCurrentState();\n        for (final TransitionPath path : paths)\n        {\n            StateLog.debug(""trying "" + path);\n            success = executeToStateInternal(path, to);\n            if (success)\n            {\n                return path;\n            }\n            setCurrentState(beforeState);\n        }\n        return null;\n    }\n\n    /**\n     * jump to the given state via the path of transitions\n     * \n     * @return true if this call had any effect\n     */\n    private boolean executeToStateInternal(final TransitionPath path, final State to)\n    {\n        if (to == getCurrentState())\n        {\n            return false;\n        }\n        if (path == null)\n        {\n            throw new IllegalStateException(String.format(""can\'t get to \'%s\' from \'%s\'"", getCurrentStateName(), to.getName()));\n        }\n        path.execute();\n        return to == getCurrentState();\n    }\n\n    /**\n     * @return the name of the current state\n     */\n    public String getCurrentStateName()\n    {\n        return getCurrentState() == null ? null : getCurrentState().getName();\n    }\n\n    /**\n     * @return the start state\n     * @throws IllegalStateException\n     *             if the state machine was already started\n     */\n    public ClaimsStartState start()\n    {\n        if (getCurrentState() != null && getCurrentState().equals(this.claimsstartstate))\n        {\n            throw new IllegalStateException(""already started"");\n        }\n        setCurrentState(this.claimsstartstate);\n        return this.claimsstartstate;\n    }\n\n    /**\n     * @return the ClaimsPaymentRejected state\n     */\n    public ClaimsPaymentRejected paymentRejected()\n    {\n        return this.claimspaymentrejected;\n    }    \n    /**\n     * @return the ClaimsReadyForPayment state\n     */\n    public ClaimsReadyForPayment readyForPayment()\n    {\n        return this.claimsreadyforpayment;\n    }    \n    /**\n     * @return the ClaimsReceivedByHeadOfDelivery state\n     */\n    public ClaimsReceivedByHeadOfDelivery receivedByHeadOfDelivery()\n    {\n        return this.claimsreceivedbyheadofdelivery;\n    }    \n    /**\n     * @return the ClaimsNotReceived state\n     */\n    public ClaimsNotReceived notReceived()\n    {\n        return this.claimsnotreceived;\n    }    \n    /**\n     * @return the ClaimsPaymentReceived state\n     */\n    public ClaimsPaymentReceived paymentReceived()\n    {\n        return this.claimspaymentreceived;\n    }    \n    /**\n     * @return the ClaimsReceivedByDeliveryTeam state\n     */\n    public ClaimsReceivedByDeliveryTeam receivedByDeliveryTeam()\n    {\n        return this.claimsreceivedbydeliveryteam;\n    }    \n    /**\n     * @return the ClaimsPaymentComplete state\n     */\n    public ClaimsPaymentComplete paymentComplete()\n    {\n        return this.claimspaymentcomplete;\n    }    \n    /**\n     * @return the ClaimsStartState state\n     */\n    public ClaimsStartState startState()\n    {\n        return this.claimsstartstate;\n    }    \n    /**\n     * @return the ClaimsReceivedByMonitoringOfficer state\n     */\n    public ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer()\n    {\n        return this.claimsreceivedbymonitoringofficer;\n    }    \n\n\n    /**\n     * @return a collection of all the transitions across all states\n     */\n    public Collection<Transition> getTransitions()\n    {\n        final Collection<Transition> states = new LinkedList<Transition>();\n        for (final AbstractClaimsState state : this.stateByName.values())\n        {\n            states.addAll(state.getTransitions());\n        }\n        return states;\n    }\n\n    /**\n     * @return a collection of all the names for all the transitions across all states\n     */\n    public Collection<String> getTransitionNames()\n    {\n        final Collection<String> names = new LinkedList<String>();\n        for (final AbstractClaimsState state : this.stateByName.values())\n        {\n            names.addAll(state.getTransitionNames());\n        }\n        return names;\n    }\n\n    /**\n     * @return a collection of all states for this state machine\n     */\n    public Collection<State> getStates()\n    {\n        final Collection<State> states = new LinkedList<State>();\n        for (final AbstractClaimsState state : this.stateByName.values())\n        {\n            states.add(state);\n        }\n        return states;\n    }\n\n\n    /**\n     * @return a collection of all the names of all the states for this state machine\n     */\n    public Collection<String> getStateNames()\n    {\n        return this.stateByName.keySet();\n    }\n    \n    /**\n     * @param name the name of the state\n     * @return the state for the given name\n     */\n    public State getStateForName(final String name)\n    {\n        if (name == null)\n        {\n            throw new NullPointerException(""Invalid argument: null state name"");\n        }\n        return this.stateByName.get(name);\n    }\n\n    /**\n     * @param name\n     *            the name of the transition\n     * @return the transition for the given name\n     */\n    public Transition getTransitionForName(final String name)\n    {\n        for (final AbstractClaimsState state : this.stateByName.values())\n        {\n            final Transition transition = state.getTransitionForName(name);\n            if (transition != null)\n            {\n                return transition;\n            }\n        }\n        return null;\n    }\n    \n    final void setCurrentState(State newState)\n    {\n        this.currentState = newState;\n    }\n\n\n    /**\n     * @param listeners\n     */\n    public void registerListeners(final StateListener... listeners)\n    {\n        for (final StateListener listener : listeners)\n        {\n            registerListener(listener);\n        }\n    }\n\n    /**\n     * register and return the given listener\n     * @param listener the registered listener\n     * @return the registered listener (for chaining)\n     */\n    public <T extends StateListener> T registerListener(final T listener)\n    {\n        final boolean added = this.notifier.registerListener(listener);\n        assert added;\n        return listener;\n    }\n\n    /**\n     * unregister a listener\n     * @return true if the listener was successfully unregistered\n     */\n    public boolean unregisterListener(final StateListener listener)\n    {\n        return this.notifier.unregisterListener(listener);\n    }\n\n    final TransitionGuard onBeforeTransition(final Transition transition)\n    {\n        return this.notifier.onBeforeTransition(transition);\n    }\n\n    final TransitionGuard onAfterTransition(final Transition transition)\n    {\n        return this.notifier.onAfterTransition(transition);\n    }\n\n    /**\n     * drops your entire database.\n     * Either that or just represents the state machine as a string. \n     * Take your chances.\n     */\n    @Override\n    public String toString()\n    {\n        final String newLine = String.format(""%n"");\n        final StringBuilder builder = new StringBuilder(""ClaimsStateMachine"").append(newLine);\n        builder.append(""\\t"").append(this.notifier).append(newLine);\n        builder.append(""Current State:"");\n        builder.append(this.currentState).append(newLine);\n        builder.append(this.claimspaymentrejected).append(newLine);\n        builder.append(this.claimsreadyforpayment).append(newLine);\n        builder.append(this.claimsreceivedbyheadofdelivery).append(newLine);\n        builder.append(this.claimsnotreceived).append(newLine);\n        builder.append(this.claimspaymentreceived).append(newLine);\n        builder.append(this.claimsreceivedbydeliveryteam).append(newLine);\n        builder.append(this.claimspaymentcomplete).append(newLine);\n        builder.append(this.claimsstartstate).append(newLine);\n        builder.append(this.claimsreceivedbymonitoringofficer).append(newLine);\n        return builder.toString();\n    }\n}\n')",[253128]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport com.google.common.base.Predicate;\n\n/**\n * A collection of useful implementations of StateListener\n */\npublic enum StateListeners \n{\n    ;//uninstantiable\n    \n    static class BlockEntryListener extends ListenerAdapter\n    {\n        private final Enum<?> reason;\n        public BlockEntryListener(final Enum<?> reason)\n        {\n            super(TransitionGuard.stopEventually(reason), TransitionGuard.ok());\n            this.reason = reason;\n        }\n        public BlockEntryListener()\n        {\n            this(null);\n        }\n\n        @Override\n        public String toString()\n        {\n            return String.format(""block entry (reason=%s)"", this.reason);\n        }\n    }\n\n    static class BlockExitListener extends ListenerAdapter\n    {\n        private final Enum<?> reason;\n        public BlockExitListener(final Enum<?> reason)\n        {\n            super(TransitionGuard.ok(), TransitionGuard.stopEventually(reason));\n            this.reason = reason;\n        }\n        public BlockExitListener()\n        {\n            this(null);\n        }\n\n        @Override\n        public String toString()\n        {\n            return String.format(""block exit (reason=%s)"", this.reason);\n        }\n    }\n\n    /**\n     */\n    public static RecordingListener recordingListener()\n    {\n        return new RecordingListener();\n    }\n\n    /**\n     * a listener which records the transitions\n     */\n    public static class RecordingListener extends ListenerAdapter\n    {\n        private final List<Transition> enterTransitions = new ArrayList<Transition>();\n        private final List<Transition> exitTransitions  = new ArrayList<Transition>();\n\n        @Override\n        public TransitionGuard onExit(final Transition transition)\n        {\n            this.exitTransitions.add(transition);\n            return TransitionGuard.ok();\n        }\n\n        @Override\n        public TransitionGuard onEnter(final Transition transition)\n        {\n            this.enterTransitions.add(transition);\n            return TransitionGuard.ok();\n        }\n\n        /**\n         * @return the exit transitions\n         */\n        public List<Transition> getExitTransitions()\n        {\n            return Collections.unmodifiableList(this.exitTransitions);\n        }\n\n        /**\n         * @return the enter transitions\n         */\n        public List<Transition> getEnterTransitions()\n        {\n            return Collections.unmodifiableList(this.enterTransitions);\n        }\n\n        @Override\n        public String toString()\n        {\n            return ""recording listener"";\n        }\n    }\n\n    /**\n     */\n    public static class EchoListener extends ListenerAdapter\n    {\n        private final PrintStream out;\n\n        public EchoListener(final PrintStream outStream)\n        {\n            if (outStream == null)\n            {\n                throw new NullPointerException();\n            }\n            this.out = outStream;\n        }\n\n        @Override\n        public TransitionGuard onEnter(final Transition transition)\n        {\n            this.out.println(String.format(""enter \'%s\' via \'%s\'"", transition.getTarget().getName(), transition.getName()));\n            return TransitionGuard.ok();\n        }\n\n        @Override\n        public TransitionGuard onExit(final Transition transition)\n        {\n            this.out.println(String.format(""exit \'%s\' via \'%s\'"", transition.getSource().getName(), transition.getName()));\n            return TransitionGuard.ok();\n        }\n        @Override\n        public String toString()\n        {\n            return ""echo listener"";\n        }\n    }\n\n    public static EchoListener echoListener(final PrintStream out)\n    {\n        return new EchoListener(out);\n    }\n\n    /**\n     * @return the registered listener\n     */\n    public static StateListener blockEntryListener()\n    {\n        return blockEntryListener(null);\n    }\n\n    /**\n     * @return the registered listener\n     */\n    public static StateListener blockEntryListener(final Enum<?> reason)\n    {\n        return new BlockEntryListener(reason);\n    }\n\n    /**\n     * @return the listener\n     */\n    public static StateListener blockExitListener()\n    {\n        return blockExitListener(null);\n    }\n\n    /**\n     * @return the listener\n     */\n    public static StateListener blockExitListener(final Enum<?> reason)\n    {\n        return new BlockExitListener(reason);\n    }\n\n    /**\n     * @param state\n     *            the state to match\n     * @return a predicate which will return true for transitions whos target state matches the given state\n     */\n    public static Predicate<Transition> targetStateEquals(final State state)\n    {\n        if (state == null)\n        {\n            throw new NullPointerException(""state cannot be null"");\n        }\n        return new Predicate<Transition>() {\n\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return value.getTarget().equals(state);\n            }\n        };\n    }\n\n    /**\n     * @param state\n     *            the state to match\n     * @return a predicate which will return true for transitions whos source state matches the given state\n     */\n    public static Predicate<Transition> sourceStateEquals(final State state)\n    {\n        if (state == null)\n        {\n            throw new NullPointerException(""state cannot be null"");\n        }\n        return new Predicate<Transition>() {\n\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return value.getSource().equals(state);\n            }\n        };\n    }\n\n    /**\n     * @param the reason\n     * @return the registered listener\n     */\n    public static StateListener blockEntry(final State state, final Enum<?> reason)\n    {\n        final StateListener listener = filter(targetStateEquals(state), blockEntryListener(reason));\n        return listener;\n    }\n\n    /**\n     * @param the reason\n     * @return the registered listener\n     */\n    public static StateListener blockExit(final State state, final Enum<?> reason)\n    {\n        final StateListener listener = filter(sourceStateEquals(state), blockExitListener(reason));\n        return listener;\n    }\n\n    /**\n     * @param filter\n     *            the filter to apply to the given listener\n     * @param listener\n     *            the listener to wrap\n     * @return the wrapped listener\n     */\n    public static ConditionalStateListener filter(final Predicate<Transition> filter, final StateListener listener)\n    {\n        return new ConditionalStateListener(filter, listener);\n    }\n\n    /**\n     * @param listeners\n     *            the listeners to treat as a single group\n     * @return the grouped listener\n     */\n    public static GroupStateListener group(final StateListener... listeners)\n    {\n        return new GroupStateListener(listeners);\n    }\n\n    /**\n     * @param listeners\n     *            the listeners to treat as a single group\n     * @return the group listener which you can turn on and off\n     */\n    public static ConditionalStateListener group(final Predicate<Transition> predicate, final StateListener... listeners)\n    {\n        return filter(predicate, group(listeners));\n    }\n }')",[284138]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'aaron.test.test.ClaimsStartStateTest')","[1598, 40927, 82847, 123982, 170306, 220144]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport com.google.common.base.Predicate;\n\n/** \n */\npublic final class ConditionalTransitionListener implements TransitionListener\n{\n    private final  TransitionGuard onFalseResult;\n    private final Predicate<Transition> filter;\n    private final TransitionListener delegate;    \n    /**\n     * @param predicate\n     */\n    public ConditionalTransitionListener(final Predicate<Transition> predicate, final TransitionListener wrappedListener)\n    {\n        this(predicate, wrappedListener, TransitionGuard.ok());\n    }\n    \n    /**\n     * @param predicate\n     */\n    public ConditionalTransitionListener(final Predicate<Transition> predicate, final TransitionListener wrappedListener, final TransitionGuard onFalseResultParam)\n    {\n        if (predicate == null)\n        {\n            throw new NullPointerException(""predicate cannot be null"");        \n        }\n        if (wrappedListener == null)\n        {\n            throw new NullPointerException(""wrappedListener cannot be null"");        \n        }\n        if (onFalseResultParam == null)\n        {\n            throw new NullPointerException(""onFalseResultParam cannot be null"");        \n        }\n        this.filter = predicate;\n        this.onFalseResult = onFalseResultParam;\n        this.delegate = wrappedListener; \n    }\n    \n    /**\n     * fired when a transition is executed\n     * \n     * @return the transition guard\n     */\n    @Override\n    public TransitionGuard onTransition(final Transition transition)\n    {\n        if (this.filter.apply(transition))\n        {\n            return this.delegate.onTransition(transition);\n        }\n        return this.onFalseResult;\n    }\n}\n')",[256142]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_executeToClaimsReceivedByDeliveryTeam(aaron.test.test.ClaimsReceivedByDeliveryTeamTest)')","[15220, 17824, 26829, 30341, 39595, 57645, 60585, 70966, 81605, 98589, 101361, 111054, 122560, 141676, 144784, 155853, 168749, 189464, 192824, 204925, 218497, 240278, 243806, 303051, 304357]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport com.google.common.base.Predicate;\n\n/**\n * A PredicateToggle provides a means for toggling a {@link Predicate}\n */\npublic final class PredicateToggle\n{\n    private final AtomicBoolean     enabled;\n    private final Predicate<Object> predicate;\n\n    private PredicateToggle(final boolean firstValue)\n    {\n        this.enabled = new AtomicBoolean(firstValue);\n        this.predicate = new Predicate<Object>() {\n            @Override\n            public boolean apply(final Object value)\n            {\n                return isEnabled();\n            }\n\n            @Override\n            public String toString()\n            {\n                return String.format(""Toggle %b"", Boolean.valueOf(isEnabled()));\n            }\n        };\n    }\n\n    /**\n     * @return a new enabled toggle\n     */\n    public static PredicateToggle on()\n    {\n        return new PredicateToggle(true);\n    }\n\n    /**\n     * @return a new disabled toggle\n     */\n    public static PredicateToggle off()\n    {\n        return new PredicateToggle(false);\n    }\n\n    /**\n     * enable the toggle\n     * \n     * @return true if this method call changed the toggle value\n     */\n    public boolean enable()\n    {\n        return this.enabled.compareAndSet(false, true);\n    }\n\n    /**\n     * disable the toggle\n     * \n     * @return true if this method call changed the toggle value\n     */\n    public boolean disable()\n    {\n        return this.enabled.compareAndSet(true, false);\n    }\n\n    /**\n     * switch the toggle value - going from off to on or from on to off.\n     */\n    public void toggle()\n    {\n        this.enabled.set(!isEnabled());\n    }\n\n    /**\n     * @return true if the toggle is currently enabled\n     */\n    public boolean isEnabled()\n    {\n        return this.enabled.get();\n    }\n\n    /**\n     * @return a transition filter representing the current state of the toggle\n     */\n    @SuppressWarnings(""unchecked"")\n    public <T> Predicate<T> predicate()\n    {\n        return (Predicate<T>) this.predicate;\n    }\n}\n')",[257079]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsReadyForPayment extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""Ready For Payment"";\n\n    private TransitionClaimsRejectPayment rejectPayment; \n    private TransitionClaimsMarkPaymentAsReceived markPaymentAsReceived; \n    \n    /**\n     * @param fsm\n     */\n    ClaimsReadyForPayment(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        // Transition reject payment\n        this.rejectPayment = new TransitionClaimsRejectPayment(this, getStateMachine().paymentRejected());\n        allTransitions.add(this.rejectPayment); \n\n        // Transition mark payment as received\n        this.markPaymentAsReceived = new TransitionClaimsMarkPaymentAsReceived(this, getStateMachine().paymentReceived());\n        allTransitions.add(this.markPaymentAsReceived); \n\n        return allTransitions;    \n    }\n    \n    /**\n     * execute the reject payment transition\n     * @return true if the transition was successful\n     */\n    public boolean rejectPayment() {\n        this.rejectPayment.execute();\n        return this.rejectPayment.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerRejectPaymentListener(final T listener)\n    {\n        return this.rejectPayment.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterRejectPaymentListener(final TransitionListener listener)\n    {\n        return this.rejectPayment.unregisterListener(listener);\n    }\n    \n    /**\n     * execute the mark payment as received transition\n     * @return true if the transition was successful\n     */\n    public boolean markPaymentAsReceived() {\n        this.markPaymentAsReceived.execute();\n        return this.markPaymentAsReceived.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerMarkPaymentAsReceivedListener(final T listener)\n    {\n        return this.markPaymentAsReceived.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterMarkPaymentAsReceivedListener(final TransitionListener listener)\n    {\n        return this.markPaymentAsReceived.unregisterListener(listener);\n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[264104]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p.test;\nimport p.*;\nimport org.junit.*;\n\n/**\n * tests for TestStateMachine\n */\n@Ignore(""base class"")\nabstract class AbstractTestTest \n{\n    /**\n     *\n     */\n    protected TestStateMachine newStateMachine()\n    {\n        final TestStateMachine fsm = TestStateMachine.createAndStart(); \n        Assert.assertNotNull(fsm);\n        return fsm;\n    }\n}\n')",[287129]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\n/**\n * a listener callback used to respond to state changes.\n */\npublic interface StateListener\n{\n    /**\n     *\n     */\n    TransitionGuard onExit(final Transition transition);\n    \n    /**\n     *\n     */\n    TransitionGuard onEnter(final Transition transition);\n}\n')",[256757]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p.test;\n\nimport p.*;\n\nimport org.junit.*;\n\n/**\n * tests for TestStateMachine\n */\npublic class TestStateMachineTest \n{\n    /**\n     *\n     */\n    @Test\n    public void test_generalListeners()\n    {\n        final TestStateMachine fsm = TestStateMachine.create(); \n        Assert.assertNotNull(fsm);\n    }\n\n}\n')",[286895]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_rejectToDeliveryTeam(aaron.test.test.ClaimsReceivedByHeadOfDeliveryTest)')","[12988, 16336, 26157, 30174, 38618, 55125, 58905, 70182, 80694, 96213, 99777, 110326, 121517, 139012, 143008, 155013, 167607, 186584, 190904, 204001, 217289, 237254, 241790, 300493, 301807]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'aaron.test.test.ClaimsStartStateTest')","[307335, 307358, 307382, 307405]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsReadyForPaymentAndClaimsPaymentRejected(aaron.test.test.ClaimsReadyForPaymentTest)')","[7935, 7966, 7997, 11655, 11686, 11717, 24069, 24093, 24117, 35734, 35764, 35794, 49420, 49455, 49490, 53620, 53655, 53690, 67746, 67774, 67802, 78004, 78032, 78060, 90834, 90867, 90900, 94794, 94827, 94860, 108064, 108090, 108116, 118439, 118471, 118503, 132981, 133018, 133055, 137421, 137458, 137495, 152403, 152433, 152463, 164238, 164273, 164308, 180064, 180104, 180144, 184864, 184904, 184944, 201130, 201163, 201196, 213726, 213763, 213800, 230408, 230450, 230492, 235448, 235490, 235532, 293633, 293673, 293713, 294925, 294967, 295009]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\n/**\n * a listener which groups other listeners\n */\npublic class GroupStateListener implements StateListener \n{\n    private final StateNotifier notifier;\n\n    /**\n     */\n    public GroupStateListener(final StateListener ... listeners)\n    {\n        this.notifier = new StateNotifier();\n        for (final StateListener listener : listeners)\n        {\n            this.notifier.registerListener(listener);\n        }\n    }\n   \n    @Override\n    public TransitionGuard onExit(final Transition transition)\n    {\n        return this.notifier.onBeforeTransition(transition);\n    }\n\n    @Override\n    public TransitionGuard onEnter(final Transition transition)\n    {\n        return this.notifier.onAfterTransition(transition);\n    }\n\n    /**\n     * @return the string representation of this listener\n     */\n    @Override\n    public String toString()\n    {\n        return String.format(""group listener {%s}"", this.notifier);\n    }\n}\n')",[256561]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * <p>\n * A TransitionPathResult represents the result of trying to execute a {@link TransitionPath}.\n * You can query the result, asking if it was successful or not. In the case where it was not\n * successful, you can retrieve a collection of \'reason\' enumerations, which indicate why the\n * path was not successful. The reasons given will be those from the exit/enter state guards or \n * transition guards. \n * </p>\n * See {@link TransitionPath#execute()}.\n */\npublic final class TransitionPathResult\n{\n    private Collection<Enum<?>> reasons;\n    private PathEntry failedEntry;\n    \n    private TransitionPathResult(final PathEntry failedEntryValue, final Collection<Enum<?>> reasonValues)\n    {\n        this.reasons = reasonValues;\n        this.failedEntry = failedEntryValue;\n    }\n    \n    /**\n     * @return the failure reasons\n     */\n    public Collection<Enum<?>> getFailureReasons()\n    {\n        return Collections.unmodifiableCollection(this.reasons);\n    }\n    \n    /**\n     * @return the failed path entry\n     */\n    public PathEntry getFailedEntry()\n    {\n        return this.failedEntry;\n    }\n    \n    /**\n     * @return true if the transition was successful\n     */\n    public boolean isSuccess()\n    {\n        return this.reasons.isEmpty();\n    }\n    \n    /**\n     * @return true if the transition failed\n     */\n    public boolean isFail()\n    {\n        return !isSuccess();\n    }\n    \n    /**\n     * factory method for success results\n     * @return a new success result\n     */\n    static TransitionPathResult success()\n    {\n        final Collection<Enum<?>> r = Collections.emptyList();\n        return new TransitionPathResult(null, r);\n    }\n\n    /**\n     * factory method for failure results\n     * @return a new failure result\n     */\n    static TransitionPathResult fail(final PathEntry failedEntryValue, final Collection<Enum<?>> reasonValues)\n    {\n        return new TransitionPathResult(failedEntryValue, reasonValues);\n    }\n\n    /**\n     * factory method for failure results\n     * @return a new failure result\n     */\n    static TransitionPathResult fail(final Enum<?> ... reasonValues)\n    {\n        final Collection<Enum<?>> r = new ArrayList<Enum<?>>();\n        if (reasonValues == null || reasonValues.length == 0)\n        {\n            r.add(TransitionGuard.Reasons.NO_REASON_GIVEN);\n        }\n        else\n        {\n            r.addAll(Arrays.asList(reasonValues));\n        }\n        return new TransitionPathResult(null, r);\n    }\n    \n    /** \n     * @return the string representation\n     */\n    @Override\n    public String toString()\n    {\n        if(isSuccess())\n        {\n            return ""SUCCESS"";\n        }\n        return String.format(""FAIL: entry=%s reasons=%s"", this.failedEntry, this.reasons);\n    }\n}\n')",[283599]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.HashSet;\n\n/**\n * A TransitionPath represents a chain of transitions from one state to another\n */\npublic final class TransitionPath implements Comparable<TransitionPath>\n{\n    private final List<PathEntry> path;\n    private final Set<String>     uniqueTransitionNames;\n\n    TransitionPath(final State startState)\n    {\n        this(Arrays.asList(new PathEntry[] { new PathEntry(startState) }));\n    }\n\n    private TransitionPath(final List<PathEntry> states)\n    {\n        this.path = new ArrayList<PathEntry>(states);\n        this.uniqueTransitionNames = new HashSet<String>();\n        for (final PathEntry pe : states)\n        {\n            if (pe.getTransition() != null)\n            {\n                this.uniqueTransitionNames.add(pe.getTransition().getName());\n            }\n        }\n    }\n\n    /**\n     * add a unique transition to the given target\n     * @param target\n     * @param trans\n     * @return true if this method invocation has altered the TransitionPath, false otherwise\n     */\n    boolean add(final State target, final Transition trans)\n    {\n        final PathEntry entry = new PathEntry(target, trans);\n        if (this.path.contains(entry))\n        {\n            return false;\n        }\n        this.uniqueTransitionNames.add(trans.getName());\n        return this.path.add(entry);\n    }\n\n    public TransitionPath clonePath()\n    {\n        return new TransitionPath(this.path);\n    }\n\n    @Override\n    public String toString()\n    {\n        final StringBuilder b = new StringBuilder(""path: "");\n        for (final PathEntry s : this.path)\n        {\n            b.append(s);\n        }\n        return b.toString();\n    }\n\n    @Override\n    public int hashCode()\n    {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((this.path == null) ? 0 : this.path.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(final Object obj)\n    {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        final TransitionPath other = (TransitionPath) obj;\n        if (this.path == null)\n        {\n            if (other.path != null)\n                return false;\n        }\n        else if (!this.path.equals(other.path))\n            return false;\n        return true;\n    }\n\n    /**\n     * execute this path on\'t state machine\n     * \n     * @return true if the path executed all transition successfully\n     */\n    final public TransitionPathResult execute()\n    {\n        for (final PathEntry entry : this.path)\n        {\n            final Collection<Enum<?>> reasons = entry.execute();\n            if (!reasons.isEmpty())\n            {\n                return TransitionPathResult.fail(entry, reasons);\n            }\n        }\n        return TransitionPathResult.success();\n    }\n\n    /**\n     * @return the length of this path\n     */\n    public int size()\n    {\n        return this.path.size();\n    }\n\n    /**\n     * @return the result of the comparison\n     */\n    @Override\n    public int compareTo(final TransitionPath o)\n    {\n        return Integer.valueOf(size()).compareTo(Integer.valueOf(o.size()));\n    }\n\n\n    /**\n     * @return true if the path contains the transition with the given name\n     */\n    public boolean containsTransition(final String name)\n    {\n        return this.uniqueTransitionNames.contains(name);\n    }\n}\n')",[283024]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport com.google.common.base.Predicate;\n\n/**\n * a listener which can be turned on and off by the given predicate\n */\npublic abstract class AbstractConditionalStateListener implements StateListener\n{\n    private final Predicate<Transition> enterFilter;\n    private final Predicate<Transition> exitFilter;\n    private final TransitionGuard        enterReturnValueOnPredicateFalse;\n    private final TransitionGuard        exitReturnValueOnPredicateFalse;\n\n    /**\n     * @param predicate\n     *            the predicate logic used to filter the given listener.\n     */\n    public AbstractConditionalStateListener(final Predicate<Transition> predicate)\n    {\n        this(predicate, predicate);\n    }\n\n    /**\n     * @param enterPredicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener\'s onEnter will be executed.\n     * @param exitPredicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener\'s onExit method will be executed.\n     */\n    public AbstractConditionalStateListener(final Predicate<Transition> enterPredicate, final Predicate<Transition> exitPredicate)\n    {\n        this(enterPredicate, exitPredicate, TransitionGuard.ok(), TransitionGuard.ok());\n    }\n\n    /**\n     * @param enterPredicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener\'s onEnter will be executed.\n     * @param exitPredicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener\'s onExit method will be executed.\n     * @param predicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener will be executed.\n     * @param listener\n     * @param enterDefault\n     *            the transition to return should the enter predicate filter return false\n     * @param exitDefault\n     *            the transition to return should the exit predicate filter return false\n     */\n    public AbstractConditionalStateListener(final Predicate<Transition> enterPredicate, final Predicate<Transition> exitPredicate,\n            final TransitionGuard enterDefault, final TransitionGuard exitDefault)\n    {\n        if (enterPredicate == null)\n        {\n            throw new NullPointerException(""enterPredicate cannot be null"");\n        }\n        if (enterDefault == null)\n        {\n            throw new NullPointerException(""enterDefault cannot be null"");\n        }\n        if (exitPredicate == null)\n        {\n            throw new NullPointerException(""exitPredicate cannot be null"");\n        }\n        if (exitDefault == null)\n        {\n            throw new NullPointerException(""exitDefault cannot be null"");\n        }\n        this.enterFilter = enterPredicate;\n        this.exitFilter = exitPredicate;\n\n        this.enterReturnValueOnPredicateFalse = enterDefault;\n        this.exitReturnValueOnPredicateFalse = exitDefault;\n    }\n\n    /**\n     * the exit condition predicate was successful. Return the result from the exit listener logic.\n     * \n     * @param transition\n     *            the transition\n     * @return the transition return value.\n     */\n    protected abstract TransitionGuard onExitInternal(final Transition transition);\n\n    /**\n     * the enter condition predicate was successful. Return the result from the exit listener logic.\n     * \n     * @param transition\n     *            the transition\n     * @return the transition return value.\n     */\n    protected abstract TransitionGuard onEnterInternal(final Transition transition);\n\n    /**\n     * @param transition\n     * @return the transition return value.\n     */\n    public final TransitionGuard onExit(final Transition transition)\n    {\n        if (!this.exitFilter.apply(transition))\n        {\n            return this.exitReturnValueOnPredicateFalse;\n        }\n        return onExitInternal(transition);\n    }\n\n    /**\n     * @param transition\n     * @return the transition return value.\n     */\n    @Override\n    public final TransitionGuard onEnter(final Transition transition)\n    {\n        if (!this.enterFilter.apply(transition))\n        {\n            return this.enterReturnValueOnPredicateFalse;\n        }\n        return onEnterInternal(transition);\n    }\n\n    /**\n     * @return the return value to use when the predicate logic evaluates to \'false\'\n     */\n    protected TransitionGuard getDefaultEnterReturnValueOnFalse()\n    {\n        return this.enterReturnValueOnPredicateFalse;\n    }\n\n    /**\n     * @return the return value to use when the predicate logic evaluates to \'false\'\n     */\n    protected TransitionGuard getDefaultExitReturnValueOnFalse()\n    {\n        return this.exitReturnValueOnPredicateFalse;\n    }\n\n    @Override\n    public String toString()\n    {\n        return String.format(""conditional listener[enter=%s, exit=%s]"", this.enterFilter, this.exitFilter);\n    }\n}')",[255556]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getStateForName(aaron.test.test.ClaimsPaymentCompleteTest)')","[5827, 5858, 5889, 7687, 7718, 7749, 22821, 22845, 22869, 33900, 33930, 33960, 47040, 47075, 47110, 49140, 49175, 49210, 66290, 66318, 66346, 76294, 76322, 76350, 88590, 88623, 88656, 90570, 90603, 90636, 106712, 106738, 106764, 116481, 116513, 116545, 130465, 130502, 130539, 132685, 132722, 132759, 150843, 150873, 150903, 162094, 162129, 162164, 177344, 177384, 177424, 179744, 179784, 179824, 199414, 199447, 199480, 211458, 211495, 211532, 227552, 227594, 227636, 230072, 230114, 230156, 289181, 289221, 289261, 289513, 289555, 289597]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsSubmitToHeadOfDelivery extends AbstractTransition<ClaimsNotReceived, ClaimsReceivedByHeadOfDelivery>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""submit to head of delivery"";\n\n    TransitionClaimsSubmitToHeadOfDelivery(final ClaimsNotReceived from, final ClaimsReceivedByHeadOfDelivery to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[266283]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\n/**\n * a listener callback used to respond to state changes.\n */\npublic interface StateListener\n{\n    /**\n     *\n     */\n    TransitionGuard onExit(final Transition transition);\n    \n    /**\n     *\n     */\n    TransitionGuard onEnter(final Transition transition);\n}\n')",[280058]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_executeToClaimsPaymentReceived(aaron.test.test.ClaimsPaymentReceivedTest)')","[19312, 20676, 27981, 30653, 41446, 62265, 63805, 72310, 83330, 102945, 104397, 112302, 124537, 146560, 148188, 157293, 170915, 194744, 196504, 206509, 220789, 245822, 247670, 307605, 308415]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_executeToClaimsNotReceived(aaron.test.test.ClaimsNotReceivedTest)')","[6292, 8896, 22989, 29421, 34247, 47565, 50505, 66486, 76617, 89085, 91857, 106894, 116852, 131020, 134128, 151053, 162501, 177944, 181304, 199645, 211889, 228182, 231710, 289891, 291661]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\npublic interface NamedObject\n{\n    /**\n     * @return a name for the object\n     */\n    public String getName();\n}\n')",[277754]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'com.porpoise.fsm.generator.StateMachineGeneratorTest')","[288052, 288075, 288099, 288122]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_moveToClaimsReceivedByHeadOfDelivery(aaron.test.test.ClaimsReceivedByDeliveryTeamTest)')","[15096, 17700, 26733, 30320, 39475, 57505, 60445, 70854, 81493, 98457, 101229, 110950, 122432, 141528, 144636, 155733, 168609, 189304, 192664, 204793, 218349, 240110, 243638, 302891, 304189]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport com.google.common.base.Predicate;\n\n/**\n * a listener which can be turned on and off by the given predicate\n */\npublic abstract class AbstractConditionalStateListener implements StateListener\n{\n    private final Predicate<Transition> enterFilter;\n    private final Predicate<Transition> exitFilter;\n    private final TransitionGuard        enterReturnValueOnPredicateFalse;\n    private final TransitionGuard        exitReturnValueOnPredicateFalse;\n\n    /**\n     * @param predicate\n     *            the predicate logic used to filter the given listener.\n     */\n    public AbstractConditionalStateListener(final Predicate<Transition> predicate)\n    {\n        this(predicate, predicate);\n    }\n\n    /**\n     * @param enterPredicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener\'s onEnter will be executed.\n     * @param exitPredicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener\'s onExit method will be executed.\n     */\n    public AbstractConditionalStateListener(final Predicate<Transition> enterPredicate, final Predicate<Transition> exitPredicate)\n    {\n        this(enterPredicate, exitPredicate, TransitionGuard.ok(), TransitionGuard.ok());\n    }\n\n    /**\n     * @param enterPredicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener\'s onEnter will be executed.\n     * @param exitPredicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener\'s onExit method will be executed.\n     * @param predicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener will be executed.\n     * @param listener\n     * @param enterDefault\n     *            the transition to return should the enter predicate filter return false\n     * @param exitDefault\n     *            the transition to return should the exit predicate filter return false\n     */\n    public AbstractConditionalStateListener(final Predicate<Transition> enterPredicate, final Predicate<Transition> exitPredicate,\n            final TransitionGuard enterDefault, final TransitionGuard exitDefault)\n    {\n        if (enterPredicate == null)\n        {\n            throw new NullPointerException(""enterPredicate cannot be null"");\n        }\n        if (enterDefault == null)\n        {\n            throw new NullPointerException(""enterDefault cannot be null"");\n        }\n        if (exitPredicate == null)\n        {\n            throw new NullPointerException(""exitPredicate cannot be null"");\n        }\n        if (exitDefault == null)\n        {\n            throw new NullPointerException(""exitDefault cannot be null"");\n        }\n        this.enterFilter = enterPredicate;\n        this.exitFilter = exitPredicate;\n\n        this.enterReturnValueOnPredicateFalse = enterDefault;\n        this.exitReturnValueOnPredicateFalse = exitDefault;\n    }\n\n    /**\n     * the exit condition predicate was successful. Return the result from the exit listener logic.\n     * \n     * @param transition\n     *            the transition\n     * @return the transition return value.\n     */\n    protected abstract TransitionGuard onExitInternal(final Transition transition);\n\n    /**\n     * the enter condition predicate was successful. Return the result from the exit listener logic.\n     * \n     * @param transition\n     *            the transition\n     * @return the transition return value.\n     */\n    protected abstract TransitionGuard onEnterInternal(final Transition transition);\n\n    /**\n     * @param transition\n     * @return the transition return value.\n     */\n    public final TransitionGuard onExit(final Transition transition)\n    {\n        if (!this.exitFilter.apply(transition))\n        {\n            return this.exitReturnValueOnPredicateFalse;\n        }\n        return onExitInternal(transition);\n    }\n\n    /**\n     * @param transition\n     * @return the transition return value.\n     */\n    @Override\n    public final TransitionGuard onEnter(final Transition transition)\n    {\n        if (!this.enterFilter.apply(transition))\n        {\n            return this.enterReturnValueOnPredicateFalse;\n        }\n        return onEnterInternal(transition);\n    }\n\n    /**\n     * @return the return value to use when the predicate logic evaluates to \'false\'\n     */\n    protected TransitionGuard getDefaultEnterReturnValueOnFalse()\n    {\n        return this.enterReturnValueOnPredicateFalse;\n    }\n\n    /**\n     * @return the return value to use when the predicate logic evaluates to \'false\'\n     */\n    protected TransitionGuard getDefaultExitReturnValueOnFalse()\n    {\n        return this.exitReturnValueOnPredicateFalse;\n    }\n\n    @Override\n    public String toString()\n    {\n        return String.format(""conditional listener[enter=%s, exit=%s]"", this.enterFilter, this.exitFilter);\n    }\n}')",[255896]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_approveForHod(aaron.test.test.ClaimsReceivedByDeliveryTeamTest)')","[15716, 18320, 27213, 30425, 40075, 58205, 61145, 71414, 82053, 99117, 101889, 111470, 123072, 142268, 145376, 156333, 169309, 190104, 193464, 205453, 219089, 240950, 244478, 303691, 305029]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\n\n/**\n * A holder for \'paths\' -- chains of transitions through the state machine\n */\npublic final class TransitionPaths implements Iterable<TransitionPath>\n{\n    private final Collection<TransitionPath> paths;\n\n    TransitionPaths()\n    {\n        this.paths = new ArrayList<TransitionPath>();\n    }\n\n    boolean add(final TransitionPath path)\n    {\n        if (!this.paths.contains(path))\n        {\n            return this.paths.add(path);\n        }\n        return false;\n    }\n \n    /** \n     * @return the paths\n     */\n    public Collection<TransitionPath> getPaths()\n    {\n        return Collections.unmodifiableCollection(this.paths);\n    }\n\n    /** \n     * get the path at index i\n     */\n    public TransitionPath getPath(final int i)\n    {\n        if (i < 0 || i > getPaths().size())\n        {\n            return null;\n        }\n        int index = 0;\n        for (final TransitionPath path : getPaths())\n        {\n            if (index == i)\n                return path;\n            index++;\n        }\n        return null;\n    }\n\n    /**\n     * return the shorted path. Multiple paths may exist with the same length\n     * \n     * @return the shorted path\n     */\n    public TransitionPath getShortestPath()\n    {\n        if (getPaths().isEmpty())\n            return null;\n        return getPathsAsSortedList().get(0);\n    }\n\n    /**\n     * @return a list of paths, shortest first\n     */\n    public List<TransitionPath> getPathsAsSortedList()\n    {\n        final LinkedList<TransitionPath> pathList = new LinkedList<TransitionPath>(getPaths());\n        Collections.sort(pathList);\n        return pathList;\n    }\n\n    /**\n     * @return the number of paths available between two states\n     */\n    public int size()\n    {\n        return this.paths.size();\n    }\n    \n    /**\n     * @return true if there are no paths between the two states\n     */\n    public boolean isEmpty()\n    {\n        return size() == 0;\n    }\n\n\n    /**\n     * @return the iterator\n     */\n    @Override\n    public Iterator<TransitionPath> iterator()\n    {\n        return getPathsAsSortedList().iterator();\n    }\n\n    /**\n     * @param names the name(s) of the transition(s) to include\n     * @return a {@link TransitionPaths} object which contains a subset of this paths object which contain the transition identified by the given name \n     */\n    public final TransitionPaths getPathsWithTransitions(final String ... names)\n    {\n        return filterPaths(PathFilters.byNames(names));\n    }\n\n    /**\n     * @name the name of the transition\n     * @return a {@link TransitionPaths} object which contains a subset of this paths object which does NOT contain the transition identified by the given name \n     */\n    public final TransitionPaths getPathsAvoidingTransitions(final String ... names)\n    {\n        final Predicate<TransitionPath> filter = PathFilters.byNames(names); \n        return filterPaths(Predicates.not(filter));\n    }\n    \n    /**\n     * @param filter the filter to apply to child paths\n     * @return a new TransitionPaths object which only contains TransitionPaths which match the given filter \n     */\n    public TransitionPaths filterPaths(final Predicate<TransitionPath> filter)\n    {\n        final TransitionPaths matchingPaths = new TransitionPaths();\n        for (final TransitionPath path : this)\n        {\n            if (filter.apply(path))\n            {\n                matchingPaths.add(path);\n            }\n        }\n        return matchingPaths;\n    }\n    \n    /**\n     * @return a string representation\n     */\n    @Override\n    public String toString()\n    {\n        final String newLine = String.format(""%n"");\n        final StringBuilder b = new StringBuilder();\n        for (final Object path : this.paths)\n        {\n            b.append(path).append(newLine);\n        }\n        return b.toString();\n    }\n    \n}')",[258336]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport com.google.common.base.Predicate;\n\n/** \n */\npublic final class ConditionalTransitionListener implements TransitionListener\n{\n    private final  TransitionGuard onFalseResult;\n    private final Predicate<Transition> filter;\n    private final TransitionListener delegate;    \n    /**\n     * @param predicate\n     */\n    public ConditionalTransitionListener(final Predicate<Transition> predicate, final TransitionListener wrappedListener)\n    {\n        this(predicate, wrappedListener, TransitionGuard.ok());\n    }\n    \n    /**\n     * @param predicate\n     */\n    public ConditionalTransitionListener(final Predicate<Transition> predicate, final TransitionListener wrappedListener, final TransitionGuard onFalseResultParam)\n    {\n        if (predicate == null)\n        {\n            throw new NullPointerException(""predicate cannot be null"");        \n        }\n        if (wrappedListener == null)\n        {\n            throw new NullPointerException(""wrappedListener cannot be null"");        \n        }\n        if (onFalseResultParam == null)\n        {\n            throw new NullPointerException(""onFalseResultParam cannot be null"");        \n        }\n        this.filter = predicate;\n        this.onFalseResult = onFalseResultParam;\n        this.delegate = wrappedListener; \n    }\n    \n    /**\n     * fired when a transition is executed\n     * \n     * @return the transition guard\n     */\n    @Override\n    public TransitionGuard onTransition(final Transition transition)\n    {\n        if (this.filter.apply(transition))\n        {\n            return this.delegate.onTransition(transition);\n        }\n        return this.onFalseResult;\n    }\n}\n')",[255978]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsMarkPaymentAsReceived extends AbstractTransition<ClaimsReadyForPayment, ClaimsPaymentReceived>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""mark payment as received"";\n\n    TransitionClaimsMarkPaymentAsReceived(final ClaimsReadyForPayment from, final ClaimsPaymentReceived to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[264460]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\n\n/**\n * A collection of useful implementations of TransitionListener\n */\npublic enum TransitionListeners \n{\n    ;//uninstantiable\n\n    /**\n     * a listener which records the transitions\n     */\n    public static class RecordingTransitionListener implements TransitionListener\n    {\n        private final List<Transition> transitions = new ArrayList<Transition>();\n\n        @Override\n        public TransitionGuard onTransition(final Transition transition)\n        {\n            this.transitions.add(transition);\n            return TransitionGuard.ok();\n        }\n\n        /**\n         * @return the enter transitions\n         */\n        public List<Transition> getTransitions()\n        {\n            return Collections.unmodifiableList(this.transitions);\n        }\n    }\n    \n    private static class BlockingListener implements TransitionListener\n    {\n        private final Enum<?> reason;\n        public BlockingListener(final Enum<?> reasonValue)\n        {\n            this.reason = reasonValue;\n        }\n    \n        @Override\n        public TransitionGuard onTransition(final Transition transition)\n        {\n            return TransitionGuard.stopEventually(this.reason);\n        }\n    }\n    \n    private static TransitionListener BLOCKING_INSTANCE = new BlockingListener(null); \n\n    /**\n     * @return a new recording transition listener\n     */\n    public static RecordingTransitionListener recordingListener()\n    {\n        return new RecordingTransitionListener();\n    }\n    /**\n     * @return a listener which returns @{code TransitionGuard.stopEventually()}\n     */\n    public static TransitionListener blockingListener()\n    {\n        return BLOCKING_INSTANCE;\n    }\n    /**\n     * @return a listener which returns @{code TransitionGuard.stopEventually()}\n     */\n    public static TransitionListener blockingListener(final Enum<?> reason)\n    {\n        return new BlockingListener(reason);\n    }\n    \n    /**\n     * @return a listener which disallows transitions when the given condition returns false\n     */\n    public static TransitionListener blockOnFalse(final Predicate<Transition> condition, final Enum<?> reason)\n    {\n        final TransitionListener delegate = TransitionListeners.blockingListener(reason);\n        final TransitionListener listener = filter(condition, delegate);\n        return listener;\n    }\n\n    /**\n     * @param condition\n     *            the condition (predicate) used to evaluate whether or not the given listener should be invoked\n     * @param delegate\n     *            the listener to invoke when the condition returns true\n     * @return the conditional listener which wraps the given listener\n     */\n    public static ConditionalTransitionListener filter(final Predicate<Transition> condition, final TransitionListener delegate)\n    {\n        final ConditionalTransitionListener listener = new ConditionalTransitionListener(condition, delegate);\n        return listener;\n    }    \n    /**\n     * @return a listener which disallows transitions when the given condition returns true\n     */\n    public static TransitionListener blockOnTrue(final Predicate<Transition> condition, final Enum<?> reason)\n    {\n        return blockOnFalse(Predicates.not(condition), reason);\n    }\n\n }')",[255118]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_moveToClaimsReadyForPayment(aaron.test.test.ClaimsReceivedByHeadOfDeliveryTest)')","[13360, 16708, 26445, 30237, 38978, 55545, 59325, 70518, 81030, 96609, 100173, 110638, 121901, 139456, 143452, 155373, 168027, 187064, 191384, 204397, 217733, 237758, 242294, 300973, 302311]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_approveForDeliveryTeam(aaron.test.test.ClaimsReceivedByMonitoringOfficerTest)')","[10787, 10818, 10849, 14135, 14166, 14197, 25221, 25245, 25269, 37311, 37341, 37371, 52640, 52675, 52710, 56420, 56455, 56490, 69090, 69118, 69146, 79475, 79503, 79531, 93870, 93903, 93936, 97434, 97467, 97500, 109312, 109338, 109364, 120122, 120154, 120186, 136385, 136422, 136459, 140381, 140418, 140455, 153843, 153873, 153903, 166080, 166115, 166150, 183744, 183784, 183824, 188064, 188104, 188144, 202714, 202747, 202780, 215674, 215711, 215748, 234272, 234314, 234356, 238808, 238850, 238892, 296991, 297031, 297071, 298795, 298837, 298879]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', ""package p.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport p.*;\nimport p.TransitionGuard.Reasons;\nimport p.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for TestStartState\n */\npublic class TestStartStateTest extends AbstractTestTest\n{\n    /**\n     * test the state machine can move into the 'TestStartState' state\n     */\n    @Test\n    public void test_executeToTestStartState()\n    {\n        Assert.assertNotNull(moveToTestStartState());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for 'startState' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final TestStateMachine fsm = newStateMachine();\n        final String name =fsm.startState().getName();\n        Assert.assertEquals(fsm.startState(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the startState state\n     */\n    final TestStartState moveToTestStartState()\n    {\n        final TestStateMachine fsm = newStateMachine();\n        final TestStartState startState = fsm.startState();\n\n        // call the method under test\n        fsm.executeToState(startState);\n\n        Assert.assertSame(startState, fsm.getCurrentState());\n        Assert.assertEquals(startState.getName(), fsm.getCurrentStateName());\n        \n        return startState;\n    }\n\n}\n"")",[287210]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * <p>\n * A TransitionPathResult represents the result of trying to execute a {@link TransitionPath}.\n * You can query the result, asking if it was successful or not. In the case where it was not\n * successful, you can retrieve a collection of \'reason\' enumerations, which indicate why the\n * path was not successful. The reasons given will be those from the exit/enter state guards or \n * transition guards. \n * </p>\n * See {@link TransitionPath#execute()}.\n */\npublic final class TransitionPathResult\n{\n    private Collection<Enum<?>> reasons;\n    private PathEntry failedEntry;\n    \n    private TransitionPathResult(final PathEntry failedEntryValue, final Collection<Enum<?>> reasonValues)\n    {\n        this.reasons = reasonValues;\n        this.failedEntry = failedEntryValue;\n    }\n    \n    /**\n     * @return the failure reasons\n     */\n    public Collection<Enum<?>> getFailureReasons()\n    {\n        return Collections.unmodifiableCollection(this.reasons);\n    }\n    \n    /**\n     * @return the failed path entry\n     */\n    public PathEntry getFailedEntry()\n    {\n        return this.failedEntry;\n    }\n    \n    /**\n     * @return true if the transition was successful\n     */\n    public boolean isSuccess()\n    {\n        return this.reasons.isEmpty();\n    }\n    \n    /**\n     * @return true if the transition failed\n     */\n    public boolean isFail()\n    {\n        return !isSuccess();\n    }\n    \n    /**\n     * factory method for success results\n     * @return a new success result\n     */\n    static TransitionPathResult success()\n    {\n        final Collection<Enum<?>> r = Collections.emptyList();\n        return new TransitionPathResult(null, r);\n    }\n\n    /**\n     * factory method for failure results\n     * @return a new failure result\n     */\n    static TransitionPathResult fail(final PathEntry failedEntryValue, final Collection<Enum<?>> reasonValues)\n    {\n        return new TransitionPathResult(failedEntryValue, reasonValues);\n    }\n\n    /**\n     * factory method for failure results\n     * @return a new failure result\n     */\n    static TransitionPathResult fail(final Enum<?> ... reasonValues)\n    {\n        final Collection<Enum<?>> r = new ArrayList<Enum<?>>();\n        if (reasonValues == null || reasonValues.length == 0)\n        {\n            r.add(TransitionGuard.Reasons.NO_REASON_GIVEN);\n        }\n        else\n        {\n            r.addAll(Arrays.asList(reasonValues));\n        }\n        return new TransitionPathResult(null, r);\n    }\n    \n    /** \n     * @return the string representation\n     */\n    @Override\n    public String toString()\n    {\n        if(isSuccess())\n        {\n            return ""SUCCESS"";\n        }\n        return String.format(""FAIL: entry=%s reasons=%s"", this.failedEntry, this.reasons);\n    }\n}\n')",[283463]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'com.porpoise.fsm.model.StateMachineTest')","[194, 31843, 74379, 114282, 159682, 208904]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.HashSet;\n\n/**\n * A TransitionPath represents a chain of transitions from one state to another\n */\npublic final class TransitionPath implements Comparable<TransitionPath>\n{\n    private final List<PathEntry> path;\n    private final Set<String>     uniqueTransitionNames;\n\n    TransitionPath(final State startState)\n    {\n        this(Arrays.asList(new PathEntry[] { new PathEntry(startState) }));\n    }\n\n    private TransitionPath(final List<PathEntry> states)\n    {\n        this.path = new ArrayList<PathEntry>(states);\n        this.uniqueTransitionNames = new HashSet<String>();\n        for (final PathEntry pe : states)\n        {\n            if (pe.getTransition() != null)\n            {\n                this.uniqueTransitionNames.add(pe.getTransition().getName());\n            }\n        }\n    }\n\n    /**\n     * add a unique transition to the given target\n     * @param target\n     * @param trans\n     * @return true if this method invocation has altered the TransitionPath, false otherwise\n     */\n    boolean add(final State target, final Transition trans)\n    {\n        final PathEntry entry = new PathEntry(target, trans);\n        if (this.path.contains(entry))\n        {\n            return false;\n        }\n        this.uniqueTransitionNames.add(trans.getName());\n        return this.path.add(entry);\n    }\n\n    public TransitionPath clonePath()\n    {\n        return new TransitionPath(this.path);\n    }\n\n    @Override\n    public String toString()\n    {\n        final StringBuilder b = new StringBuilder(""path: "");\n        for (final PathEntry s : this.path)\n        {\n            b.append(s);\n        }\n        return b.toString();\n    }\n\n    @Override\n    public int hashCode()\n    {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((this.path == null) ? 0 : this.path.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(final Object obj)\n    {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        final TransitionPath other = (TransitionPath) obj;\n        if (this.path == null)\n        {\n            if (other.path != null)\n                return false;\n        }\n        else if (!this.path.equals(other.path))\n            return false;\n        return true;\n    }\n\n    /**\n     * execute this path on\'t state machine\n     * \n     * @return true if the path executed all transition successfully\n     */\n    final public TransitionPathResult execute()\n    {\n        for (final PathEntry entry : this.path)\n        {\n            final Collection<Enum<?>> reasons = entry.execute();\n            if (!reasons.isEmpty())\n            {\n                return TransitionPathResult.fail(entry, reasons);\n            }\n        }\n        return TransitionPathResult.success();\n    }\n\n    /**\n     * @return the length of this path\n     */\n    public int size()\n    {\n        return this.path.size();\n    }\n\n    /**\n     * @return the result of the comparison\n     */\n    @Override\n    public int compareTo(final TransitionPath o)\n    {\n        return Integer.valueOf(size()).compareTo(Integer.valueOf(o.size()));\n    }\n\n\n    /**\n     * @return true if the path contains the transition with the given name\n     */\n    public boolean containsTransition(final String name)\n    {\n        return this.uniqueTransitionNames.contains(name);\n    }\n}\n')",[259723]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsPaymentReceived extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""Payment Received"";\n\n    private TransitionClaimsMarkPaymentAsComplete markPaymentAsComplete; \n    \n    /**\n     * @param fsm\n     */\n    ClaimsPaymentReceived(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        // Transition mark payment as complete\n        this.markPaymentAsComplete = new TransitionClaimsMarkPaymentAsComplete(this, getStateMachine().paymentComplete());\n        allTransitions.add(this.markPaymentAsComplete); \n\n        return allTransitions;    \n    }\n    \n    /**\n     * execute the mark payment as complete transition\n     * @return true if the transition was successful\n     */\n    public boolean markPaymentAsComplete() {\n        this.markPaymentAsComplete.execute();\n        return this.markPaymentAsComplete.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerMarkPaymentAsCompleteListener(final T listener)\n    {\n        return this.markPaymentAsComplete.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterMarkPaymentAsCompleteListener(final TransitionListener listener)\n    {\n        return this.markPaymentAsComplete.unregisterListener(listener);\n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[266443]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsReceivedByHeadOfDelivery\n */\npublic class ClaimsReceivedByHeadOfDeliveryTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the \'ClaimsReceivedByHeadOfDelivery\' state\n     */\n    @Test\n    public void test_executeToClaimsReceivedByHeadOfDelivery()\n    {\n        Assert.assertNotNull(moveToClaimsReceivedByHeadOfDelivery());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for \'receivedByHeadOfDelivery\' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.receivedByHeadOfDelivery().getName();\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the receivedByHeadOfDelivery state\n     */\n    final ClaimsReceivedByHeadOfDelivery moveToClaimsReceivedByHeadOfDelivery()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsReceivedByHeadOfDelivery receivedByHeadOfDelivery = fsm.receivedByHeadOfDelivery();\n\n        // call the method under test\n        fsm.executeToState(receivedByHeadOfDelivery);\n\n        Assert.assertSame(receivedByHeadOfDelivery, fsm.getCurrentState());\n        Assert.assertEquals(receivedByHeadOfDelivery.getName(), fsm.getCurrentStateName());\n        \n        return receivedByHeadOfDelivery;\n    }\n\n    \n    @Test\n    public void test_getPathBetweenClaimsReceivedByHeadOfDeliveryAndClaimsReceivedByDeliveryTeam()\n    {\n\n        final ClaimsReceivedByHeadOfDelivery receivedByHeadOfDelivery = moveToClaimsReceivedByHeadOfDelivery();\n        final ClaimsStateMachine fsm = receivedByHeadOfDelivery.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'receivedByHeadOfDelivery\'"", receivedByHeadOfDelivery, fsm.getCurrentState());\n\n        final TransitionPaths paths = receivedByHeadOfDelivery.getPaths(fsm.receivedByDeliveryTeam());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        receivedByHeadOfDelivery.registerRejectToDeliveryTeamListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'receivedByHeadOfDelivery\'"", receivedByHeadOfDelivery, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.receivedByDeliveryTeam(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'rejectToDeliveryTeam\' transition \n     */\n    @Test\n    public void test_rejectToDeliveryTeam()\n    {\n        final ClaimsReceivedByHeadOfDelivery receivedByHeadOfDelivery = moveToClaimsReceivedByHeadOfDelivery();\n        final ClaimsStateMachine fsm = receivedByHeadOfDelivery.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        receivedByHeadOfDelivery.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        receivedByHeadOfDelivery.rejectToDeliveryTeam();\n\n        //\n        // assert the current state is now ClaimsReceivedByDeliveryTeam\n        //\n        Assert.assertEquals(fsm.receivedByDeliveryTeam(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.receivedByDeliveryTeam().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsRejectToDeliveryTeam.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsRejectToDeliveryTeam.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(receivedByHeadOfDelivery.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReceivedByHeadOfDelivery\' can be moved into the ClaimsReceivedByDeliveryTeam state\n     */\n    @Test\n    public void test_moveToClaimsReceivedByDeliveryTeam()\n    {\n        final ClaimsReceivedByHeadOfDelivery receivedByHeadOfDelivery = moveToClaimsReceivedByHeadOfDelivery();\n        final ClaimsStateMachine fsm = receivedByHeadOfDelivery.getStateMachine();\n        receivedByHeadOfDelivery.getPaths(fsm.receivedByDeliveryTeam());\n        \n    }\n    \n    @Test\n    public void test_getPathBetweenClaimsReceivedByHeadOfDeliveryAndClaimsReadyForPayment()\n    {\n\n        final ClaimsReceivedByHeadOfDelivery receivedByHeadOfDelivery = moveToClaimsReceivedByHeadOfDelivery();\n        final ClaimsStateMachine fsm = receivedByHeadOfDelivery.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'receivedByHeadOfDelivery\'"", receivedByHeadOfDelivery, fsm.getCurrentState());\n\n        final TransitionPaths paths = receivedByHeadOfDelivery.getPaths(fsm.readyForPayment());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        receivedByHeadOfDelivery.registerMarkAsReadyForPaymentListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'receivedByHeadOfDelivery\'"", receivedByHeadOfDelivery, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.readyForPayment(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'markAsReadyForPayment\' transition \n     */\n    @Test\n    public void test_markAsReadyForPayment()\n    {\n        final ClaimsReceivedByHeadOfDelivery receivedByHeadOfDelivery = moveToClaimsReceivedByHeadOfDelivery();\n        final ClaimsStateMachine fsm = receivedByHeadOfDelivery.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        receivedByHeadOfDelivery.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        receivedByHeadOfDelivery.markAsReadyForPayment();\n\n        //\n        // assert the current state is now ClaimsReadyForPayment\n        //\n        Assert.assertEquals(fsm.readyForPayment(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.readyForPayment().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsMarkAsReadyForPayment.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsMarkAsReadyForPayment.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(receivedByHeadOfDelivery.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReceivedByHeadOfDelivery\' can be moved into the ClaimsReadyForPayment state\n     */\n    @Test\n    public void test_moveToClaimsReadyForPayment()\n    {\n        final ClaimsReceivedByHeadOfDelivery receivedByHeadOfDelivery = moveToClaimsReceivedByHeadOfDelivery();\n        final ClaimsStateMachine fsm = receivedByHeadOfDelivery.getStateMachine();\n        receivedByHeadOfDelivery.getPaths(fsm.readyForPayment());\n        \n    }\n}\n')",[271757]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsReceivedByHeadOfDeliveryAndClaimsReadyForPayment(aaron.test.test.ClaimsReceivedByHeadOfDeliveryTest)')","[13143, 13174, 13205, 16491, 16522, 16553, 26277, 26301, 26325, 38768, 38798, 38828, 55300, 55335, 55370, 59080, 59115, 59150, 70322, 70350, 70378, 80834, 80862, 80890, 96378, 96411, 96444, 99942, 99975, 100008, 110456, 110482, 110508, 121677, 121709, 121741, 139197, 139234, 139271, 143193, 143230, 143267, 155163, 155193, 155223, 167782, 167817, 167852, 186784, 186824, 186864, 191104, 191144, 191184, 204166, 204199, 204232, 217474, 217511, 217548, 237464, 237506, 237548, 242000, 242042, 242084, 300693, 300733, 300773, 302017, 302059, 302101]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\n\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Set;\nimport java.util.HashSet;\n\n/**\n * A TransitionPath represents a chain of transitions from one state to another\n */\nenum PathFilters\n{\n    ; // uninstantiable\n\n    /**\n     * @return a TransitionPath filter which returns \'true\' when a path contains a transition\n     * with the given name\n     */\n    public static final Predicate<TransitionPath> byName(final String name)\n    {\n        return new Predicate<TransitionPath>() {\n            public boolean apply(final TransitionPath path) {\n                return path.containsTransition(name);\n            }\n        };\n    }\n\n    /**\n     * @return a TransitionPath filter which returns \'true\' when a path contains a transition with one of the given names\n     */\n     @SuppressWarnings(""unchecked"")\n    public static final Predicate<TransitionPath> byNames(final String ... names)\n    {\n        final Set<String> uniqueNames = new HashSet<String>(Arrays.asList(names));\n        final Collection<Predicate<TransitionPath>> filters = new ArrayList<Predicate<TransitionPath>>(uniqueNames.size());\n        for (final String name : uniqueNames)\n        {\n            if (name != null)\n            {\n                filters.add(byName(name));\n            }\n        }\n        Predicate<TransitionPath>[] filtersArray = new Predicate[filters.size()];\n        filtersArray = filters.toArray(filtersArray);\n        return Predicates.or(filtersArray);\n    }\n}\n')",[282084]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsReceivedByMonitoringOfficer extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""Received By Monitoring Officer"";\n\n    private TransitionClaimsApproveForDeliveryTeam approveForDeliveryTeam; \n    private TransitionClaimsApproveForHeadOfDelivery approveForHeadOfDelivery; \n    private TransitionClaimsRejectToParticipant rejectToParticipant; \n    \n    /**\n     * @param fsm\n     */\n    ClaimsReceivedByMonitoringOfficer(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        // Transition approve for delivery team\n        this.approveForDeliveryTeam = new TransitionClaimsApproveForDeliveryTeam(this, getStateMachine().receivedByDeliveryTeam());\n        allTransitions.add(this.approveForDeliveryTeam); \n\n        // Transition approve for head of delivery\n        this.approveForHeadOfDelivery = new TransitionClaimsApproveForHeadOfDelivery(this, getStateMachine().receivedByHeadOfDelivery());\n        allTransitions.add(this.approveForHeadOfDelivery); \n\n        // Transition reject to participant\n        this.rejectToParticipant = new TransitionClaimsRejectToParticipant(this, getStateMachine().notReceived());\n        allTransitions.add(this.rejectToParticipant); \n\n        return allTransitions;    \n    }\n    \n    /**\n     * execute the approve for delivery team transition\n     * @return true if the transition was successful\n     */\n    public boolean approveForDeliveryTeam() {\n        this.approveForDeliveryTeam.execute();\n        return this.approveForDeliveryTeam.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerApproveForDeliveryTeamListener(final T listener)\n    {\n        return this.approveForDeliveryTeam.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterApproveForDeliveryTeamListener(final TransitionListener listener)\n    {\n        return this.approveForDeliveryTeam.unregisterListener(listener);\n    }\n    \n    /**\n     * execute the approve for head of delivery transition\n     * @return true if the transition was successful\n     */\n    public boolean approveForHeadOfDelivery() {\n        this.approveForHeadOfDelivery.execute();\n        return this.approveForHeadOfDelivery.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerApproveForHeadOfDeliveryListener(final T listener)\n    {\n        return this.approveForHeadOfDelivery.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterApproveForHeadOfDeliveryListener(final TransitionListener listener)\n    {\n        return this.approveForHeadOfDelivery.unregisterListener(listener);\n    }\n    \n    /**\n     * execute the reject to participant transition\n     * @return true if the transition was successful\n     */\n    public boolean rejectToParticipant() {\n        this.rejectToParticipant.execute();\n        return this.rejectToParticipant.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerRejectToParticipantListener(final T listener)\n    {\n        return this.rejectToParticipant.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterRejectToParticipantListener(final TransitionListener listener)\n    {\n        return this.rejectToParticipant.unregisterListener(listener);\n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[268618]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsRejectToDeliveryTeam extends AbstractTransition<ClaimsReceivedByHeadOfDelivery, ClaimsReceivedByDeliveryTeam>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""reject to delivery team"";\n\n    TransitionClaimsRejectToDeliveryTeam(final ClaimsReceivedByHeadOfDelivery from, final ClaimsReceivedByDeliveryTeam to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[265051]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsApproveForHeadOfDelivery extends AbstractTransition<ClaimsReceivedByMonitoringOfficer, ClaimsReceivedByHeadOfDelivery>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""approve for head of delivery"";\n\n    TransitionClaimsApproveForHeadOfDelivery(final ClaimsReceivedByMonitoringOfficer from, final ClaimsReceivedByHeadOfDelivery to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[269117]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsStartStateAndClaimsNotReceived(aaron.test.test.ClaimsStartStateTest)')","[17235, 17266, 17297, 18971, 19002, 19033, 27621, 27645, 27669, 40722, 40752, 40782, 59920, 59955, 59990, 61880, 61915, 61950, 71890, 71918, 71946, 82656, 82684, 82712, 100734, 100767, 100800, 102582, 102615, 102648, 111912, 111938, 111964, 123763, 123795, 123827, 144081, 144118, 144155, 146153, 146190, 146227, 156843, 156873, 156903, 170066, 170101, 170136, 192064, 192104, 192144, 194304, 194344, 194384, 206014, 206047, 206080, 219890, 219927, 219964, 243008, 243050, 243092, 245360, 245402, 245444, 305809, 305849, 305889, 306637, 306679, 306721]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_approveForHod(aaron.test.test.ClaimsReceivedByDeliveryTeamTest)')","[15747, 15778, 15809, 18351, 18382, 18413, 27237, 27261, 27285, 40105, 40135, 40165, 58240, 58275, 58310, 61180, 61215, 61250, 71442, 71470, 71498, 82081, 82109, 82137, 99150, 99183, 99216, 101922, 101955, 101988, 111496, 111522, 111548, 123104, 123136, 123168, 142305, 142342, 142379, 145413, 145450, 145487, 156363, 156393, 156423, 169344, 169379, 169414, 190144, 190184, 190224, 193504, 193544, 193584, 205486, 205519, 205552, 219126, 219163, 219200, 240992, 241034, 241076, 244520, 244562, 244604, 303731, 303771, 303811, 305071, 305113, 305155]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_moveToClaimsReceivedByMonitoringOfficer(aaron.test.test.ClaimsReceivedByDeliveryTeamTest)')","[14972, 17576, 26637, 30299, 39355, 57365, 60305, 70742, 81381, 98325, 101097, 110846, 122304, 141380, 144488, 155613, 168469, 189144, 192504, 204661, 218201, 239942, 243470, 302731, 304021]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsPaymentRejectedAndClaimsReadyForPayment(aaron.test.test.ClaimsPaymentRejectedTest)')","[20335, 20366, 20397, 28677, 28701, 28725, 42453, 42483, 42513, 63420, 63455, 63490, 73122, 73150, 73178, 84269, 84297, 84325, 104034, 104067, 104100, 113056, 113082, 113108, 125612, 125644, 125676, 147781, 147818, 147855, 158163, 158193, 158223, 172092, 172127, 172162, 196064, 196104, 196144, 207466, 207499, 207532, 222034, 222071, 222108, 247208, 247250, 247292, 309699, 309739, 309779, 310527, 310569, 310611]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_create(com.porpoise.fsm.model.StateMachineTest)')","[2200, 3316, 21357, 28924, 31248, 42945, 44205, 64582, 73824, 84729, 85917, 105126, 113647, 126136, 127468, 149013, 158987, 172664, 174104, 197401, 208169, 222638, 224150, 248828, 249798]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_moveToClaimsNotReceived(aaron.test.test.ClaimsStartStateTest)')","[16987, 17018, 17049, 18723, 18754, 18785, 27429, 27453, 27477, 40482, 40512, 40542, 59640, 59675, 59710, 61600, 61635, 61670, 71666, 71694, 71722, 82432, 82460, 82488, 100470, 100503, 100536, 102318, 102351, 102384, 111704, 111730, 111756, 123507, 123539, 123571, 143785, 143822, 143859, 145857, 145894, 145931, 156603, 156633, 156663, 169786, 169821, 169856, 191744, 191784, 191824, 193984, 194024, 194064, 205750, 205783, 205816, 219594, 219631, 219668, 242672, 242714, 242756, 245024, 245066, 245108, 305489, 305529, 305569, 306301, 306343, 306385]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.HashMap;\n        \nabstract class AbstractClaimsState implements State\n{\n    private final Map<String, Transition> transitionsByName;\n\n    private final ClaimsStateMachine stateMachine;\n    private final StateNotifier notifier;\n    \n    AbstractClaimsState(final ClaimsStateMachine fsm)\n    {\n        if (fsm == null)\n        {\n            throw new NullPointerException(""state machine cannot be null"");\n        }\n        this.stateMachine = fsm;\n        this.notifier = fsm.newNotifier();\n        this.transitionsByName = new HashMap<String, Transition>();\n    }\n    \n    public ClaimsStateMachine getStateMachine()\n    {\n        return this.stateMachine;\n    }\n\n\n    /**\n     * @param fsm\n     */\n    void initialise()\n    {\n        for(final Transition transition  : initialiseTransitions())\n        {\n            this.transitionsByName.put(transition.getName(), transition);\n        }    \n    }\n    \n    Collection<Transition> getTransitions()\n    {\n        return this.transitionsByName.values();\n    }\n\n    Collection<String> getTransitionNames()\n    {\n        return this.transitionsByName.keySet();\n    }\n    \n    final Transition getTransitionForName(final String name)\n    {\n        return this.transitionsByName.get(name);\n    }\n\n    abstract Collection<Transition> initialiseTransitions();\n\n    /**\n     * @return true if the listener was successfully registered\n     */\n    public <T extends StateListener> T registerListener(final T listener)\n    {\n        final boolean registered = this.notifier.registerListener(listener);\n        assert registered : ""listener not registered: "" + listener;\n        return listener;\n    }\n\n    public boolean unregisterListener(final StateListener listener)\n    {\n        return this.notifier.unregisterListener(listener);\n    }\n\n    final TransitionGuard onExit(final Transition transition)\n    {\n        return this.notifier.onBeforeTransition(transition);\n    }\n\n    final TransitionGuard onEnter(final Transition transition)\n    {\n        return this.notifier.onAfterTransition(transition);\n    }\n\n    /**\n     * @param the target state\n     * @return the transition paths\n     */\n    public TransitionPaths getPaths(final State toState)\n    {\n        final TransitionPaths paths = new TransitionPaths();\n        final TransitionPath path = new TransitionPath(this);\n\n        appendPathRecursive(paths, path, toState);\n\n        return paths;\n    }\n\n    private void appendPathRecursive(final TransitionPaths paths, final TransitionPath srcPath, final State goal)\n    {\n        for (final Transition transition : getTransitions())\n        {\n            final TransitionPath path = srcPath.clonePath();\n            final AbstractClaimsState targetState = (AbstractClaimsState) transition.getTarget();\n\n            final boolean notRecursivePathLoop = path.add(targetState, transition);\n\n            if (notRecursivePathLoop)\n            {\n                if (targetState.equals(goal))\n                {\n                   paths.add(path); \n                }\n                else\n                {\n                    targetState.appendPathRecursive(paths, path, goal);\n                }\n            }\n        }\n    }\n    \n    /**\n     *\n     */\n    @Override\n    public String toString()\n    {\n        final StringBuilder builder = new StringBuilder();\n        final String newLine = String.format(""%n"");\n        builder.append(getName()).append(newLine);\n        for (final Transition transition : getTransitions())\n        {\n            builder.append(""\\t"").append(transition).append(newLine);\n        }\n        builder.append(""\\t"").append(this.notifier).append(newLine);\n        return builder.toString();\n    }\n}\n')",[263173]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\n/**\n * represents the state in a state machine\n */\npublic interface State extends NamedObject\n{\n    /**\n     * Return a unique name for this state.\n     * \n     * A state may need to be persisted, a common way to do this is \n     * to persist an enumeration of state values.\n     *   \n     * @return the unique name of this state\n     */\n    @Override\n    public String getName();\n    \n    /**\n     * allow callbacks to register their interest\n     * @param listener the listener to register\n     * @return true if the listener was registered successfully\n     */\n    <T extends StateListener> T registerListener(final T listener);\n\n    /**\n     * allow callbacks (listeners) to unregister their interest\n     * @param listener the listener to unregister\n     * @return true if the listener was unregistered successfully\n     */\n    boolean unregisterListener(final StateListener listener);\n    \n    /**\n     * @return an object representing all paths to the given state from this state\n     */\n    TransitionPaths getPaths(final State to);\n}\n')",[278041]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\n\n\n/**\n * Representation of the state machine. Through a ClaimsStateMachine instance you can:\n * <ul>\n * <li>Create a new instance (see @{link createAndStart()} and @{link create()})</li>\n * <li>Access all states by their names</li>\n * <li>register and unregister listeners which will be notified of every state transition</li>\n * <li>navigate to (execute) states via transitions</li>\n * <li>retrieve state instances by their names</li>\n * </ul>\n *\n * States returned via this state machine may *only* be used in this state machine.\n * For example, this is not valid:\n * <pre>\n * ClaimsStateMachine fsmOne = ClaimsStateMachine.createAndStart();\n * ClaimsStateMachine fsmTwo = ClaimsStateMachine.createAndStart();\n * Object stateA = fsmOne.<some state>();\n * fsmTwo.executeToState(stateA); // invalid  -- cannot share state instances between state machines\n * </pre>\n */\npublic class ClaimsStateMachine\n{\n    private StateNotifier notifier;\n    private State                     currentState;\n    private final Map<String, AbstractClaimsState>  stateByName;\n\n    private ClaimsPaymentRejected claimspaymentrejected;\n    private ClaimsReadyForPayment claimsreadyforpayment;\n    private ClaimsReceivedByHeadOfDelivery claimsreceivedbyheadofdelivery;\n    private ClaimsNotReceived claimsnotreceived;\n    private ClaimsPaymentReceived claimspaymentreceived;\n    private ClaimsReceivedByDeliveryTeam claimsreceivedbydeliveryteam;\n    private ClaimsPaymentComplete claimspaymentcomplete;\n    private ClaimsStartState claimsstartstate;\n    private ClaimsReceivedByMonitoringOfficer claimsreceivedbymonitoringofficer;\n\n    /**\n     *\n     */\n    private ClaimsStateMachine()\n    {\n        super();\n        this.stateByName = new HashMap<String, AbstractClaimsState>();\n    }\n\n    /**\n     * @return a new notifier\n     */\n    final StateNotifier newNotifier()\n    {\n        return new StateNotifier();\n    }\n\n    /**\n     * state machines need to be explicitly started.\n     * This is a convenience method for returning a new state machine which is \n     * already in the start state\n     *\n     * @return the new state machine\n     */\n    public static ClaimsStateMachine createAndStart()\n    {\n        ClaimsStateMachine instance = create();\n        instance.start();\n        return instance;\n    }\n\n    /**\n     * factory method used to create state machines\n     *\n     * @return a new state machine instance\n     */\n    public static ClaimsStateMachine create()\n    {\n        final ClaimsStateMachine fsm = new ClaimsStateMachine();\n\n        fsm.notifier = fsm.newNotifier();\n        \n        //\n        // Create states\n        //\n        fsm.claimspaymentrejected = new ClaimsPaymentRejected(fsm);\n        final State oldClaimsPaymentRejectedEntry = fsm.stateByName.put(fsm.claimspaymentrejected.getName(), fsm.claimspaymentrejected);\n        assert oldClaimsPaymentRejectedEntry == null : ""duplicate state names: "" + fsm.claimspaymentrejected.getName();\n\n        fsm.claimsreadyforpayment = new ClaimsReadyForPayment(fsm);\n        final State oldClaimsReadyForPaymentEntry = fsm.stateByName.put(fsm.claimsreadyforpayment.getName(), fsm.claimsreadyforpayment);\n        assert oldClaimsReadyForPaymentEntry == null : ""duplicate state names: "" + fsm.claimsreadyforpayment.getName();\n\n        fsm.claimsreceivedbyheadofdelivery = new ClaimsReceivedByHeadOfDelivery(fsm);\n        final State oldClaimsReceivedByHeadOfDeliveryEntry = fsm.stateByName.put(fsm.claimsreceivedbyheadofdelivery.getName(), fsm.claimsreceivedbyheadofdelivery);\n        assert oldClaimsReceivedByHeadOfDeliveryEntry == null : ""duplicate state names: "" + fsm.claimsreceivedbyheadofdelivery.getName();\n\n        fsm.claimsnotreceived = new ClaimsNotReceived(fsm);\n        final State oldClaimsNotReceivedEntry = fsm.stateByName.put(fsm.claimsnotreceived.getName(), fsm.claimsnotreceived);\n        assert oldClaimsNotReceivedEntry == null : ""duplicate state names: "" + fsm.claimsnotreceived.getName();\n\n        fsm.claimspaymentreceived = new ClaimsPaymentReceived(fsm);\n        final State oldClaimsPaymentReceivedEntry = fsm.stateByName.put(fsm.claimspaymentreceived.getName(), fsm.claimspaymentreceived);\n        assert oldClaimsPaymentReceivedEntry == null : ""duplicate state names: "" + fsm.claimspaymentreceived.getName();\n\n        fsm.claimsreceivedbydeliveryteam = new ClaimsReceivedByDeliveryTeam(fsm);\n        final State oldClaimsReceivedByDeliveryTeamEntry = fsm.stateByName.put(fsm.claimsreceivedbydeliveryteam.getName(), fsm.claimsreceivedbydeliveryteam);\n        assert oldClaimsReceivedByDeliveryTeamEntry == null : ""duplicate state names: "" + fsm.claimsreceivedbydeliveryteam.getName();\n\n        fsm.claimspaymentcomplete = new ClaimsPaymentComplete(fsm);\n        final State oldClaimsPaymentCompleteEntry = fsm.stateByName.put(fsm.claimspaymentcomplete.getName(), fsm.claimspaymentcomplete);\n        assert oldClaimsPaymentCompleteEntry == null : ""duplicate state names: "" + fsm.claimspaymentcomplete.getName();\n\n        fsm.claimsstartstate = new ClaimsStartState(fsm);\n        final State oldClaimsStartStateEntry = fsm.stateByName.put(fsm.claimsstartstate.getName(), fsm.claimsstartstate);\n        assert oldClaimsStartStateEntry == null : ""duplicate state names: "" + fsm.claimsstartstate.getName();\n\n        fsm.claimsreceivedbymonitoringofficer = new ClaimsReceivedByMonitoringOfficer(fsm);\n        final State oldClaimsReceivedByMonitoringOfficerEntry = fsm.stateByName.put(fsm.claimsreceivedbymonitoringofficer.getName(), fsm.claimsreceivedbymonitoringofficer);\n        assert oldClaimsReceivedByMonitoringOfficerEntry == null : ""duplicate state names: "" + fsm.claimsreceivedbymonitoringofficer.getName();\n\n\n        //\n        // Initialise transitions\n        //\n        fsm.claimspaymentrejected.initialise();\n        fsm.claimsreadyforpayment.initialise();\n        fsm.claimsreceivedbyheadofdelivery.initialise();\n        fsm.claimsnotreceived.initialise();\n        fsm.claimspaymentreceived.initialise();\n        fsm.claimsreceivedbydeliveryteam.initialise();\n        fsm.claimspaymentcomplete.initialise();\n        fsm.claimsstartstate.initialise();\n        fsm.claimsreceivedbymonitoringofficer.initialise();\n        return fsm;\n    }\n\n    /**\n     * @return the current state\n     */\n    public State getCurrentState()\n    {\n        return this.currentState;\n    }\n    \n    /**\n     * @param goal the target state\n     * @return a TransitionPaths object from the current state to the given goal state\n     */\n    public TransitionPaths getPaths(final State goal)\n    {\n        return getCurrentState().getPaths(goal);\n    }\n\n    /**\n     * @param goal\n     *            the target state\n     * @return a TransitionPaths object from the current state to the given goal state\n     */\n    public TransitionPaths getSuccessfulPaths(final State goal)\n    {\n        final TransitionPaths allPaths = getCurrentState().getPaths(goal);\n        final TransitionPaths successfulPaths = new TransitionPaths();\n        if (allPaths != null)\n        {\n            for (final TransitionPath path : allPaths)\n            {\n                final TransitionPathResult result = executePathDryRun(path);\n                if (result != null && result.isSuccess())\n                {\n                    successfulPaths.add(path);\n                }\n            }\n        }\n        return successfulPaths;\n    }\n\n    /**\n     * @param path\n     *            the path to execute w/o affecting the current state. All registered listeners however will be notified.\n     * @return the result\n     */\n    public final TransitionPathResult executePathDryRun(final TransitionPath path)\n    {\n        final State beforeState = getCurrentState();\n        TransitionPathResult result;\n        try\n        {\n            result = path.execute();\n        }\n        finally\n        {\n            setCurrentState(beforeState);\n        }\n        return result;\n    }\n\n    /**\n     * @param path\n     *            the path to execute\n     * @return the result\n     */\n    public final TransitionPathResult executePath(final TransitionPath path)\n    {\n        return path.execute();\n    }\n\n    /**\n     * @param the given state name\n     * @return the result\n     */\n    public TransitionPathResult executeToState(final String name)\n    {   \n        final State state = getStateForName(name);\n        if (state == null)\n        {\n            throw new IllegalArgumentException(String.format(""No state exists with the name \'%s\'"", name));\n        }\n        return executeToState(state);\n    }\n\n    /**\n     * @param the given state name\n     * @return the result\n     */\n    public TransitionPathResult executeToStateDryRun(final String name)\n    {   \n        final State state = getStateForName(name);\n        if (state == null)\n        {\n            throw new IllegalArgumentException(String.format(""No state exists with the name \'%s\'"", name));\n        }\n        return executeToStateDryRun(state);\n    }\n    \n    /**\n     * After calling, the state will be reset its current state see {@link #executeToState(State)}\n     * \n     * @param to\n     *            the goal state\n     * @return the result of executing to the given state via the shorted available path\n     */\n    public TransitionPathResult executeToStateDryRun(final State to)\n    {\n        final State beforeState = getCurrentState();\n        TransitionPathResult result;\n        try\n        {\n            result = executeToState(to);\n        }\n        finally\n        {\n            setCurrentState(beforeState);\n        }\n        return result;\n    }\n\n\n    /**\n     * jump to the given state via the shortest \'path\'.\n     * \n     * @param to\n     *            the goal state\n     * @return the result of trying to move to the given state via the shortest available path, or null if no path was found. If the state machine was already in the given state it returns false. If the state\n     *         machine has now moved into the given state it returns true.\n     */\n    public TransitionPathResult executeToState(final State to)\n    {\n        if (to == getCurrentState())\n        {\n            return TransitionPathResult.fail(TransitionGuard.Reasons.ALREADY_IN_TARGET_STATE);\n        }\n\n        final TransitionPath path = getShortestSuccessfulPath(to);\n        \n        if (path != null)\n        {\n            return path.execute();\n        }\n\n        return TransitionPathResult.fail(TransitionGuard.Reasons.TARGET_STATE_UNREACHABLE);\n    }\n\n    /**\n     * @param to\n     *            the target (goal) state\n     * @return the first path available which can transition to the given state\n     */\n    public TransitionPath getShortestSuccessfulPath(final State to)\n    {\n        final State beforeState = getCurrentState();\n        TransitionPath path;\n        try\n        {\n            path = getShortestSuccessfulPathInternal(to);\n        }\n        finally\n        {\n            setCurrentState(beforeState);\n        }\n\n        return path;\n    }\n\n    private TransitionPath getShortestSuccessfulPathInternal(final State to)\n    {\n        final TransitionPaths paths = getPaths(to);\n        boolean success = false;\n        final State beforeState = getCurrentState();\n        for (final TransitionPath path : paths)\n        {\n            StateLog.debug(""trying "" + path);\n            success = executeToStateInternal(path, to);\n            if (success)\n            {\n                return path;\n            }\n            setCurrentState(beforeState);\n        }\n        return null;\n    }\n\n    /**\n     * jump to the given state via the path of transitions\n     * \n     * @return true if this call had any effect\n     */\n    private boolean executeToStateInternal(final TransitionPath path, final State to)\n    {\n        if (to == getCurrentState())\n        {\n            return false;\n        }\n        if (path == null)\n        {\n            throw new IllegalStateException(String.format(""can\'t get to \'%s\' from \'%s\'"", getCurrentStateName(), to.getName()));\n        }\n        path.execute();\n        return to == getCurrentState();\n    }\n\n    /**\n     * @return the name of the current state\n     */\n    public String getCurrentStateName()\n    {\n        return getCurrentState() == null ? null : getCurrentState().getName();\n    }\n\n    /**\n     * @return the start state\n     * @throws IllegalStateException\n     *             if the state machine was already started\n     */\n    public ClaimsStartState start()\n    {\n        if (getCurrentState() != null && getCurrentState().equals(this.claimsstartstate))\n        {\n            throw new IllegalStateException(""already started"");\n        }\n        setCurrentState(this.claimsstartstate);\n        return this.claimsstartstate;\n    }\n\n    /**\n     * @return the ClaimsPaymentRejected state\n     */\n    public ClaimsPaymentRejected paymentRejected()\n    {\n        return this.claimspaymentrejected;\n    }    \n    /**\n     * @return the ClaimsReadyForPayment state\n     */\n    public ClaimsReadyForPayment readyForPayment()\n    {\n        return this.claimsreadyforpayment;\n    }    \n    /**\n     * @return the ClaimsReceivedByHeadOfDelivery state\n     */\n    public ClaimsReceivedByHeadOfDelivery receivedByHeadOfDelivery()\n    {\n        return this.claimsreceivedbyheadofdelivery;\n    }    \n    /**\n     * @return the ClaimsNotReceived state\n     */\n    public ClaimsNotReceived notReceived()\n    {\n        return this.claimsnotreceived;\n    }    \n    /**\n     * @return the ClaimsPaymentReceived state\n     */\n    public ClaimsPaymentReceived paymentReceived()\n    {\n        return this.claimspaymentreceived;\n    }    \n    /**\n     * @return the ClaimsReceivedByDeliveryTeam state\n     */\n    public ClaimsReceivedByDeliveryTeam receivedByDeliveryTeam()\n    {\n        return this.claimsreceivedbydeliveryteam;\n    }    \n    /**\n     * @return the ClaimsPaymentComplete state\n     */\n    public ClaimsPaymentComplete paymentComplete()\n    {\n        return this.claimspaymentcomplete;\n    }    \n    /**\n     * @return the ClaimsStartState state\n     */\n    public ClaimsStartState startState()\n    {\n        return this.claimsstartstate;\n    }    \n    /**\n     * @return the ClaimsReceivedByMonitoringOfficer state\n     */\n    public ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer()\n    {\n        return this.claimsreceivedbymonitoringofficer;\n    }    \n\n\n    /**\n     * @return a collection of all the transitions across all states\n     */\n    public Collection<Transition> getTransitions()\n    {\n        final Collection<Transition> states = new LinkedList<Transition>();\n        for (final AbstractClaimsState state : this.stateByName.values())\n        {\n            states.addAll(state.getTransitions());\n        }\n        return states;\n    }\n\n    /**\n     * @return a collection of all the names for all the transitions across all states\n     */\n    public Collection<String> getTransitionNames()\n    {\n        final Collection<String> names = new LinkedList<String>();\n        for (final AbstractClaimsState state : this.stateByName.values())\n        {\n            names.addAll(state.getTransitionNames());\n        }\n        return names;\n    }\n\n    /**\n     * @return a collection of all states for this state machine\n     */\n    public Collection<State> getStates()\n    {\n        final Collection<State> states = new LinkedList<State>();\n        for (final AbstractClaimsState state : this.stateByName.values())\n        {\n            states.add(state);\n        }\n        return states;\n    }\n\n\n    /**\n     * @return a collection of all the names of all the states for this state machine\n     */\n    public Collection<String> getStateNames()\n    {\n        return this.stateByName.keySet();\n    }\n    \n    /**\n     * @param name the name of the state\n     * @return the state for the given name\n     */\n    public State getStateForName(final String name)\n    {\n        if (name == null)\n        {\n            throw new NullPointerException(""Invalid argument: null state name"");\n        }\n        return this.stateByName.get(name);\n    }\n\n    /**\n     * @param name\n     *            the name of the transition\n     * @return the transition for the given name\n     */\n    public Transition getTransitionForName(final String name)\n    {\n        for (final AbstractClaimsState state : this.stateByName.values())\n        {\n            final Transition transition = state.getTransitionForName(name);\n            if (transition != null)\n            {\n                return transition;\n            }\n        }\n        return null;\n    }\n    \n    final void setCurrentState(State newState)\n    {\n        this.currentState = newState;\n    }\n\n\n    /**\n     * @param listeners\n     */\n    public void registerListeners(final StateListener... listeners)\n    {\n        for (final StateListener listener : listeners)\n        {\n            registerListener(listener);\n        }\n    }\n\n    /**\n     * register and return the given listener\n     * @param listener the registered listener\n     * @return the registered listener (for chaining)\n     */\n    public <T extends StateListener> T registerListener(final T listener)\n    {\n        final boolean added = this.notifier.registerListener(listener);\n        assert added;\n        return listener;\n    }\n\n    /**\n     * unregister a listener\n     * @return true if the listener was successfully unregistered\n     */\n    public boolean unregisterListener(final StateListener listener)\n    {\n        return this.notifier.unregisterListener(listener);\n    }\n\n    final TransitionGuard onBeforeTransition(final Transition transition)\n    {\n        return this.notifier.onBeforeTransition(transition);\n    }\n\n    final TransitionGuard onAfterTransition(final Transition transition)\n    {\n        return this.notifier.onAfterTransition(transition);\n    }\n\n    /**\n     * drops your entire database.\n     * Either that or just represents the state machine as a string. \n     * Take your chances.\n     */\n    @Override\n    public String toString()\n    {\n        final String newLine = String.format(""%n"");\n        final StringBuilder builder = new StringBuilder(""ClaimsStateMachine"").append(newLine);\n        builder.append(""\\t"").append(this.notifier).append(newLine);\n        builder.append(""Current State:"");\n        builder.append(this.currentState).append(newLine);\n        builder.append(this.claimspaymentrejected).append(newLine);\n        builder.append(this.claimsreadyforpayment).append(newLine);\n        builder.append(this.claimsreceivedbyheadofdelivery).append(newLine);\n        builder.append(this.claimsnotreceived).append(newLine);\n        builder.append(this.claimspaymentreceived).append(newLine);\n        builder.append(this.claimsreceivedbydeliveryteam).append(newLine);\n        builder.append(this.claimspaymentcomplete).append(newLine);\n        builder.append(this.claimsstartstate).append(newLine);\n        builder.append(this.claimsreceivedbymonitoringofficer).append(newLine);\n        return builder.toString();\n    }\n}\n')",[253738]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsReadyForPaymentAndClaimsPaymentRejected(aaron.test.test.ClaimsReadyForPaymentTest)')","[7904, 11624, 24045, 29672, 35704, 49385, 53585, 67718, 77976, 90801, 94761, 108038, 118407, 132944, 137384, 152373, 164203, 180024, 184824, 201097, 213689, 230366, 235406, 293593, 294883]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsReceivedByDeliveryTeamAndClaimsReceivedByHeadOfDelivery(aaron.test.test.ClaimsReceivedByDeliveryTeamTest)')","[15592, 18196, 27117, 30404, 39955, 58065, 61005, 71302, 81941, 98985, 101757, 111366, 122944, 142120, 145228, 156213, 169169, 189944, 193304, 205321, 218941, 240782, 244310, 303531, 304861]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_executeToClaimsPaymentRejected(aaron.test.test.ClaimsPaymentRejectedTest)')","[20211, 20242, 20273, 28581, 28605, 28629, 42333, 42363, 42393, 63280, 63315, 63350, 73010, 73038, 73066, 84157, 84185, 84213, 103902, 103935, 103968, 112952, 112978, 113004, 125484, 125516, 125548, 147633, 147670, 147707, 158043, 158073, 158103, 171952, 171987, 172022, 195904, 195944, 195984, 207334, 207367, 207400, 221886, 221923, 221960, 247040, 247082, 247124, 309539, 309579, 309619, 310359, 310401, 310443]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_markPaymentAsReceived(aaron.test.test.ClaimsReadyForPaymentTest)')","[8431, 8462, 8493, 12151, 12182, 12213, 24453, 24477, 24501, 36214, 36244, 36274, 49980, 50015, 50050, 54180, 54215, 54250, 68194, 68222, 68250, 78452, 78480, 78508, 91362, 91395, 91428, 95322, 95355, 95388, 108480, 108506, 108532, 118951, 118983, 119015, 133573, 133610, 133647, 138013, 138050, 138087, 152883, 152913, 152943, 164798, 164833, 164868, 180704, 180744, 180784, 185504, 185544, 185584, 201658, 201691, 201724, 214318, 214355, 214392, 231080, 231122, 231164, 236120, 236162, 236204, 294273, 294313, 294353, 295597, 295639, 295681]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_joinStartState(com.porpoise.fsm.model.StartStateTest)')","[101, 2820, 21165, 28842, 30871, 31014, 43645, 64358, 73338, 73473, 73606, 85389, 104918, 113244, 113397, 126876, 148773, 158395, 158545, 158713, 173464, 197137, 207701, 207879, 223478, 248340, 248502]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport java.util.Collection;\n\n/**\n * Transition represents a transition between two states \n */\npublic interface Transition extends NamedObject\n{\n    /**\n     * General failure reasons for transitions\n     */\n    enum Reasons\n    {\n        /** \n         * The current state of the state machine does not match the source state of the transition\n         */\n        INVALID_SOURCE_STATE;\n    }\n\n    /** \n     * execute the transition\n     * @return the new state\n     */\n    Collection<Enum<?>> execute();\n     \n    /**\n     * @return the source state\n     */\n    State getSource();\n     \n    /**\n     * @return the target state\n     */\n    State getTarget();\n\n    /**\n     * @param listener\n     * @return the registered listener\n     */\n    <T extends TransitionListener> T registerListener(final T listener);\n\n    /**\n     * @param listener\n     * @return true if the listener was removed successfully\n     */\n    boolean unregisterListener(final TransitionListener listener);\n}\n')",[262145]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsReceivedByDeliveryTeam\n */\npublic class ClaimsReceivedByDeliveryTeamTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the \'ClaimsReceivedByDeliveryTeam\' state\n     */\n    @Test\n    public void test_executeToClaimsReceivedByDeliveryTeam()\n    {\n        Assert.assertNotNull(moveToClaimsReceivedByDeliveryTeam());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for \'receivedByDeliveryTeam\' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.receivedByDeliveryTeam().getName();\n        Assert.assertEquals(fsm.receivedByDeliveryTeam(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the receivedByDeliveryTeam state\n     */\n    final ClaimsReceivedByDeliveryTeam moveToClaimsReceivedByDeliveryTeam()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsReceivedByDeliveryTeam receivedByDeliveryTeam = fsm.receivedByDeliveryTeam();\n\n        // call the method under test\n        fsm.executeToState(receivedByDeliveryTeam);\n\n        Assert.assertSame(receivedByDeliveryTeam, fsm.getCurrentState());\n        Assert.assertEquals(receivedByDeliveryTeam.getName(), fsm.getCurrentStateName());\n        \n        return receivedByDeliveryTeam;\n    }\n\n    \n    @Test\n    public void test_getPathBetweenClaimsReceivedByDeliveryTeamAndClaimsReceivedByMonitoringOfficer()\n    {\n\n        final ClaimsReceivedByDeliveryTeam receivedByDeliveryTeam = moveToClaimsReceivedByDeliveryTeam();\n        final ClaimsStateMachine fsm = receivedByDeliveryTeam.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'receivedByDeliveryTeam\'"", receivedByDeliveryTeam, fsm.getCurrentState());\n\n        final TransitionPaths paths = receivedByDeliveryTeam.getPaths(fsm.receivedByMonitoringOfficer());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        receivedByDeliveryTeam.registerRejectToMoListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'receivedByDeliveryTeam\'"", receivedByDeliveryTeam, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.receivedByMonitoringOfficer(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'rejectToMo\' transition \n     */\n    @Test\n    public void test_rejectToMo()\n    {\n        final ClaimsReceivedByDeliveryTeam receivedByDeliveryTeam = moveToClaimsReceivedByDeliveryTeam();\n        final ClaimsStateMachine fsm = receivedByDeliveryTeam.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        receivedByDeliveryTeam.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        receivedByDeliveryTeam.rejectToMo();\n\n        //\n        // assert the current state is now ClaimsReceivedByMonitoringOfficer\n        //\n        Assert.assertEquals(fsm.receivedByMonitoringOfficer(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.receivedByMonitoringOfficer().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsRejectToMo.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsRejectToMo.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(receivedByDeliveryTeam.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReceivedByDeliveryTeam\' can be moved into the ClaimsReceivedByMonitoringOfficer state\n     */\n    @Test\n    public void test_moveToClaimsReceivedByMonitoringOfficer()\n    {\n        final ClaimsReceivedByDeliveryTeam receivedByDeliveryTeam = moveToClaimsReceivedByDeliveryTeam();\n        final ClaimsStateMachine fsm = receivedByDeliveryTeam.getStateMachine();\n        receivedByDeliveryTeam.getPaths(fsm.receivedByMonitoringOfficer());\n        \n    }\n    \n    @Test\n    public void test_getPathBetweenClaimsReceivedByDeliveryTeamAndClaimsReceivedByHeadOfDelivery()\n    {\n\n        final ClaimsReceivedByDeliveryTeam receivedByDeliveryTeam = moveToClaimsReceivedByDeliveryTeam();\n        final ClaimsStateMachine fsm = receivedByDeliveryTeam.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'receivedByDeliveryTeam\'"", receivedByDeliveryTeam, fsm.getCurrentState());\n\n        final TransitionPaths paths = receivedByDeliveryTeam.getPaths(fsm.receivedByHeadOfDelivery());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        receivedByDeliveryTeam.registerApproveForHodListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'receivedByDeliveryTeam\'"", receivedByDeliveryTeam, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'approveForHod\' transition \n     */\n    @Test\n    public void test_approveForHod()\n    {\n        final ClaimsReceivedByDeliveryTeam receivedByDeliveryTeam = moveToClaimsReceivedByDeliveryTeam();\n        final ClaimsStateMachine fsm = receivedByDeliveryTeam.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        receivedByDeliveryTeam.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        receivedByDeliveryTeam.approveForHod();\n\n        //\n        // assert the current state is now ClaimsReceivedByHeadOfDelivery\n        //\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsApproveForHod.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsApproveForHod.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(receivedByDeliveryTeam.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReceivedByDeliveryTeam\' can be moved into the ClaimsReceivedByHeadOfDelivery state\n     */\n    @Test\n    public void test_moveToClaimsReceivedByHeadOfDelivery()\n    {\n        final ClaimsReceivedByDeliveryTeam receivedByDeliveryTeam = moveToClaimsReceivedByDeliveryTeam();\n        final ClaimsStateMachine fsm = receivedByDeliveryTeam.getStateMachine();\n        receivedByDeliveryTeam.getPaths(fsm.receivedByHeadOfDelivery());\n        \n    }\n}\n')",[274250]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', ""package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsPaymentComplete\n */\npublic class ClaimsPaymentCompleteTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the 'ClaimsPaymentComplete' state\n     */\n    @Test\n    public void test_executeToClaimsPaymentComplete()\n    {\n        Assert.assertNotNull(moveToClaimsPaymentComplete());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for 'paymentComplete' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.paymentComplete().getName();\n        Assert.assertEquals(fsm.paymentComplete(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the paymentComplete state\n     */\n    final ClaimsPaymentComplete moveToClaimsPaymentComplete()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsPaymentComplete paymentComplete = fsm.paymentComplete();\n\n        // call the method under test\n        fsm.executeToState(paymentComplete);\n\n        Assert.assertSame(paymentComplete, fsm.getCurrentState());\n        Assert.assertEquals(paymentComplete.getName(), fsm.getCurrentStateName());\n        \n        return paymentComplete;\n    }\n\n}\n"")",[274331]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsReceivedByHeadOfDelivery extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""Received By Head of Delivery"";\n\n    private TransitionClaimsRejectToDeliveryTeam rejectToDeliveryTeam; \n    private TransitionClaimsMarkAsReadyForPayment markAsReadyForPayment; \n    \n    /**\n     * @param fsm\n     */\n    ClaimsReceivedByHeadOfDelivery(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        // Transition reject to delivery team\n        this.rejectToDeliveryTeam = new TransitionClaimsRejectToDeliveryTeam(this, getStateMachine().receivedByDeliveryTeam());\n        allTransitions.add(this.rejectToDeliveryTeam); \n\n        // Transition mark as ready for payment\n        this.markAsReadyForPayment = new TransitionClaimsMarkAsReadyForPayment(this, getStateMachine().readyForPayment());\n        allTransitions.add(this.markAsReadyForPayment); \n\n        return allTransitions;    \n    }\n    \n    /**\n     * execute the reject to delivery team transition\n     * @return true if the transition was successful\n     */\n    public boolean rejectToDeliveryTeam() {\n        this.rejectToDeliveryTeam.execute();\n        return this.rejectToDeliveryTeam.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerRejectToDeliveryTeamListener(final T listener)\n    {\n        return this.rejectToDeliveryTeam.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterRejectToDeliveryTeamListener(final TransitionListener listener)\n    {\n        return this.rejectToDeliveryTeam.unregisterListener(listener);\n    }\n    \n    /**\n     * execute the mark as ready for payment transition\n     * @return true if the transition was successful\n     */\n    public boolean markAsReadyForPayment() {\n        this.markAsReadyForPayment.execute();\n        return this.markAsReadyForPayment.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerMarkAsReadyForPaymentListener(final T listener)\n    {\n        return this.markAsReadyForPayment.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterMarkAsReadyForPaymentListener(final TransitionListener listener)\n    {\n        return this.markAsReadyForPayment.unregisterListener(listener);\n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[264854]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsReceivedByMonitoringOfficerAndClaimsNotReceived(aaron.test.test.ClaimsReceivedByMonitoringOfficerTest)')","[11159, 11190, 11221, 14507, 14538, 14569, 25509, 25533, 25557, 37671, 37701, 37731, 53060, 53095, 53130, 56840, 56875, 56910, 69426, 69454, 69482, 79811, 79839, 79867, 94266, 94299, 94332, 97830, 97863, 97896, 109624, 109650, 109676, 120506, 120538, 120570, 136829, 136866, 136903, 140825, 140862, 140899, 154203, 154233, 154263, 166500, 166535, 166570, 184224, 184264, 184304, 188544, 188584, 188624, 203110, 203143, 203176, 216118, 216155, 216192, 234776, 234818, 234860, 239312, 239354, 239396, 297471, 297511, 297551, 299299, 299341, 299383]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_executeToClaimsReceivedByHeadOfDelivery(aaron.test.test.ClaimsReceivedByHeadOfDeliveryTest)')","[12740, 16088, 25965, 30132, 38378, 54845, 58625, 69958, 80470, 95949, 99513, 110118, 121261, 138716, 142712, 154773, 167327, 186264, 190584, 203737, 216993, 236918, 241454, 300173, 301471]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsReceivedByDeliveryTeam\n */\npublic class ClaimsReceivedByDeliveryTeamTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the \'ClaimsReceivedByDeliveryTeam\' state\n     */\n    @Test\n    public void test_executeToClaimsReceivedByDeliveryTeam()\n    {\n        Assert.assertNotNull(moveToClaimsReceivedByDeliveryTeam());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for \'receivedByDeliveryTeam\' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.receivedByDeliveryTeam().getName();\n        Assert.assertEquals(fsm.receivedByDeliveryTeam(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the receivedByDeliveryTeam state\n     */\n    final ClaimsReceivedByDeliveryTeam moveToClaimsReceivedByDeliveryTeam()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsReceivedByDeliveryTeam receivedByDeliveryTeam = fsm.receivedByDeliveryTeam();\n\n        // call the method under test\n        fsm.executeToState(receivedByDeliveryTeam);\n\n        Assert.assertSame(receivedByDeliveryTeam, fsm.getCurrentState());\n        Assert.assertEquals(receivedByDeliveryTeam.getName(), fsm.getCurrentStateName());\n        \n        return receivedByDeliveryTeam;\n    }\n\n    \n    @Test\n    public void test_getPathBetweenClaimsReceivedByDeliveryTeamAndClaimsReceivedByMonitoringOfficer()\n    {\n\n        final ClaimsReceivedByDeliveryTeam receivedByDeliveryTeam = moveToClaimsReceivedByDeliveryTeam();\n        final ClaimsStateMachine fsm = receivedByDeliveryTeam.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'receivedByDeliveryTeam\'"", receivedByDeliveryTeam, fsm.getCurrentState());\n\n        final TransitionPaths paths = receivedByDeliveryTeam.getPaths(fsm.receivedByMonitoringOfficer());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        receivedByDeliveryTeam.registerRejectToMoListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'receivedByDeliveryTeam\'"", receivedByDeliveryTeam, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.receivedByMonitoringOfficer(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'rejectToMo\' transition \n     */\n    @Test\n    public void test_rejectToMo()\n    {\n        final ClaimsReceivedByDeliveryTeam receivedByDeliveryTeam = moveToClaimsReceivedByDeliveryTeam();\n        final ClaimsStateMachine fsm = receivedByDeliveryTeam.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        receivedByDeliveryTeam.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        receivedByDeliveryTeam.rejectToMo();\n\n        //\n        // assert the current state is now ClaimsReceivedByMonitoringOfficer\n        //\n        Assert.assertEquals(fsm.receivedByMonitoringOfficer(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.receivedByMonitoringOfficer().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsRejectToMo.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsRejectToMo.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(receivedByDeliveryTeam.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReceivedByDeliveryTeam\' can be moved into the ClaimsReceivedByMonitoringOfficer state\n     */\n    @Test\n    public void test_moveToClaimsReceivedByMonitoringOfficer()\n    {\n        final ClaimsReceivedByDeliveryTeam receivedByDeliveryTeam = moveToClaimsReceivedByDeliveryTeam();\n        final ClaimsStateMachine fsm = receivedByDeliveryTeam.getStateMachine();\n        receivedByDeliveryTeam.getPaths(fsm.receivedByMonitoringOfficer());\n        \n    }\n    \n    @Test\n    public void test_getPathBetweenClaimsReceivedByDeliveryTeamAndClaimsReceivedByHeadOfDelivery()\n    {\n\n        final ClaimsReceivedByDeliveryTeam receivedByDeliveryTeam = moveToClaimsReceivedByDeliveryTeam();\n        final ClaimsStateMachine fsm = receivedByDeliveryTeam.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'receivedByDeliveryTeam\'"", receivedByDeliveryTeam, fsm.getCurrentState());\n\n        final TransitionPaths paths = receivedByDeliveryTeam.getPaths(fsm.receivedByHeadOfDelivery());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        receivedByDeliveryTeam.registerApproveForHodListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'receivedByDeliveryTeam\'"", receivedByDeliveryTeam, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'approveForHod\' transition \n     */\n    @Test\n    public void test_approveForHod()\n    {\n        final ClaimsReceivedByDeliveryTeam receivedByDeliveryTeam = moveToClaimsReceivedByDeliveryTeam();\n        final ClaimsStateMachine fsm = receivedByDeliveryTeam.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        receivedByDeliveryTeam.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        receivedByDeliveryTeam.approveForHod();\n\n        //\n        // assert the current state is now ClaimsReceivedByHeadOfDelivery\n        //\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsApproveForHod.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsApproveForHod.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(receivedByDeliveryTeam.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReceivedByDeliveryTeam\' can be moved into the ClaimsReceivedByHeadOfDelivery state\n     */\n    @Test\n    public void test_moveToClaimsReceivedByHeadOfDelivery()\n    {\n        final ClaimsReceivedByDeliveryTeam receivedByDeliveryTeam = moveToClaimsReceivedByDeliveryTeam();\n        final ClaimsStateMachine fsm = receivedByDeliveryTeam.getStateMachine();\n        receivedByDeliveryTeam.getPaths(fsm.receivedByHeadOfDelivery());\n        \n    }\n}\n')",[273973]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsInit extends AbstractTransition<ClaimsStartState, ClaimsNotReceived>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""init"";\n\n    TransitionClaimsInit(final ClaimsStartState from, final ClaimsNotReceived to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[268203]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\n/**\n * tests for TestStateMachine\n */\npublic class ListenerAdapter implements StateListener \n{\n    private TransitionGuard entranceGuard;\n    private TransitionGuard exitGuard;\n\n    /**\n     * Default Constructor\n     */\n    public ListenerAdapter()\n    {\n        this(TransitionGuard.ok(), TransitionGuard.ok());\n    }\n\n    /**\n     * @param entrance the entrance guard\n     * @param exit the exit guard\n     */\n    public ListenerAdapter(final TransitionGuard entrance, final TransitionGuard exit)\n    {\n        if (entrance == null)\n        {\n            throw new NullPointerException(""entrance guard type cannot be null"");\n        }\n        if (exit == null)\n        {\n            throw new NullPointerException(""exit guard type cannot be null"");\n        }\n        this.entranceGuard = entrance;\n        this.exitGuard = exit;\n    }\n\n    /**\n     * @param transition\n     * @return \'continue\'\n     */\n    public TransitionGuard onExit(final Transition transition)\n    {\n        return this.exitGuard;\n    }\n\n    /**\n     * @param transition\n     * @return \'continue\'\n     */\n    public TransitionGuard onEnter(final Transition transition)\n    {\n        return this.entranceGuard;\n    }\n}\n')",[283759]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_rejectToParticipant(aaron.test.test.ClaimsReceivedByMonitoringOfficerTest)')","[11283, 11314, 11345, 14631, 14662, 14693, 25605, 25629, 25653, 37791, 37821, 37851, 53200, 53235, 53270, 56980, 57015, 57050, 69538, 69566, 69594, 79923, 79951, 79979, 94398, 94431, 94464, 97962, 97995, 98028, 109728, 109754, 109780, 120634, 120666, 120698, 136977, 137014, 137051, 140973, 141010, 141047, 154323, 154353, 154383, 166640, 166675, 166710, 184384, 184424, 184464, 188704, 188744, 188784, 203242, 203275, 203308, 216266, 216303, 216340, 234944, 234986, 235028, 239480, 239522, 239564, 297631, 297671, 297711, 299467, 299509, 299551]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport com.google.common.base.Predicate;\n\n/**\n * A collection of useful implementations of StateListener\n */\npublic enum StateListeners \n{\n    ;//uninstantiable\n    \n    static class BlockEntryListener extends ListenerAdapter\n    {\n        private final Enum<?> reason;\n        public BlockEntryListener(final Enum<?> reason)\n        {\n            super(TransitionGuard.stopEventually(reason), TransitionGuard.ok());\n            this.reason = reason;\n        }\n        public BlockEntryListener()\n        {\n            this(null);\n        }\n\n        @Override\n        public String toString()\n        {\n            return String.format(""block entry (reason=%s)"", this.reason);\n        }\n    }\n\n    static class BlockExitListener extends ListenerAdapter\n    {\n        private final Enum<?> reason;\n        public BlockExitListener(final Enum<?> reason)\n        {\n            super(TransitionGuard.ok(), TransitionGuard.stopEventually(reason));\n            this.reason = reason;\n        }\n        public BlockExitListener()\n        {\n            this(null);\n        }\n\n        @Override\n        public String toString()\n        {\n            return String.format(""block exit (reason=%s)"", this.reason);\n        }\n    }\n\n    /**\n     */\n    public static RecordingListener recordingListener()\n    {\n        return new RecordingListener();\n    }\n\n    /**\n     * a listener which records the transitions\n     */\n    public static class RecordingListener extends ListenerAdapter\n    {\n        private final List<Transition> enterTransitions = new ArrayList<Transition>();\n        private final List<Transition> exitTransitions  = new ArrayList<Transition>();\n\n        @Override\n        public TransitionGuard onExit(final Transition transition)\n        {\n            this.exitTransitions.add(transition);\n            return TransitionGuard.ok();\n        }\n\n        @Override\n        public TransitionGuard onEnter(final Transition transition)\n        {\n            this.enterTransitions.add(transition);\n            return TransitionGuard.ok();\n        }\n\n        /**\n         * @return the exit transitions\n         */\n        public List<Transition> getExitTransitions()\n        {\n            return Collections.unmodifiableList(this.exitTransitions);\n        }\n\n        /**\n         * @return the enter transitions\n         */\n        public List<Transition> getEnterTransitions()\n        {\n            return Collections.unmodifiableList(this.enterTransitions);\n        }\n\n        @Override\n        public String toString()\n        {\n            return ""recording listener"";\n        }\n    }\n\n    /**\n     */\n    public static class EchoListener extends ListenerAdapter\n    {\n        private final PrintStream out;\n\n        public EchoListener(final PrintStream outStream)\n        {\n            if (outStream == null)\n            {\n                throw new NullPointerException();\n            }\n            this.out = outStream;\n        }\n\n        @Override\n        public TransitionGuard onEnter(final Transition transition)\n        {\n            this.out.println(String.format(""enter \'%s\' via \'%s\'"", transition.getTarget().getName(), transition.getName()));\n            return TransitionGuard.ok();\n        }\n\n        @Override\n        public TransitionGuard onExit(final Transition transition)\n        {\n            this.out.println(String.format(""exit \'%s\' via \'%s\'"", transition.getSource().getName(), transition.getName()));\n            return TransitionGuard.ok();\n        }\n        @Override\n        public String toString()\n        {\n            return ""echo listener"";\n        }\n    }\n\n    public static EchoListener echoListener(final PrintStream out)\n    {\n        return new EchoListener(out);\n    }\n\n    /**\n     * @return the registered listener\n     */\n    public static StateListener blockEntryListener()\n    {\n        return blockEntryListener(null);\n    }\n\n    /**\n     * @return the registered listener\n     */\n    public static StateListener blockEntryListener(final Enum<?> reason)\n    {\n        return new BlockEntryListener(reason);\n    }\n\n    /**\n     * @return the listener\n     */\n    public static StateListener blockExitListener()\n    {\n        return blockExitListener(null);\n    }\n\n    /**\n     * @return the listener\n     */\n    public static StateListener blockExitListener(final Enum<?> reason)\n    {\n        return new BlockExitListener(reason);\n    }\n\n    /**\n     * @param state\n     *            the state to match\n     * @return a predicate which will return true for transitions whos target state matches the given state\n     */\n    public static Predicate<Transition> targetStateEquals(final State state)\n    {\n        if (state == null)\n        {\n            throw new NullPointerException(""state cannot be null"");\n        }\n        return new Predicate<Transition>() {\n\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return value.getTarget().equals(state);\n            }\n        };\n    }\n\n    /**\n     * @param state\n     *            the state to match\n     * @return a predicate which will return true for transitions whos source state matches the given state\n     */\n    public static Predicate<Transition> sourceStateEquals(final State state)\n    {\n        if (state == null)\n        {\n            throw new NullPointerException(""state cannot be null"");\n        }\n        return new Predicate<Transition>() {\n\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return value.getSource().equals(state);\n            }\n        };\n    }\n\n    /**\n     * @param the reason\n     * @return the registered listener\n     */\n    public static StateListener blockEntry(final State state, final Enum<?> reason)\n    {\n        final StateListener listener = filter(targetStateEquals(state), blockEntryListener(reason));\n        return listener;\n    }\n\n    /**\n     * @param the reason\n     * @return the registered listener\n     */\n    public static StateListener blockExit(final State state, final Enum<?> reason)\n    {\n        final StateListener listener = filter(sourceStateEquals(state), blockExitListener(reason));\n        return listener;\n    }\n\n    /**\n     * @param filter\n     *            the filter to apply to the given listener\n     * @param listener\n     *            the listener to wrap\n     * @return the wrapped listener\n     */\n    public static ConditionalStateListener filter(final Predicate<Transition> filter, final StateListener listener)\n    {\n        return new ConditionalStateListener(filter, listener);\n    }\n\n    /**\n     * @param listeners\n     *            the listeners to treat as a single group\n     * @return the grouped listener\n     */\n    public static GroupStateListener group(final StateListener... listeners)\n    {\n        return new GroupStateListener(listeners);\n    }\n\n    /**\n     * @param listeners\n     *            the listeners to treat as a single group\n     * @return the group listener which you can turn on and off\n     */\n    public static ConditionalStateListener group(final Predicate<Transition> predicate, final StateListener... listeners)\n    {\n        return filter(predicate, group(listeners));\n    }\n }')",[261136]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n *\n */\nabstract class AbstractTransition<SOURCE extends AbstractTestState, TARGET extends AbstractTestState> implements Transition\n{\n    private final SOURCE sourceState;\n    private final TARGET targetState;\n    \n    private Collection<TransitionListener> listeners;\n\n    AbstractTransition(final SOURCE from, final TARGET to)\n    {\n        if (from == null) \n        {\n            throw new NullPointerException(""source state cannot be null"");\n        }\n        if (to == null) \n        {\n            throw new NullPointerException(""target state cannot be null"");\n        }\n        if (from.getStateMachine() != to.getStateMachine())\n        {\n            throw new NullPointerException(""source and target states are for different state machines"");\n        }\n        this.sourceState = from;\n        this.targetState = to;\n        this.listeners = new CopyOnWriteArrayList<TransitionListener>();\n    }\n\n    public SOURCE getSource()\n    {\n        return this.sourceState;\n    }\n    \n    public TARGET getTarget()\n    {\n        return this.targetState;\n    }\n\n    /**\n     *  hook for subclasses\n     */\n    protected void executeInternal()\n    {\n    // no-op\n    }\n\n    /**\n     * Execute the transition, returning a collection of reasons why the transition could not execute should the transition fail.\n     * Should the transition succeed, an empty collection is returned.\n     * @return a collection of reasons why the transition could not execute should the transition fail\n     */\n    public final Collection<Enum<?>> execute()\n    {\n        if (getSource() != getStateMachine().getCurrentState())\n        {\n            StateLog.error(""Illegal transition \'%s\' called. Current state was expected to be \'%s\' but was \'%s\'"", getName(), getSource().getName(),\n                    getStateMachine().getCurrentStateName());\n            return Arrays.asList(new Enum<?>[] { Reasons.INVALID_SOURCE_STATE });\n        }\n\n        //\n        // process general listeners\n        //\n        final TransitionGuard generalBeforeResult = getStateMachine().onBeforeTransition(this);\n        if (generalBeforeResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop before transition. Reason=%s"", getName(), generalBeforeResult.getReason());\n            return generalBeforeResult.getReasons();\n        }\n\n        //\n        // process source handlers\n        //\n        final TransitionGuard specificBeforeResult = getSource().onExit(this);\n        if (specificBeforeResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop exiting the state. Reason=%s"", getName(), specificBeforeResult.getReason());\n            return specificBeforeResult.getReasons();\n        }\n\n        //\n        // perform any subclass processing\n        //\n        executeInternal();\n\n        //\n        // process specific target entrance handlers\n        //\n        final TransitionGuard specificAfterResult = getSource().onEnter(this);\n        if (specificAfterResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop entering state. Reason=%s"", getName(), specificAfterResult.getReason());\n            return specificAfterResult.getReasons();\n        }\n\n        //\n        // notify the direct transition listeners that the transition is taking place\n        //\n        final TransitionGuard transGuardResult = notifyListeners();\n        if (transGuardResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop by a transaction listener. Reason=%s"", getName(), transGuardResult.getReason());\n            return transGuardResult.getReasons();\n        }\n\n        //\n        // process general target entrance handlers\n        //\n        final TransitionGuard generalAfterResult = getStateMachine().onAfterTransition(this);\n        if (generalAfterResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop by a transaction listener. Reason=%s"", getName(), generalAfterResult.getReason());\n            return generalAfterResult.getReasons();\n        }\n\n        //\n        // success! Or is it? Anybody think we should stop?\n        //\n        final Collection<Enum<?>> reasons = TransitionGuard.filterReasons(generalBeforeResult,//\n                specificBeforeResult,//\n                specificAfterResult,//\n                transGuardResult,//\n                generalAfterResult);\n\n        if (reasons.isEmpty())\n        {\n            StateLog.debug(""transition \'%s\' proceeding to state \'%s\'"", getName(), getTarget().getName());\n            getStateMachine().setCurrentState(getTarget());\n        }\n        else\n        {\n            StateLog.debug(""transition \'%s\' returning without proceeding to \'%s\', staying in \'%s\' due to: %s"", getName(), getTarget()\n                    .getName(), getStateMachine().getCurrentState().getName(), reasons);\n        }\n\n        return reasons;\n    }\n\n    TestStateMachine getStateMachine()\n    {\n        return getSource().getStateMachine();\n    }\n    \n    private TransitionGuard notifyListeners()\n    {\n        TransitionGuard result = TransitionGuard.ok(); \n        for (final TransitionListener listener : this.listeners)\n        {\n            final TransitionGuard listenerResult = listener.onTransition(this);\n            if (listenerResult.stop())\n            {\n                return listenerResult;\n            }\n            else if (!listenerResult.continueProcessing())\n            {\n                result = listenerResult; \n            }\n        }\n        return result;\n    }\n    \n    /**\n     * @param listener the listener to add\n     * @return true if the listener was added successfully\n     */\n    @Override\n    public <T extends TransitionListener> T registerListener(final T listener)\n    {\n        if (listener == null)\n        {\n            return null;\n        }\n        final boolean success =  this.listeners.add(listener);\n        assert success;\n        return listener;\n    }\n\n    /**\n     * @param listener the listener to remove\n     * @reutrn true if the listener was removed successfully\n     */\n    @Override\n    public boolean unregisterListener(final TransitionListener listener)\n    {\n        if (listener == null)\n        {\n            return false;\n        }\n        return this.listeners.remove(listener);\n    }\n    \n    /**\n     * @return the string value for this transition\n     */\n    @Override\n    public String toString()\n    {\n        return String.format(""%s [%d]: %s --> %s"", getName(), Integer.valueOf(this.listeners.size()), getSource().getName(), getTarget()\n                .getName());\n    }\n}\n')",[285680]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\n/**\n * a listener which groups other listeners\n */\npublic class GroupStateListener implements StateListener \n{\n    private final StateNotifier notifier;\n\n    /**\n     */\n    public GroupStateListener(final StateListener ... listeners)\n    {\n        this.notifier = new StateNotifier();\n        for (final StateListener listener : listeners)\n        {\n            this.notifier.registerListener(listener);\n        }\n    }\n   \n    @Override\n    public TransitionGuard onExit(final Transition transition)\n    {\n        return this.notifier.onBeforeTransition(transition);\n    }\n\n    @Override\n    public TransitionGuard onEnter(final Transition transition)\n    {\n        return this.notifier.onAfterTransition(transition);\n    }\n\n    /**\n     * @return the string representation of this listener\n     */\n    @Override\n    public String toString()\n    {\n        return String.format(""group listener {%s}"", this.notifier);\n    }\n}\n')",[279929]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsPaymentReceived extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""Payment Received"";\n\n    private TransitionClaimsMarkPaymentAsComplete markPaymentAsComplete; \n    \n    /**\n     * @param fsm\n     */\n    ClaimsPaymentReceived(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        // Transition mark payment as complete\n        this.markPaymentAsComplete = new TransitionClaimsMarkPaymentAsComplete(this, getStateMachine().paymentComplete());\n        allTransitions.add(this.markPaymentAsComplete); \n\n        return allTransitions;    \n    }\n    \n    /**\n     * execute the mark payment as complete transition\n     * @return true if the transition was successful\n     */\n    public boolean markPaymentAsComplete() {\n        this.markPaymentAsComplete.execute();\n        return this.markPaymentAsComplete.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerMarkPaymentAsCompleteListener(final T listener)\n    {\n        return this.markPaymentAsComplete.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterMarkPaymentAsCompleteListener(final TransitionListener listener)\n    {\n        return this.markPaymentAsComplete.unregisterListener(listener);\n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[266657]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getStateForName(aaron.test.test.ClaimsReadyForPaymentTest)')","[1178, 1202, 1226, 7811, 7842, 7873, 11531, 11562, 11593, 23973, 23997, 24021, 29651, 35614, 35644, 35674, 36595, 36623, 36651, 49280, 49315, 49350, 53480, 53515, 53550, 67634, 67662, 67690, 77892, 77920, 77948, 78807, 78833, 78859, 90702, 90735, 90768, 94662, 94695, 94728, 107960, 107986, 108012, 118311, 118343, 118375, 119358, 119388, 119418, 132833, 132870, 132907, 137273, 137310, 137347, 152283, 152313, 152343, 164098, 164133, 164168, 165244, 165277, 165310, 179904, 179944, 179984, 184704, 184744, 184784, 200998, 201031, 201064, 213578, 213615, 213652, 214790, 214825, 214860, 230240, 230282, 230324, 235280, 235322, 235364, 293473, 293513, 293553, 294757, 294799, 294841]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test.test;\nimport aaron.test.*;\nimport org.junit.*;\n\n/**\n * tests for ClaimsStateMachine\n */\n@Ignore(""base class"")\nabstract class AbstractClaimsTest \n{\n    /**\n     *\n     */\n    protected ClaimsStateMachine newStateMachine()\n    {\n        final ClaimsStateMachine fsm = ClaimsStateMachine.createAndStart(); \n        Assert.assertNotNull(fsm);\n        return fsm;\n    }\n}\n')",[269512]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_cannotAddTwoStatesWithTheSameName(com.porpoise.fsm.model.StateMachineTest)')","[2479, 2510, 2541, 3595, 3626, 3657, 21573, 21597, 21621, 31518, 31548, 31578, 43260, 43295, 43330, 44520, 44555, 44590, 64834, 64862, 64890, 74076, 74104, 74132, 85026, 85059, 85092, 86214, 86247, 86280, 105360, 105386, 105412, 113935, 113967, 113999, 126469, 126506, 126543, 127801, 127838, 127875, 149283, 149313, 149343, 159302, 159337, 159372, 173024, 173064, 173104, 174464, 174504, 174544, 197698, 197731, 197764, 208502, 208539, 208576, 223016, 223058, 223100, 224528, 224570, 224612, 249188, 249228, 249268, 250176, 250218, 250260]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\n/**\n * a listener callback used to respond to state changes.\n */\npublic interface StateListener\n{\n    /**\n     *\n     */\n    TransitionGuard onExit(final Transition transition);\n    \n    /**\n     *\n     */\n    TransitionGuard onEnter(final Transition transition);\n}\n')",[279972]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsStartState\n */\npublic class ClaimsStartStateTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the \'ClaimsStartState\' state\n     */\n    @Test\n    public void test_executeToClaimsStartState()\n    {\n        Assert.assertNotNull(moveToClaimsStartState());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for \'startState\' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.startState().getName();\n        Assert.assertEquals(fsm.startState(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the startState state\n     */\n    final ClaimsStartState moveToClaimsStartState()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsStartState startState = fsm.startState();\n\n        // call the method under test\n        fsm.executeToState(startState);\n\n        Assert.assertSame(startState, fsm.getCurrentState());\n        Assert.assertEquals(startState.getName(), fsm.getCurrentStateName());\n        \n        return startState;\n    }\n\n    \n    @Test\n    public void test_getPathBetweenClaimsStartStateAndClaimsNotReceived()\n    {\n\n        final ClaimsStartState startState = moveToClaimsStartState();\n        final ClaimsStateMachine fsm = startState.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'startState\'"", startState, fsm.getCurrentState());\n\n        final TransitionPaths paths = startState.getPaths(fsm.notReceived());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        startState.registerInitListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'startState\'"", startState, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.notReceived(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'init\' transition \n     */\n    @Test\n    public void test_init()\n    {\n        final ClaimsStartState startState = moveToClaimsStartState();\n        final ClaimsStateMachine fsm = startState.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        startState.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        startState.init();\n\n        //\n        // assert the current state is now ClaimsNotReceived\n        //\n        Assert.assertEquals(fsm.notReceived(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.notReceived().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsInit.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsInit.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(startState.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsStartState\' can be moved into the ClaimsNotReceived state\n     */\n    @Test\n    public void test_moveToClaimsNotReceived()\n    {\n        final ClaimsStartState startState = moveToClaimsStartState();\n        final ClaimsStateMachine fsm = startState.getStateMachine();\n        startState.getPaths(fsm.notReceived());\n        \n    }\n}\n')",[274672]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\n\n/**\n * A collection of useful implementations of TransitionListener\n */\npublic enum TransitionListeners \n{\n    ;//uninstantiable\n\n    /**\n     * a listener which records the transitions\n     */\n    public static class RecordingTransitionListener implements TransitionListener\n    {\n        private final List<Transition> transitions = new ArrayList<Transition>();\n\n        @Override\n        public TransitionGuard onTransition(final Transition transition)\n        {\n            this.transitions.add(transition);\n            return TransitionGuard.ok();\n        }\n\n        /**\n         * @return the enter transitions\n         */\n        public List<Transition> getTransitions()\n        {\n            return Collections.unmodifiableList(this.transitions);\n        }\n    }\n    \n    private static class BlockingListener implements TransitionListener\n    {\n        private final Enum<?> reason;\n        public BlockingListener(final Enum<?> reasonValue)\n        {\n            this.reason = reasonValue;\n        }\n    \n        @Override\n        public TransitionGuard onTransition(final Transition transition)\n        {\n            return TransitionGuard.stopEventually(this.reason);\n        }\n    }\n    \n    private static TransitionListener BLOCKING_INSTANCE = new BlockingListener(null); \n\n    /**\n     * @return a new recording transition listener\n     */\n    public static RecordingTransitionListener recordingListener()\n    {\n        return new RecordingTransitionListener();\n    }\n    /**\n     * @return a listener which returns @{code TransitionGuard.stopEventually()}\n     */\n    public static TransitionListener blockingListener()\n    {\n        return BLOCKING_INSTANCE;\n    }\n    /**\n     * @return a listener which returns @{code TransitionGuard.stopEventually()}\n     */\n    public static TransitionListener blockingListener(final Enum<?> reason)\n    {\n        return new BlockingListener(reason);\n    }\n    \n    /**\n     * @return a listener which disallows transitions when the given condition returns false\n     */\n    public static TransitionListener blockOnFalse(final Predicate<Transition> condition, final Enum<?> reason)\n    {\n        final TransitionListener delegate = TransitionListeners.blockingListener(reason);\n        final TransitionListener listener = filter(condition, delegate);\n        return listener;\n    }\n\n    /**\n     * @param condition\n     *            the condition (predicate) used to evaluate whether or not the given listener should be invoked\n     * @param delegate\n     *            the listener to invoke when the condition returns true\n     * @return the conditional listener which wraps the given listener\n     */\n    public static ConditionalTransitionListener filter(final Predicate<Transition> condition, final TransitionListener delegate)\n    {\n        final ConditionalTransitionListener listener = new ConditionalTransitionListener(condition, delegate);\n        return listener;\n    }    \n    /**\n     * @return a listener which disallows transitions when the given condition returns true\n     */\n    public static TransitionListener blockOnTrue(final Predicate<Transition> condition, final Enum<?> reason)\n    {\n        return blockOnFalse(Predicates.not(condition), reason);\n    }\n\n }')",[255386]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_markPaymentAsReceived(aaron.test.test.ClaimsReadyForPaymentTest)')","[8400, 12120, 24429, 29756, 36184, 49945, 54145, 68166, 78424, 91329, 95289, 108454, 118919, 133536, 137976, 152853, 164763, 180664, 185464, 201625, 214281, 231038, 236078, 294233, 295555]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsReceivedByDeliveryTeamAndClaimsReceivedByMonitoringOfficer(aaron.test.test.ClaimsReceivedByDeliveryTeamTest)')","[15344, 17948, 26925, 30362, 39715, 57785, 60725, 71078, 81717, 98721, 101493, 111158, 122688, 141824, 144932, 155973, 168889, 189624, 192984, 205057, 218645, 240446, 243974, 303211, 304525]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_resubmitForPayment(aaron.test.test.ClaimsPaymentRejectedTest)')","[20428, 28749, 30841, 42543, 63525, 73206, 84353, 104133, 113134, 125708, 147892, 158253, 172197, 196184, 207565, 222145, 247334, 309819, 310653]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\nimport com.google.common.base.Predicate;\n\n/**\n * a listener which can be turned on and off by the given predicate\n */\npublic class ConditionalStateListener extends AbstractConditionalStateListener \n{\n    private final StateListener wrappedListener;\n\n    /**\n     * @param predicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener will be executed.\n     * @param listener\n     */\n    public ConditionalStateListener(final Predicate<Transition> predicate, final StateListener listener)\n    {\n        this(predicate, predicate, listener);\n    }\n\n    /**\n     * @param enterPredicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener\'s onEnter will be executed.\n     * @param exitPredicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener\'s onExit method will be executed.\n     * @param predicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener will be executed.\n     * @param listener\n     */\n    public ConditionalStateListener(final Predicate<Transition> enterPredicate, final Predicate<Transition> exitPredicate, final StateListener listener)\n    {\n        this(enterPredicate, exitPredicate, listener, TransitionGuard.ok(), TransitionGuard.ok());\n    }\n\n    /**\n     * @param enterPredicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener\'s onEnter will be executed.\n     * @param exitPredicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener\'s onExit method will be executed.\n     * @param predicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener will be executed.\n     * @param listener\n     * @param enterDefault the transition to return should the enter predicate filter return false\n     * @param exitDefault the transition to return should the exit predicate filter return false\n     */\n    public ConditionalStateListener(final Predicate<Transition> enterPredicate, final Predicate<Transition> exitPredicate, final StateListener listener, final TransitionGuard enterDefault, final TransitionGuard exitDefault)\n    {\n        super(enterPredicate, exitPredicate, exitDefault, exitDefault);\n        if (listener == null)\n        {\n            throw new NullPointerException(""listener cannot be null"");\n        }\n        this.wrappedListener = listener;\n    }\n   \n    /**\n     * @param transition\n     * @return the transition return value.  \n     */\n    @Override\n    protected TransitionGuard onExitInternal(final Transition transition)\n    {\n        return this.wrappedListener.onExit(transition);\n    }\n\n    /**\n     * @param transition\n     * @return the transition return value.  \n     */\n    @Override\n    protected TransitionGuard onEnterInternal(final Transition transition)\n    {\n        return this.wrappedListener.onEnter(transition);\n    }\n}\n')",[279538]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_submitToMonitoringOfficer(aaron.test.test.ClaimsNotReceivedTest)')","[6571, 6602, 6633, 9175, 9206, 9237, 23205, 23229, 23253, 34517, 34547, 34577, 47880, 47915, 47950, 50820, 50855, 50890, 66738, 66766, 66794, 76869, 76897, 76925, 89382, 89415, 89448, 92154, 92187, 92220, 107128, 107154, 107180, 117140, 117172, 117204, 131353, 131390, 131427, 134461, 134498, 134535, 151323, 151353, 151383, 162816, 162851, 162886, 178304, 178344, 178384, 181664, 181704, 181744, 199942, 199975, 200008, 212222, 212259, 212296, 228560, 228602, 228644, 232088, 232130, 232172, 290251, 290291, 290331, 292039, 292081, 292123]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsResubmitForPayment extends AbstractTransition<ClaimsPaymentRejected, ClaimsReadyForPayment>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""resubmit for payment"";\n\n    TransitionClaimsResubmitForPayment(final ClaimsPaymentRejected from, final ClaimsReadyForPayment to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[263710]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsReadyForPayment\n */\npublic class ClaimsReadyForPaymentTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the \'ClaimsReadyForPayment\' state\n     */\n    @Test\n    public void test_executeToClaimsReadyForPayment()\n    {\n        Assert.assertNotNull(moveToClaimsReadyForPayment());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for \'readyForPayment\' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.readyForPayment().getName();\n        Assert.assertEquals(fsm.readyForPayment(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the readyForPayment state\n     */\n    final ClaimsReadyForPayment moveToClaimsReadyForPayment()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsReadyForPayment readyForPayment = fsm.readyForPayment();\n\n        // call the method under test\n        fsm.executeToState(readyForPayment);\n\n        Assert.assertSame(readyForPayment, fsm.getCurrentState());\n        Assert.assertEquals(readyForPayment.getName(), fsm.getCurrentStateName());\n        \n        return readyForPayment;\n    }\n\n    \n    @Test\n    public void test_getPathBetweenClaimsReadyForPaymentAndClaimsPaymentRejected()\n    {\n\n        final ClaimsReadyForPayment readyForPayment = moveToClaimsReadyForPayment();\n        final ClaimsStateMachine fsm = readyForPayment.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'readyForPayment\'"", readyForPayment, fsm.getCurrentState());\n\n        final TransitionPaths paths = readyForPayment.getPaths(fsm.paymentRejected());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        readyForPayment.registerRejectPaymentListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'readyForPayment\'"", readyForPayment, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.paymentRejected(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'rejectPayment\' transition \n     */\n    @Test\n    public void test_rejectPayment()\n    {\n        final ClaimsReadyForPayment readyForPayment = moveToClaimsReadyForPayment();\n        final ClaimsStateMachine fsm = readyForPayment.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        readyForPayment.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        readyForPayment.rejectPayment();\n\n        //\n        // assert the current state is now ClaimsPaymentRejected\n        //\n        Assert.assertEquals(fsm.paymentRejected(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.paymentRejected().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsRejectPayment.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsRejectPayment.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(readyForPayment.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReadyForPayment\' can be moved into the ClaimsPaymentRejected state\n     */\n    @Test\n    public void test_moveToClaimsPaymentRejected()\n    {\n        final ClaimsReadyForPayment readyForPayment = moveToClaimsReadyForPayment();\n        final ClaimsStateMachine fsm = readyForPayment.getStateMachine();\n        readyForPayment.getPaths(fsm.paymentRejected());\n        \n    }\n    \n    @Test\n    public void test_getPathBetweenClaimsReadyForPaymentAndClaimsPaymentReceived()\n    {\n\n        final ClaimsReadyForPayment readyForPayment = moveToClaimsReadyForPayment();\n        final ClaimsStateMachine fsm = readyForPayment.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'readyForPayment\'"", readyForPayment, fsm.getCurrentState());\n\n        final TransitionPaths paths = readyForPayment.getPaths(fsm.paymentReceived());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        readyForPayment.registerMarkPaymentAsReceivedListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'readyForPayment\'"", readyForPayment, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.paymentReceived(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'markPaymentAsReceived\' transition \n     */\n    @Test\n    public void test_markPaymentAsReceived()\n    {\n        final ClaimsReadyForPayment readyForPayment = moveToClaimsReadyForPayment();\n        final ClaimsStateMachine fsm = readyForPayment.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        readyForPayment.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        readyForPayment.markPaymentAsReceived();\n\n        //\n        // assert the current state is now ClaimsPaymentReceived\n        //\n        Assert.assertEquals(fsm.paymentReceived(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.paymentReceived().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsMarkPaymentAsReceived.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsMarkPaymentAsReceived.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(readyForPayment.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReadyForPayment\' can be moved into the ClaimsPaymentReceived state\n     */\n    @Test\n    public void test_moveToClaimsPaymentReceived()\n    {\n        final ClaimsReadyForPayment readyForPayment = moveToClaimsReadyForPayment();\n        final ClaimsStateMachine fsm = readyForPayment.getStateMachine();\n        readyForPayment.getPaths(fsm.paymentReceived());\n        \n    }\n}\n')",[270372]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_executeToClaimsReadyForPayment(aaron.test.test.ClaimsReadyForPaymentTest)')","[8679, 8710, 8741, 12399, 12430, 12461, 24645, 24669, 24693, 36454, 36484, 36514, 50260, 50295, 50330, 54460, 54495, 54530, 68418, 68446, 68474, 78676, 78704, 78732, 91626, 91659, 91692, 95586, 95619, 95652, 108688, 108714, 108740, 119207, 119239, 119271, 133869, 133906, 133943, 138309, 138346, 138383, 153123, 153153, 153183, 165078, 165113, 165148, 181024, 181064, 181104, 185824, 185864, 185904, 201922, 201955, 201988, 214614, 214651, 214688, 231416, 231458, 231500, 236456, 236498, 236540, 294593, 294633, 294673, 295933, 295975, 296017]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'aaron.test.test.ClaimsStateMachineTest')","[309069, 309092, 309116, 309139]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsPaymentReceivedAndClaimsPaymentComplete(aaron.test.test.ClaimsPaymentReceivedTest)')","[19436, 20800, 28077, 30674, 41566, 62405, 63945, 72422, 83442, 103077, 104529, 112406, 124665, 146708, 148336, 157413, 171055, 194904, 196664, 206641, 220937, 245990, 247838, 307765, 308583]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsPaymentReceived extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""Payment Received"";\n\n    private TransitionClaimsMarkPaymentAsComplete markPaymentAsComplete; \n    \n    /**\n     * @param fsm\n     */\n    ClaimsPaymentReceived(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        // Transition mark payment as complete\n        this.markPaymentAsComplete = new TransitionClaimsMarkPaymentAsComplete(this, getStateMachine().paymentComplete());\n        allTransitions.add(this.markPaymentAsComplete); \n\n        return allTransitions;    \n    }\n    \n    /**\n     * execute the mark payment as complete transition\n     * @return true if the transition was successful\n     */\n    public boolean markPaymentAsComplete() {\n        this.markPaymentAsComplete.execute();\n        return this.markPaymentAsComplete.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerMarkPaymentAsCompleteListener(final T listener)\n    {\n        return this.markPaymentAsComplete.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterMarkPaymentAsCompleteListener(final TransitionListener listener)\n    {\n        return this.markPaymentAsComplete.unregisterListener(listener);\n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[266550]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_moveToClaimsNotReceived(aaron.test.test.ClaimsStartStateTest)')","[16956, 18692, 27405, 30487, 40452, 59605, 61565, 71638, 82404, 100437, 102285, 111678, 123475, 143748, 145820, 156573, 169751, 191704, 193944, 205717, 219557, 242630, 244982, 305449, 306259]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n *\n */\nabstract class AbstractTransition<SOURCE extends AbstractClaimsState, TARGET extends AbstractClaimsState> implements Transition\n{\n    private final SOURCE sourceState;\n    private final TARGET targetState;\n    \n    private Collection<TransitionListener> listeners;\n\n    AbstractTransition(final SOURCE from, final TARGET to)\n    {\n        if (from == null) \n        {\n            throw new NullPointerException(""source state cannot be null"");\n        }\n        if (to == null) \n        {\n            throw new NullPointerException(""target state cannot be null"");\n        }\n        if (from.getStateMachine() != to.getStateMachine())\n        {\n            throw new NullPointerException(""source and target states are for different state machines"");\n        }\n        this.sourceState = from;\n        this.targetState = to;\n        this.listeners = new CopyOnWriteArrayList<TransitionListener>();\n    }\n\n    public SOURCE getSource()\n    {\n        return this.sourceState;\n    }\n    \n    public TARGET getTarget()\n    {\n        return this.targetState;\n    }\n\n    /**\n     *  hook for subclasses\n     */\n    protected void executeInternal()\n    {\n    // no-op\n    }\n\n    /**\n     * Execute the transition, returning a collection of reasons why the transition could not execute should the transition fail.\n     * Should the transition succeed, an empty collection is returned.\n     * @return a collection of reasons why the transition could not execute should the transition fail\n     */\n    public final Collection<Enum<?>> execute()\n    {\n        if (getSource() != getStateMachine().getCurrentState())\n        {\n            StateLog.error(""Illegal transition \'%s\' called. Current state was expected to be \'%s\' but was \'%s\'"", getName(), getSource().getName(),\n                    getStateMachine().getCurrentStateName());\n            return Arrays.asList(new Enum<?>[] { Reasons.INVALID_SOURCE_STATE });\n        }\n\n        //\n        // process general listeners\n        //\n        final TransitionGuard generalBeforeResult = getStateMachine().onBeforeTransition(this);\n        if (generalBeforeResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop before transition. Reason=%s"", getName(), generalBeforeResult.getReason());\n            return generalBeforeResult.getReasons();\n        }\n\n        //\n        // process source handlers\n        //\n        final TransitionGuard specificBeforeResult = getSource().onExit(this);\n        if (specificBeforeResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop exiting the state. Reason=%s"", getName(), specificBeforeResult.getReason());\n            return specificBeforeResult.getReasons();\n        }\n\n        //\n        // perform any subclass processing\n        //\n        executeInternal();\n\n        //\n        // process specific target entrance handlers\n        //\n        final TransitionGuard specificAfterResult = getSource().onEnter(this);\n        if (specificAfterResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop entering state. Reason=%s"", getName(), specificAfterResult.getReason());\n            return specificAfterResult.getReasons();\n        }\n\n        //\n        // notify the direct transition listeners that the transition is taking place\n        //\n        final TransitionGuard transGuardResult = notifyListeners();\n        if (transGuardResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop by a transaction listener. Reason=%s"", getName(), transGuardResult.getReason());\n            return transGuardResult.getReasons();\n        }\n\n        //\n        // process general target entrance handlers\n        //\n        final TransitionGuard generalAfterResult = getStateMachine().onAfterTransition(this);\n        if (generalAfterResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop by a transaction listener. Reason=%s"", getName(), generalAfterResult.getReason());\n            return generalAfterResult.getReasons();\n        }\n\n        //\n        // success! Or is it? Anybody think we should stop?\n        //\n        final Collection<Enum<?>> reasons = TransitionGuard.filterReasons(generalBeforeResult,//\n                specificBeforeResult,//\n                specificAfterResult,//\n                transGuardResult,//\n                generalAfterResult);\n\n        if (reasons.isEmpty())\n        {\n            StateLog.debug(""transition \'%s\' proceeding to state \'%s\'"", getName(), getTarget().getName());\n            getStateMachine().setCurrentState(getTarget());\n        }\n        else\n        {\n            StateLog.debug(""transition \'%s\' returning without proceeding to \'%s\', staying in \'%s\' due to: %s"", getName(), getTarget()\n                    .getName(), getStateMachine().getCurrentState().getName(), reasons);\n        }\n\n        return reasons;\n    }\n\n    ClaimsStateMachine getStateMachine()\n    {\n        return getSource().getStateMachine();\n    }\n    \n    private TransitionGuard notifyListeners()\n    {\n        TransitionGuard result = TransitionGuard.ok(); \n        for (final TransitionListener listener : this.listeners)\n        {\n            final TransitionGuard listenerResult = listener.onTransition(this);\n            if (listenerResult.stop())\n            {\n                return listenerResult;\n            }\n            else if (!listenerResult.continueProcessing())\n            {\n                result = listenerResult; \n            }\n        }\n        return result;\n    }\n    \n    /**\n     * @param listener the listener to add\n     * @return true if the listener was added successfully\n     */\n    @Override\n    public <T extends TransitionListener> T registerListener(final T listener)\n    {\n        if (listener == null)\n        {\n            return null;\n        }\n        final boolean success =  this.listeners.add(listener);\n        assert success;\n        return listener;\n    }\n\n    /**\n     * @param listener the listener to remove\n     * @reutrn true if the listener was removed successfully\n     */\n    @Override\n    public boolean unregisterListener(final TransitionListener listener)\n    {\n        if (listener == null)\n        {\n            return false;\n        }\n        return this.listeners.remove(listener);\n    }\n    \n    /**\n     * @return the string value for this transition\n     */\n    @Override\n    public String toString()\n    {\n        return String.format(""%s [%d]: %s --> %s"", getName(), Integer.valueOf(this.listeners.size()), getSource().getName(), getTarget()\n                .getName());\n    }\n}\n')",[262379]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsNotReceived\n */\npublic class ClaimsNotReceivedTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the \'ClaimsNotReceived\' state\n     */\n    @Test\n    public void test_executeToClaimsNotReceived()\n    {\n        Assert.assertNotNull(moveToClaimsNotReceived());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for \'notReceived\' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.notReceived().getName();\n        Assert.assertEquals(fsm.notReceived(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the notReceived state\n     */\n    final ClaimsNotReceived moveToClaimsNotReceived()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsNotReceived notReceived = fsm.notReceived();\n\n        // call the method under test\n        fsm.executeToState(notReceived);\n\n        Assert.assertSame(notReceived, fsm.getCurrentState());\n        Assert.assertEquals(notReceived.getName(), fsm.getCurrentStateName());\n        \n        return notReceived;\n    }\n\n    \n    @Test\n    public void test_getPathBetweenClaimsNotReceivedAndClaimsReceivedByMonitoringOfficer()\n    {\n\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'notReceived\'"", notReceived, fsm.getCurrentState());\n\n        final TransitionPaths paths = notReceived.getPaths(fsm.receivedByMonitoringOfficer());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        notReceived.registerSubmitToMonitoringOfficerListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'notReceived\'"", notReceived, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.receivedByMonitoringOfficer(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'submitToMonitoringOfficer\' transition \n     */\n    @Test\n    public void test_submitToMonitoringOfficer()\n    {\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        notReceived.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        notReceived.submitToMonitoringOfficer();\n\n        //\n        // assert the current state is now ClaimsReceivedByMonitoringOfficer\n        //\n        Assert.assertEquals(fsm.receivedByMonitoringOfficer(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.receivedByMonitoringOfficer().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsSubmitToMonitoringOfficer.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsSubmitToMonitoringOfficer.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(notReceived.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsNotReceived\' can be moved into the ClaimsReceivedByMonitoringOfficer state\n     */\n    @Test\n    public void test_moveToClaimsReceivedByMonitoringOfficer()\n    {\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n        notReceived.getPaths(fsm.receivedByMonitoringOfficer());\n        \n    }\n    \n    @Test\n    public void test_getPathBetweenClaimsNotReceivedAndClaimsReceivedByDeliveryTeam()\n    {\n\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'notReceived\'"", notReceived, fsm.getCurrentState());\n\n        final TransitionPaths paths = notReceived.getPaths(fsm.receivedByDeliveryTeam());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        notReceived.registerSubmitToDeliveryTeamListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'notReceived\'"", notReceived, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.receivedByDeliveryTeam(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'submitToDeliveryTeam\' transition \n     */\n    @Test\n    public void test_submitToDeliveryTeam()\n    {\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        notReceived.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        notReceived.submitToDeliveryTeam();\n\n        //\n        // assert the current state is now ClaimsReceivedByDeliveryTeam\n        //\n        Assert.assertEquals(fsm.receivedByDeliveryTeam(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.receivedByDeliveryTeam().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsSubmitToDeliveryTeam.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsSubmitToDeliveryTeam.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(notReceived.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsNotReceived\' can be moved into the ClaimsReceivedByDeliveryTeam state\n     */\n    @Test\n    public void test_moveToClaimsReceivedByDeliveryTeam()\n    {\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n        notReceived.getPaths(fsm.receivedByDeliveryTeam());\n        \n    }\n    \n    @Test\n    public void test_getPathBetweenClaimsNotReceivedAndClaimsReceivedByHeadOfDelivery()\n    {\n\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'notReceived\'"", notReceived, fsm.getCurrentState());\n\n        final TransitionPaths paths = notReceived.getPaths(fsm.receivedByHeadOfDelivery());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        notReceived.registerSubmitToHeadOfDeliveryListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'notReceived\'"", notReceived, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'submitToHeadOfDelivery\' transition \n     */\n    @Test\n    public void test_submitToHeadOfDelivery()\n    {\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        notReceived.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        notReceived.submitToHeadOfDelivery();\n\n        //\n        // assert the current state is now ClaimsReceivedByHeadOfDelivery\n        //\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsSubmitToHeadOfDelivery.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsSubmitToHeadOfDelivery.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(notReceived.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsNotReceived\' can be moved into the ClaimsReceivedByHeadOfDelivery state\n     */\n    @Test\n    public void test_moveToClaimsReceivedByHeadOfDelivery()\n    {\n        final ClaimsNotReceived notReceived = moveToClaimsNotReceived();\n        final ClaimsStateMachine fsm = notReceived.getStateMachine();\n        notReceived.getPaths(fsm.receivedByHeadOfDelivery());\n        \n    }\n}\n')",[272132]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'com.porpoise.fsm.model.TransitionTest')","[252448, 252471, 252495, 252518]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * A PathEntry represents a link in the chain of a \'path\' from one state to another.\n * Each link in a path denotes a new target state and the transition used to get there. \n */\nfinal class PathEntry\n{\n    private final State      state;\n    private final Transition viaTransition;\n\n    PathEntry(final State stateValue, final Transition transitionValue)\n    {\n        this.state = stateValue;\n        this.viaTransition = transitionValue;\n    }\n\n    PathEntry(final State startState)\n    {\n        this(startState, null);\n    }\n\n    /**\n     * @return the state from this transition\n     */\n    public State getState()\n    {\n        return this.state;\n    }\n\n    /**\n     * @return the transition used to arrive at the next state\n     */\n    public Transition getTransition()\n    {\n        return this.viaTransition;\n    }\n\n    /**\n     * execute the given path. Return true if all transitions executed successfully\n     * \n     * @return a non-null collection of reasons should the transition fail\n     */\n    final Collection<Enum<?>> execute()\n    {\n        if (getTransition() != null)\n        {\n            return getTransition().execute();\n        }\n        return Collections.emptyList();\n    }\n\n    @Override\n    public int hashCode()\n    {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((this.state == null) ? 0 : this.state.hashCode());\n        result = prime * result + ((this.viaTransition == null) ? 0 : this.viaTransition.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(final Object obj)\n    {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        final PathEntry other = (PathEntry) obj;\n        if (this.state == null)\n        {\n            if (other.state != null)\n                return false;\n        }\n        else if (!this.state.equals(other.state))\n            return false;\n        if (this.viaTransition == null)\n        {\n            if (other.viaTransition != null)\n                return false;\n        }\n        else if (!this.viaTransition.equals(other.viaTransition))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString()\n    {\n        if (this.viaTransition == null)\n            return this.state.getName();\n        return String.format(""--[%s]-->%s"", this.viaTransition.getName(), this.state.getName());\n    }\n}')",[259389]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'aaron.test.test.ClaimsReceivedByHeadOfDeliveryTest')","[305179, 305202, 305226, 305249]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * <p>\n * A TransitionPathResult represents the result of trying to execute a {@link TransitionPath}.\n * You can query the result, asking if it was successful or not. In the case where it was not\n * successful, you can retrieve a collection of \'reason\' enumerations, which indicate why the\n * path was not successful. The reasons given will be those from the exit/enter state guards or \n * transition guards. \n * </p>\n * See {@link TransitionPath#execute()}.\n */\npublic final class TransitionPathResult\n{\n    private Collection<Enum<?>> reasons;\n    private PathEntry failedEntry;\n    \n    private TransitionPathResult(final PathEntry failedEntryValue, final Collection<Enum<?>> reasonValues)\n    {\n        this.reasons = reasonValues;\n        this.failedEntry = failedEntryValue;\n    }\n    \n    /**\n     * @return the failure reasons\n     */\n    public Collection<Enum<?>> getFailureReasons()\n    {\n        return Collections.unmodifiableCollection(this.reasons);\n    }\n    \n    /**\n     * @return the failed path entry\n     */\n    public PathEntry getFailedEntry()\n    {\n        return this.failedEntry;\n    }\n    \n    /**\n     * @return true if the transition was successful\n     */\n    public boolean isSuccess()\n    {\n        return this.reasons.isEmpty();\n    }\n    \n    /**\n     * @return true if the transition failed\n     */\n    public boolean isFail()\n    {\n        return !isSuccess();\n    }\n    \n    /**\n     * factory method for success results\n     * @return a new success result\n     */\n    static TransitionPathResult success()\n    {\n        final Collection<Enum<?>> r = Collections.emptyList();\n        return new TransitionPathResult(null, r);\n    }\n\n    /**\n     * factory method for failure results\n     * @return a new failure result\n     */\n    static TransitionPathResult fail(final PathEntry failedEntryValue, final Collection<Enum<?>> reasonValues)\n    {\n        return new TransitionPathResult(failedEntryValue, reasonValues);\n    }\n\n    /**\n     * factory method for failure results\n     * @return a new failure result\n     */\n    static TransitionPathResult fail(final Enum<?> ... reasonValues)\n    {\n        final Collection<Enum<?>> r = new ArrayList<Enum<?>>();\n        if (reasonValues == null || reasonValues.length == 0)\n        {\n            r.add(TransitionGuard.Reasons.NO_REASON_GIVEN);\n        }\n        else\n        {\n            r.addAll(Arrays.asList(reasonValues));\n        }\n        return new TransitionPathResult(null, r);\n    }\n    \n    /** \n     * @return the string representation\n     */\n    @Override\n    public String toString()\n    {\n        if(isSuccess())\n        {\n            return ""SUCCESS"";\n        }\n        return String.format(""FAIL: entry=%s reasons=%s"", this.failedEntry, this.reasons);\n    }\n}\n')",[283327]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_markPaymentAsComplete(aaron.test.test.ClaimsPaymentReceivedTest)')","[19560, 20924, 28173, 30695, 41686, 62545, 64085, 72534, 83554, 103209, 104661, 112510, 124793, 146856, 148484, 157533, 171195, 195064, 196824, 206773, 221085, 246158, 248006, 307925, 308751]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_moveToClaimsReceivedByDeliveryTeam(aaron.test.test.ClaimsNotReceivedTest)')","[7036, 9640, 23565, 29547, 34967, 48405, 51345, 67158, 77289, 89877, 92649, 107518, 117620, 131908, 135016, 151773, 163341, 178904, 182264, 200437, 212777, 229190, 232718, 290851, 292669]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\n/**\n * tests for TestStateMachine\n */\npublic class ListenerAdapter implements StateListener \n{\n    private TransitionGuard entranceGuard;\n    private TransitionGuard exitGuard;\n\n    /**\n     * Default Constructor\n     */\n    public ListenerAdapter()\n    {\n        this(TransitionGuard.ok(), TransitionGuard.ok());\n    }\n\n    /**\n     * @param entrance the entrance guard\n     * @param exit the exit guard\n     */\n    public ListenerAdapter(final TransitionGuard entrance, final TransitionGuard exit)\n    {\n        if (entrance == null)\n        {\n            throw new NullPointerException(""entrance guard type cannot be null"");\n        }\n        if (exit == null)\n        {\n            throw new NullPointerException(""exit guard type cannot be null"");\n        }\n        this.entranceGuard = entrance;\n        this.exitGuard = exit;\n    }\n\n    /**\n     * @param transition\n     * @return \'continue\'\n     */\n    public TransitionGuard onExit(final Transition transition)\n    {\n        return this.exitGuard;\n    }\n\n    /**\n     * @param transition\n     * @return \'continue\'\n     */\n    public TransitionGuard onEnter(final Transition transition)\n    {\n        return this.entranceGuard;\n    }\n}\n')",[283679]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'aaron.test.test.ClaimsPaymentReceivedTest')","[1832, 41921, 83773, 125044, 171470, 221376]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p.test;\n\nimport p.*;\n\nimport org.junit.*;\n\n/**\n * tests for TestStateMachine\n */\npublic class TestStateMachineTest \n{\n    /**\n     *\n     */\n    @Test\n    public void test_generalListeners()\n    {\n        final TestStateMachine fsm = TestStateMachine.create(); \n        Assert.assertNotNull(fsm);\n    }\n\n}\n')",[286991]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsStartState extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""start-state"";\n\n    private TransitionClaimsInit init; \n    \n    /**\n     * @param fsm\n     */\n    ClaimsStartState(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        // Transition init\n        this.init = new TransitionClaimsInit(this, getStateMachine().notReceived());\n        allTransitions.add(this.init); \n\n        return allTransitions;    \n    }\n    \n    /**\n     * execute the init transition\n     * @return true if the transition was successful\n     */\n    public boolean init() {\n        this.init.execute();\n        return this.init.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerInitListener(final T listener)\n    {\n        return this.init.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterInitListener(final TransitionListener listener)\n    {\n        return this.init.unregisterListener(listener);\n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[267883]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsReadyForPaymentAndClaimsPaymentReceived(aaron.test.test.ClaimsReadyForPaymentTest)')","[8276, 11996, 24333, 29735, 36064, 49805, 54005, 68054, 78312, 91197, 95157, 108350, 118791, 133388, 137828, 152733, 164623, 180504, 185304, 201493, 214133, 230870, 235910, 294073, 295387]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getStateForName(aaron.test.test.ClaimsPaymentRejectedTest)')","[1973, 19932, 28365, 30737, 42063, 42686, 62965, 72758, 83905, 84486, 103605, 112718, 125196, 125861, 147300, 157773, 171637, 172365, 195544, 207037, 221553, 222323, 246662, 309179, 309981]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsMarkAsReadyForPayment extends AbstractTransition<ClaimsReceivedByHeadOfDelivery, ClaimsReadyForPayment>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""mark as ready for payment"";\n\n    TransitionClaimsMarkAsReadyForPayment(final ClaimsReceivedByHeadOfDelivery from, final ClaimsReadyForPayment to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[265316]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_moveToClaimsReceivedByDeliveryTeam(aaron.test.test.ClaimsNotReceivedTest)')","[7067, 7098, 7129, 9671, 9702, 9733, 23589, 23613, 23637, 34997, 35027, 35057, 48440, 48475, 48510, 51380, 51415, 51450, 67186, 67214, 67242, 77317, 77345, 77373, 89910, 89943, 89976, 92682, 92715, 92748, 107544, 107570, 107596, 117652, 117684, 117716, 131945, 131982, 132019, 135053, 135090, 135127, 151803, 151833, 151863, 163376, 163411, 163446, 178944, 178984, 179024, 182304, 182344, 182384, 200470, 200503, 200536, 212814, 212851, 212888, 229232, 229274, 229316, 232760, 232802, 232844, 290891, 290931, 290971, 292711, 292753, 292795]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.HashSet;\n\n/**\n * A TransitionPath represents a chain of transitions from one state to another\n */\npublic final class TransitionPath implements Comparable<TransitionPath>\n{\n    private final List<PathEntry> path;\n    private final Set<String>     uniqueTransitionNames;\n\n    TransitionPath(final State startState)\n    {\n        this(Arrays.asList(new PathEntry[] { new PathEntry(startState) }));\n    }\n\n    private TransitionPath(final List<PathEntry> states)\n    {\n        this.path = new ArrayList<PathEntry>(states);\n        this.uniqueTransitionNames = new HashSet<String>();\n        for (final PathEntry pe : states)\n        {\n            if (pe.getTransition() != null)\n            {\n                this.uniqueTransitionNames.add(pe.getTransition().getName());\n            }\n        }\n    }\n\n    /**\n     * add a unique transition to the given target\n     * @param target\n     * @param trans\n     * @return true if this method invocation has altered the TransitionPath, false otherwise\n     */\n    boolean add(final State target, final Transition trans)\n    {\n        final PathEntry entry = new PathEntry(target, trans);\n        if (this.path.contains(entry))\n        {\n            return false;\n        }\n        this.uniqueTransitionNames.add(trans.getName());\n        return this.path.add(entry);\n    }\n\n    public TransitionPath clonePath()\n    {\n        return new TransitionPath(this.path);\n    }\n\n    @Override\n    public String toString()\n    {\n        final StringBuilder b = new StringBuilder(""path: "");\n        for (final PathEntry s : this.path)\n        {\n            b.append(s);\n        }\n        return b.toString();\n    }\n\n    @Override\n    public int hashCode()\n    {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((this.path == null) ? 0 : this.path.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(final Object obj)\n    {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        final TransitionPath other = (TransitionPath) obj;\n        if (this.path == null)\n        {\n            if (other.path != null)\n                return false;\n        }\n        else if (!this.path.equals(other.path))\n            return false;\n        return true;\n    }\n\n    /**\n     * execute this path on\'t state machine\n     * \n     * @return true if the path executed all transition successfully\n     */\n    final public TransitionPathResult execute()\n    {\n        for (final PathEntry entry : this.path)\n        {\n            final Collection<Enum<?>> reasons = entry.execute();\n            if (!reasons.isEmpty())\n            {\n                return TransitionPathResult.fail(entry, reasons);\n            }\n        }\n        return TransitionPathResult.success();\n    }\n\n    /**\n     * @return the length of this path\n     */\n    public int size()\n    {\n        return this.path.size();\n    }\n\n    /**\n     * @return the result of the comparison\n     */\n    @Override\n    public int compareTo(final TransitionPath o)\n    {\n        return Integer.valueOf(size()).compareTo(Integer.valueOf(o.size()));\n    }\n\n\n    /**\n     * @return true if the path contains the transition with the given name\n     */\n    public boolean containsTransition(final String name)\n    {\n        return this.uniqueTransitionNames.contains(name);\n    }\n}\n')",[282857]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsPaymentComplete extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""Payment Complete"";\n\n    \n    /**\n     * @param fsm\n     */\n    ClaimsPaymentComplete(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        return allTransitions;    \n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[267776]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getPackageName(com.porpoise.fsm.generator.FilenameHelperTest)')","[710, 734, 758, 4711, 4742, 4773, 5455, 5486, 5517, 22341, 22365, 22389, 29214, 33026, 33056, 33086, 33287, 33315, 33343, 45780, 45815, 45850, 46620, 46655, 46690, 65730, 65758, 65786, 75480, 75508, 75536, 75723, 75749, 75775, 87402, 87435, 87468, 88194, 88227, 88260, 106192, 106218, 106244, 115547, 115579, 115611, 115826, 115856, 115886, 129133, 129170, 129207, 130021, 130058, 130095, 150243, 150273, 150303, 161070, 161105, 161140, 161376, 161409, 161442, 175904, 175944, 175984, 176864, 176904, 176944, 198754, 198787, 198820, 210374, 210411, 210448, 210698, 210733, 210768, 226040, 226082, 226124, 227048, 227090, 227132, 287452, 287492, 287532, 287776, 287818, 287860]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\binterface (\\w+).*', 'package aaron.test;\n\n/**\n * a listener callback used to respond to state changes.\n */\npublic interface StateListener\n{\n    /**\n     *\n     */\n    TransitionGuard onExit(final Transition transition);\n    \n    /**\n     *\n     */\n    TransitionGuard onEnter(final Transition transition);\n}\n')",[256714]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsNotReceivedAndClaimsReceivedByHeadOfDelivery(aaron.test.test.ClaimsNotReceivedTest)')","[7191, 7222, 7253, 9795, 9826, 9857, 23685, 23709, 23733, 35117, 35147, 35177, 48580, 48615, 48650, 51520, 51555, 51590, 67298, 67326, 67354, 77429, 77457, 77485, 90042, 90075, 90108, 92814, 92847, 92880, 107648, 107674, 107700, 117780, 117812, 117844, 132093, 132130, 132167, 135201, 135238, 135275, 151923, 151953, 151983, 163516, 163551, 163586, 179104, 179144, 179184, 182464, 182504, 182544, 200602, 200635, 200668, 212962, 212999, 213036, 229400, 229442, 229484, 232928, 232970, 233012, 291051, 291091, 291131, 292879, 292921, 292963]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsNotReceivedAndClaimsReceivedByMonitoringOfficer(aaron.test.test.ClaimsNotReceivedTest)')","[6416, 9020, 23085, 29442, 34367, 47705, 50645, 66598, 76729, 89217, 91989, 106998, 116980, 131168, 134276, 151173, 162641, 178104, 181464, 199777, 212037, 228350, 231878, 290051, 291829]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_executeToClaimsReceivedByMonitoringOfficer(aaron.test.test.ClaimsReceivedByMonitoringOfficerTest)')","[10508, 13856, 25005, 29902, 37041, 52325, 56105, 68838, 79223, 93573, 97137, 109078, 119834, 136052, 140048, 153573, 165765, 183384, 187704, 202417, 215341, 233894, 238430, 296631, 298417]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\nimport com.google.common.base.Predicate;\n\n/** \n */\npublic final class ConditionalTransitionListener implements TransitionListener\n{\n    private final  TransitionGuard onFalseResult;\n    private final Predicate<Transition> filter;\n    private final TransitionListener delegate;    \n    /**\n     * @param predicate\n     */\n    public ConditionalTransitionListener(final Predicate<Transition> predicate, final TransitionListener wrappedListener)\n    {\n        this(predicate, wrappedListener, TransitionGuard.ok());\n    }\n    \n    /**\n     * @param predicate\n     */\n    public ConditionalTransitionListener(final Predicate<Transition> predicate, final TransitionListener wrappedListener, final TransitionGuard onFalseResultParam)\n    {\n        if (predicate == null)\n        {\n            throw new NullPointerException(""predicate cannot be null"");        \n        }\n        if (wrappedListener == null)\n        {\n            throw new NullPointerException(""wrappedListener cannot be null"");        \n        }\n        if (onFalseResultParam == null)\n        {\n            throw new NullPointerException(""onFalseResultParam cannot be null"");        \n        }\n        this.filter = predicate;\n        this.onFalseResult = onFalseResultParam;\n        this.delegate = wrappedListener; \n    }\n    \n    /**\n     * fired when a transition is executed\n     * \n     * @return the transition guard\n     */\n    @Override\n    public TransitionGuard onTransition(final Transition transition)\n    {\n        if (this.filter.apply(transition))\n        {\n            return this.delegate.onTransition(transition);\n        }\n        return this.onFalseResult;\n    }\n}\n')",[279279]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class TestStartState extends AbstractTestState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""start-state"";\n\n    \n    /**\n     * @param fsm\n     */\n    TestStartState(final TestStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        return allTransitions;    \n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[286777]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\npublic interface NamedObject\n{\n    /**\n     * @return a name for the object\n     */\n    public String getName();\n}\n')",[277684]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'com.porpoise.fsm.generator.StateMachineGeneratorTest')","[545, 32854, 75320, 115363, 160868, 210160]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_rejectToParticipant(aaron.test.test.ClaimsReceivedByMonitoringOfficerTest)')","[11252, 14600, 25581, 30028, 37761, 53165, 56945, 69510, 79895, 94365, 97929, 109702, 120602, 136940, 140936, 154293, 166605, 184344, 188664, 203209, 216229, 234902, 239438, 297591, 299425]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * A PathEntry represents a link in the chain of a \'path\' from one state to another.\n * Each link in a path denotes a new target state and the transition used to get there. \n */\nfinal class PathEntry\n{\n    private final State      state;\n    private final Transition viaTransition;\n\n    PathEntry(final State stateValue, final Transition transitionValue)\n    {\n        this.state = stateValue;\n        this.viaTransition = transitionValue;\n    }\n\n    PathEntry(final State startState)\n    {\n        this(startState, null);\n    }\n\n    /**\n     * @return the state from this transition\n     */\n    public State getState()\n    {\n        return this.state;\n    }\n\n    /**\n     * @return the transition used to arrive at the next state\n     */\n    public Transition getTransition()\n    {\n        return this.viaTransition;\n    }\n\n    /**\n     * execute the given path. Return true if all transitions executed successfully\n     * \n     * @return a non-null collection of reasons should the transition fail\n     */\n    final Collection<Enum<?>> execute()\n    {\n        if (getTransition() != null)\n        {\n            return getTransition().execute();\n        }\n        return Collections.emptyList();\n    }\n\n    @Override\n    public int hashCode()\n    {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((this.state == null) ? 0 : this.state.hashCode());\n        result = prime * result + ((this.viaTransition == null) ? 0 : this.viaTransition.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(final Object obj)\n    {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        final PathEntry other = (PathEntry) obj;\n        if (this.state == null)\n        {\n            if (other.state != null)\n                return false;\n        }\n        else if (!this.state.equals(other.state))\n            return false;\n        if (this.viaTransition == null)\n        {\n            if (other.viaTransition != null)\n                return false;\n        }\n        else if (!this.viaTransition.equals(other.viaTransition))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString()\n    {\n        if (this.viaTransition == null)\n            return this.state.getName();\n        return String.format(""--[%s]-->%s"", this.viaTransition.getName(), this.state.getName());\n    }\n}')",[282440]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\n\n/**\n * A collection of useful implementations of TransitionListener\n */\npublic enum TransitionListeners \n{\n    ;//uninstantiable\n\n    /**\n     * a listener which records the transitions\n     */\n    public static class RecordingTransitionListener implements TransitionListener\n    {\n        private final List<Transition> transitions = new ArrayList<Transition>();\n\n        @Override\n        public TransitionGuard onTransition(final Transition transition)\n        {\n            this.transitions.add(transition);\n            return TransitionGuard.ok();\n        }\n\n        /**\n         * @return the enter transitions\n         */\n        public List<Transition> getTransitions()\n        {\n            return Collections.unmodifiableList(this.transitions);\n        }\n    }\n    \n    private static class BlockingListener implements TransitionListener\n    {\n        private final Enum<?> reason;\n        public BlockingListener(final Enum<?> reasonValue)\n        {\n            this.reason = reasonValue;\n        }\n    \n        @Override\n        public TransitionGuard onTransition(final Transition transition)\n        {\n            return TransitionGuard.stopEventually(this.reason);\n        }\n    }\n    \n    private static TransitionListener BLOCKING_INSTANCE = new BlockingListener(null); \n\n    /**\n     * @return a new recording transition listener\n     */\n    public static RecordingTransitionListener recordingListener()\n    {\n        return new RecordingTransitionListener();\n    }\n    /**\n     * @return a listener which returns @{code TransitionGuard.stopEventually()}\n     */\n    public static TransitionListener blockingListener()\n    {\n        return BLOCKING_INSTANCE;\n    }\n    /**\n     * @return a listener which returns @{code TransitionGuard.stopEventually()}\n     */\n    public static TransitionListener blockingListener(final Enum<?> reason)\n    {\n        return new BlockingListener(reason);\n    }\n    \n    /**\n     * @return a listener which disallows transitions when the given condition returns false\n     */\n    public static TransitionListener blockOnFalse(final Predicate<Transition> condition, final Enum<?> reason)\n    {\n        final TransitionListener delegate = TransitionListeners.blockingListener(reason);\n        final TransitionListener listener = filter(condition, delegate);\n        return listener;\n    }\n\n    /**\n     * @param condition\n     *            the condition (predicate) used to evaluate whether or not the given listener should be invoked\n     * @param delegate\n     *            the listener to invoke when the condition returns true\n     * @return the conditional listener which wraps the given listener\n     */\n    public static ConditionalTransitionListener filter(final Predicate<Transition> condition, final TransitionListener delegate)\n    {\n        final ConditionalTransitionListener listener = new ConditionalTransitionListener(condition, delegate);\n        return listener;\n    }    \n    /**\n     * @return a listener which disallows transitions when the given condition returns true\n     */\n    public static TransitionListener blockOnTrue(final Predicate<Transition> condition, final Enum<?> reason)\n    {\n        return blockOnFalse(Predicates.not(condition), reason);\n    }\n\n }')",[278687]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\n\n\n/**\n * Representation of the state machine. Through a TestStateMachine instance you can:\n * <ul>\n * <li>Create a new instance (see @{link createAndStart()} and @{link create()})</li>\n * <li>Access all states by their names</li>\n * <li>register and unregister listeners which will be notified of every state transition</li>\n * <li>navigate to (execute) states via transitions</li>\n * <li>retrieve state instances by their names</li>\n * </ul>\n *\n * States returned via this state machine may *only* be used in this state machine.\n * For example, this is not valid:\n * <pre>\n * TestStateMachine fsmOne = TestStateMachine.createAndStart();\n * TestStateMachine fsmTwo = TestStateMachine.createAndStart();\n * Object stateA = fsmOne.<some state>();\n * fsmTwo.executeToState(stateA); // invalid  -- cannot share state instances between state machines\n * </pre>\n */\npublic class TestStateMachine\n{\n    private StateNotifier notifier;\n    private State                     currentState;\n    private final Map<String, AbstractTestState>  stateByName;\n\n    private TestStartState teststartstate;\n\n    /**\n     *\n     */\n    private TestStateMachine()\n    {\n        super();\n        this.stateByName = new HashMap<String, AbstractTestState>();\n    }\n\n    /**\n     * @return a new notifier\n     */\n    final StateNotifier newNotifier()\n    {\n        return new StateNotifier();\n    }\n\n    /**\n     * state machines need to be explicitly started.\n     * This is a convenience method for returning a new state machine which is \n     * already in the start state\n     *\n     * @return the new state machine\n     */\n    public static TestStateMachine createAndStart()\n    {\n        TestStateMachine instance = create();\n        instance.start();\n        return instance;\n    }\n\n    /**\n     * factory method used to create state machines\n     *\n     * @return a new state machine instance\n     */\n    public static TestStateMachine create()\n    {\n        final TestStateMachine fsm = new TestStateMachine();\n\n        fsm.notifier = fsm.newNotifier();\n        \n        //\n        // Create states\n        //\n        fsm.teststartstate = new TestStartState(fsm);\n        final State oldTestStartStateEntry = fsm.stateByName.put(fsm.teststartstate.getName(), fsm.teststartstate);\n        assert oldTestStartStateEntry == null : ""duplicate state names: "" + fsm.teststartstate.getName();\n\n\n        //\n        // Initialise transitions\n        //\n        fsm.teststartstate.initialise();\n        return fsm;\n    }\n\n    /**\n     * @return the current state\n     */\n    public State getCurrentState()\n    {\n        return this.currentState;\n    }\n    \n    /**\n     * @param goal the target state\n     * @return a TransitionPaths object from the current state to the given goal state\n     */\n    public TransitionPaths getPaths(final State goal)\n    {\n        return getCurrentState().getPaths(goal);\n    }\n\n    /**\n     * @param goal\n     *            the target state\n     * @return a TransitionPaths object from the current state to the given goal state\n     */\n    public TransitionPaths getSuccessfulPaths(final State goal)\n    {\n        final TransitionPaths allPaths = getCurrentState().getPaths(goal);\n        final TransitionPaths successfulPaths = new TransitionPaths();\n        if (allPaths != null)\n        {\n            for (final TransitionPath path : allPaths)\n            {\n                final TransitionPathResult result = executePathDryRun(path);\n                if (result != null && result.isSuccess())\n                {\n                    successfulPaths.add(path);\n                }\n            }\n        }\n        return successfulPaths;\n    }\n\n    /**\n     * @param path\n     *            the path to execute w/o affecting the current state. All registered listeners however will be notified.\n     * @return the result\n     */\n    public final TransitionPathResult executePathDryRun(final TransitionPath path)\n    {\n        final State beforeState = getCurrentState();\n        TransitionPathResult result;\n        try\n        {\n            result = path.execute();\n        }\n        finally\n        {\n            setCurrentState(beforeState);\n        }\n        return result;\n    }\n\n    /**\n     * @param path\n     *            the path to execute\n     * @return the result\n     */\n    public final TransitionPathResult executePath(final TransitionPath path)\n    {\n        return path.execute();\n    }\n\n    /**\n     * @param the given state name\n     * @return the result\n     */\n    public TransitionPathResult executeToState(final String name)\n    {   \n        final State state = getStateForName(name);\n        if (state == null)\n        {\n            throw new IllegalArgumentException(String.format(""No state exists with the name \'%s\'"", name));\n        }\n        return executeToState(state);\n    }\n\n    /**\n     * @param the given state name\n     * @return the result\n     */\n    public TransitionPathResult executeToStateDryRun(final String name)\n    {   \n        final State state = getStateForName(name);\n        if (state == null)\n        {\n            throw new IllegalArgumentException(String.format(""No state exists with the name \'%s\'"", name));\n        }\n        return executeToStateDryRun(state);\n    }\n    \n    /**\n     * After calling, the state will be reset its current state see {@link #executeToState(State)}\n     * \n     * @param to\n     *            the goal state\n     * @return the result of executing to the given state via the shorted available path\n     */\n    public TransitionPathResult executeToStateDryRun(final State to)\n    {\n        final State beforeState = getCurrentState();\n        TransitionPathResult result;\n        try\n        {\n            result = executeToState(to);\n        }\n        finally\n        {\n            setCurrentState(beforeState);\n        }\n        return result;\n    }\n\n\n    /**\n     * jump to the given state via the shortest \'path\'.\n     * \n     * @param to\n     *            the goal state\n     * @return the result of trying to move to the given state via the shortest available path, or null if no path was found. If the state machine was already in the given state it returns false. If the state\n     *         machine has now moved into the given state it returns true.\n     */\n    public TransitionPathResult executeToState(final State to)\n    {\n        if (to == getCurrentState())\n        {\n            return TransitionPathResult.fail(TransitionGuard.Reasons.ALREADY_IN_TARGET_STATE);\n        }\n\n        final TransitionPath path = getShortestSuccessfulPath(to);\n        \n        if (path != null)\n        {\n            return path.execute();\n        }\n\n        return TransitionPathResult.fail(TransitionGuard.Reasons.TARGET_STATE_UNREACHABLE);\n    }\n\n    /**\n     * @param to\n     *            the target (goal) state\n     * @return the first path available which can transition to the given state\n     */\n    public TransitionPath getShortestSuccessfulPath(final State to)\n    {\n        final State beforeState = getCurrentState();\n        TransitionPath path;\n        try\n        {\n            path = getShortestSuccessfulPathInternal(to);\n        }\n        finally\n        {\n            setCurrentState(beforeState);\n        }\n\n        return path;\n    }\n\n    private TransitionPath getShortestSuccessfulPathInternal(final State to)\n    {\n        final TransitionPaths paths = getPaths(to);\n        boolean success = false;\n        final State beforeState = getCurrentState();\n        for (final TransitionPath path : paths)\n        {\n            StateLog.debug(""trying "" + path);\n            success = executeToStateInternal(path, to);\n            if (success)\n            {\n                return path;\n            }\n            setCurrentState(beforeState);\n        }\n        return null;\n    }\n\n    /**\n     * jump to the given state via the path of transitions\n     * \n     * @return true if this call had any effect\n     */\n    private boolean executeToStateInternal(final TransitionPath path, final State to)\n    {\n        if (to == getCurrentState())\n        {\n            return false;\n        }\n        if (path == null)\n        {\n            throw new IllegalStateException(String.format(""can\'t get to \'%s\' from \'%s\'"", getCurrentStateName(), to.getName()));\n        }\n        path.execute();\n        return to == getCurrentState();\n    }\n\n    /**\n     * @return the name of the current state\n     */\n    public String getCurrentStateName()\n    {\n        return getCurrentState() == null ? null : getCurrentState().getName();\n    }\n\n    /**\n     * @return the start state\n     * @throws IllegalStateException\n     *             if the state machine was already started\n     */\n    public TestStartState start()\n    {\n        if (getCurrentState() != null && getCurrentState().equals(this.teststartstate))\n        {\n            throw new IllegalStateException(""already started"");\n        }\n        setCurrentState(this.teststartstate);\n        return this.teststartstate;\n    }\n\n    /**\n     * @return the TestStartState state\n     */\n    public TestStartState startState()\n    {\n        return this.teststartstate;\n    }    \n\n\n    /**\n     * @return a collection of all the transitions across all states\n     */\n    public Collection<Transition> getTransitions()\n    {\n        final Collection<Transition> states = new LinkedList<Transition>();\n        for (final AbstractTestState state : this.stateByName.values())\n        {\n            states.addAll(state.getTransitions());\n        }\n        return states;\n    }\n\n    /**\n     * @return a collection of all the names for all the transitions across all states\n     */\n    public Collection<String> getTransitionNames()\n    {\n        final Collection<String> names = new LinkedList<String>();\n        for (final AbstractTestState state : this.stateByName.values())\n        {\n            names.addAll(state.getTransitionNames());\n        }\n        return names;\n    }\n\n    /**\n     * @return a collection of all states for this state machine\n     */\n    public Collection<State> getStates()\n    {\n        final Collection<State> states = new LinkedList<State>();\n        for (final AbstractTestState state : this.stateByName.values())\n        {\n            states.add(state);\n        }\n        return states;\n    }\n\n\n    /**\n     * @return a collection of all the names of all the states for this state machine\n     */\n    public Collection<String> getStateNames()\n    {\n        return this.stateByName.keySet();\n    }\n    \n    /**\n     * @param name the name of the state\n     * @return the state for the given name\n     */\n    public State getStateForName(final String name)\n    {\n        if (name == null)\n        {\n            throw new NullPointerException(""Invalid argument: null state name"");\n        }\n        return this.stateByName.get(name);\n    }\n\n    /**\n     * @param name\n     *            the name of the transition\n     * @return the transition for the given name\n     */\n    public Transition getTransitionForName(final String name)\n    {\n        for (final AbstractTestState state : this.stateByName.values())\n        {\n            final Transition transition = state.getTransitionForName(name);\n            if (transition != null)\n            {\n                return transition;\n            }\n        }\n        return null;\n    }\n    \n    final void setCurrentState(State newState)\n    {\n        this.currentState = newState;\n    }\n\n\n    /**\n     * @param listeners\n     */\n    public void registerListeners(final StateListener... listeners)\n    {\n        for (final StateListener listener : listeners)\n        {\n            registerListener(listener);\n        }\n    }\n\n    /**\n     * register and return the given listener\n     * @param listener the registered listener\n     * @return the registered listener (for chaining)\n     */\n    public <T extends StateListener> T registerListener(final T listener)\n    {\n        final boolean added = this.notifier.registerListener(listener);\n        assert added;\n        return listener;\n    }\n\n    /**\n     * unregister a listener\n     * @return true if the listener was successfully unregistered\n     */\n    public boolean unregisterListener(final StateListener listener)\n    {\n        return this.notifier.unregisterListener(listener);\n    }\n\n    final TransitionGuard onBeforeTransition(final Transition transition)\n    {\n        return this.notifier.onBeforeTransition(transition);\n    }\n\n    final TransitionGuard onAfterTransition(final Transition transition)\n    {\n        return this.notifier.onAfterTransition(transition);\n    }\n\n    /**\n     * drops your entire database.\n     * Either that or just represents the state machine as a string. \n     * Take your chances.\n     */\n    @Override\n    public String toString()\n    {\n        final String newLine = String.format(""%n"");\n        final StringBuilder builder = new StringBuilder(""TestStateMachine"").append(newLine);\n        builder.append(""\\t"").append(this.notifier).append(newLine);\n        builder.append(""Current State:"");\n        builder.append(this.currentState).append(newLine);\n        builder.append(this.teststartstate).append(newLine);\n        return builder.toString();\n    }\n}\n')",[277649]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\n/**\n * represents the state in a state machine\n */\npublic interface State extends NamedObject\n{\n    /**\n     * Return a unique name for this state.\n     * \n     * A state may need to be persisted, a common way to do this is \n     * to persist an enumeration of state values.\n     *   \n     * @return the unique name of this state\n     */\n    @Override\n    public String getName();\n    \n    /**\n     * allow callbacks to register their interest\n     * @param listener the listener to register\n     * @return true if the listener was registered successfully\n     */\n    <T extends StateListener> T registerListener(final T listener);\n\n    /**\n     * allow callbacks (listeners) to unregister their interest\n     * @param listener the listener to unregister\n     * @return true if the listener was unregistered successfully\n     */\n    boolean unregisterListener(final StateListener listener);\n    \n    /**\n     * @return an object representing all paths to the given state from this state\n     */\n    TransitionPaths getPaths(final State to);\n}\n')",[277852]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.HashSet;\n\n/**\n * A TransitionPath represents a chain of transitions from one state to another\n */\npublic final class TransitionPath implements Comparable<TransitionPath>\n{\n    private final List<PathEntry> path;\n    private final Set<String>     uniqueTransitionNames;\n\n    TransitionPath(final State startState)\n    {\n        this(Arrays.asList(new PathEntry[] { new PathEntry(startState) }));\n    }\n\n    private TransitionPath(final List<PathEntry> states)\n    {\n        this.path = new ArrayList<PathEntry>(states);\n        this.uniqueTransitionNames = new HashSet<String>();\n        for (final PathEntry pe : states)\n        {\n            if (pe.getTransition() != null)\n            {\n                this.uniqueTransitionNames.add(pe.getTransition().getName());\n            }\n        }\n    }\n\n    /**\n     * add a unique transition to the given target\n     * @param target\n     * @param trans\n     * @return true if this method invocation has altered the TransitionPath, false otherwise\n     */\n    boolean add(final State target, final Transition trans)\n    {\n        final PathEntry entry = new PathEntry(target, trans);\n        if (this.path.contains(entry))\n        {\n            return false;\n        }\n        this.uniqueTransitionNames.add(trans.getName());\n        return this.path.add(entry);\n    }\n\n    public TransitionPath clonePath()\n    {\n        return new TransitionPath(this.path);\n    }\n\n    @Override\n    public String toString()\n    {\n        final StringBuilder b = new StringBuilder(""path: "");\n        for (final PathEntry s : this.path)\n        {\n            b.append(s);\n        }\n        return b.toString();\n    }\n\n    @Override\n    public int hashCode()\n    {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((this.path == null) ? 0 : this.path.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(final Object obj)\n    {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        final TransitionPath other = (TransitionPath) obj;\n        if (this.path == null)\n        {\n            if (other.path != null)\n                return false;\n        }\n        else if (!this.path.equals(other.path))\n            return false;\n        return true;\n    }\n\n    /**\n     * execute this path on\'t state machine\n     * \n     * @return true if the path executed all transition successfully\n     */\n    final public TransitionPathResult execute()\n    {\n        for (final PathEntry entry : this.path)\n        {\n            final Collection<Enum<?>> reasons = entry.execute();\n            if (!reasons.isEmpty())\n            {\n                return TransitionPathResult.fail(entry, reasons);\n            }\n        }\n        return TransitionPathResult.success();\n    }\n\n    /**\n     * @return the length of this path\n     */\n    public int size()\n    {\n        return this.path.size();\n    }\n\n    /**\n     * @return the result of the comparison\n     */\n    @Override\n    public int compareTo(final TransitionPath o)\n    {\n        return Integer.valueOf(size()).compareTo(Integer.valueOf(o.size()));\n    }\n\n\n    /**\n     * @return true if the path contains the transition with the given name\n     */\n    public boolean containsTransition(final String name)\n    {\n        return this.uniqueTransitionNames.contains(name);\n    }\n}\n')",[283191]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport com.google.common.base.Predicate;\n\n/**\n * a listener which can be turned on and off by the given predicate\n */\npublic class ConditionalStateListener extends AbstractConditionalStateListener \n{\n    private final StateListener wrappedListener;\n\n    /**\n     * @param predicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener will be executed.\n     * @param listener\n     */\n    public ConditionalStateListener(final Predicate<Transition> predicate, final StateListener listener)\n    {\n        this(predicate, predicate, listener);\n    }\n\n    /**\n     * @param enterPredicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener\'s onEnter will be executed.\n     * @param exitPredicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener\'s onExit method will be executed.\n     * @param predicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener will be executed.\n     * @param listener\n     */\n    public ConditionalStateListener(final Predicate<Transition> enterPredicate, final Predicate<Transition> exitPredicate, final StateListener listener)\n    {\n        this(enterPredicate, exitPredicate, listener, TransitionGuard.ok(), TransitionGuard.ok());\n    }\n\n    /**\n     * @param enterPredicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener\'s onEnter will be executed.\n     * @param exitPredicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener\'s onExit method will be executed.\n     * @param predicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener will be executed.\n     * @param listener\n     * @param enterDefault the transition to return should the enter predicate filter return false\n     * @param exitDefault the transition to return should the exit predicate filter return false\n     */\n    public ConditionalStateListener(final Predicate<Transition> enterPredicate, final Predicate<Transition> exitPredicate, final StateListener listener, final TransitionGuard enterDefault, final TransitionGuard exitDefault)\n    {\n        super(enterPredicate, exitPredicate, exitDefault, exitDefault);\n        if (listener == null)\n        {\n            throw new NullPointerException(""listener cannot be null"");\n        }\n        this.wrappedListener = listener;\n    }\n   \n    /**\n     * @param transition\n     * @return the transition return value.  \n     */\n    @Override\n    protected TransitionGuard onExitInternal(final Transition transition)\n    {\n        return this.wrappedListener.onExit(transition);\n    }\n\n    /**\n     * @param transition\n     * @return the transition return value.  \n     */\n    @Override\n    protected TransitionGuard onEnterInternal(final Transition transition)\n    {\n        return this.wrappedListener.onEnter(transition);\n    }\n}\n')",[256427]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport java.util.Collection;\n\n/**\n * Transition represents a transition between two states \n */\npublic interface Transition extends NamedObject\n{\n    /**\n     * General failure reasons for transitions\n     */\n    enum Reasons\n    {\n        /** \n         * The current state of the state machine does not match the source state of the transition\n         */\n        INVALID_SOURCE_STATE;\n    }\n\n    /** \n     * execute the transition\n     * @return the new state\n     */\n    Collection<Enum<?>> execute();\n     \n    /**\n     * @return the source state\n     */\n    State getSource();\n     \n    /**\n     * @return the target state\n     */\n    State getTarget();\n\n    /**\n     * @param listener\n     * @return the registered listener\n     */\n    <T extends TransitionListener> T registerListener(final T listener);\n\n    /**\n     * @param listener\n     * @return true if the listener was removed successfully\n     */\n    boolean unregisterListener(final TransitionListener listener);\n}\n')",[261923]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_cannotCreateTransitionsBetweenMachines(com.porpoise.fsm.model.TransitionTest)')","[452, 3936, 4556, 22029, 29091, 32362, 32505, 44905, 45605, 65366, 74862, 74995, 86577, 87237, 105854, 114837, 114990, 128208, 128948, 149853, 160291, 160459, 174904, 175704, 198325, 209549, 209727, 224990, 225830, 251386, 251548]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getStateForName(aaron.test.test.ClaimsReceivedByMonitoringOfficerTest)')","[1295, 1319, 1343, 10167, 10198, 10229, 13515, 13546, 13577, 24741, 24765, 24789, 29839, 36711, 36741, 36771, 38052, 38080, 38108, 51940, 51975, 52010, 55720, 55755, 55790, 68530, 68558, 68586, 78915, 78943, 78971, 80166, 80192, 80218, 93210, 93243, 93276, 96774, 96807, 96840, 108792, 108818, 108844, 119482, 119514, 119546, 120913, 120943, 120973, 135645, 135682, 135719, 139641, 139678, 139715, 153243, 153273, 153303, 165380, 165415, 165450, 166946, 166979, 167012, 182944, 182984, 183024, 187264, 187304, 187344, 202054, 202087, 202120, 214934, 214971, 215008, 216590, 216625, 216660, 233432, 233474, 233516, 237968, 238010, 238052, 296191, 296231, 296271, 297955, 297997, 298039]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getStateForName(aaron.test.test.ClaimsPaymentCompleteTest)')","[5796, 7656, 22797, 29359, 33870, 47005, 49105, 66262, 76266, 88557, 90537, 106686, 116449, 130428, 132648, 150813, 162059, 177304, 179704, 199381, 211421, 227510, 230030, 289141, 289471]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getStateForName(aaron.test.test.ClaimsReceivedByDeliveryTeamTest)')","[1505, 14848, 17452, 26541, 30258, 39235, 40218, 57225, 60165, 70630, 81269, 82186, 98193, 100965, 110742, 122176, 123225, 141232, 144340, 155493, 168329, 169477, 188984, 192344, 204529, 218053, 219267, 239774, 243302, 302571, 303853]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\n\n/**\n * A holder for \'paths\' -- chains of transitions through the state machine\n */\npublic final class TransitionPaths implements Iterable<TransitionPath>\n{\n    private final Collection<TransitionPath> paths;\n\n    TransitionPaths()\n    {\n        this.paths = new ArrayList<TransitionPath>();\n    }\n\n    boolean add(final TransitionPath path)\n    {\n        if (!this.paths.contains(path))\n        {\n            return this.paths.add(path);\n        }\n        return false;\n    }\n \n    /** \n     * @return the paths\n     */\n    public Collection<TransitionPath> getPaths()\n    {\n        return Collections.unmodifiableCollection(this.paths);\n    }\n\n    /** \n     * get the path at index i\n     */\n    public TransitionPath getPath(final int i)\n    {\n        if (i < 0 || i > getPaths().size())\n        {\n            return null;\n        }\n        int index = 0;\n        for (final TransitionPath path : getPaths())\n        {\n            if (index == i)\n                return path;\n            index++;\n        }\n        return null;\n    }\n\n    /**\n     * return the shorted path. Multiple paths may exist with the same length\n     * \n     * @return the shorted path\n     */\n    public TransitionPath getShortestPath()\n    {\n        if (getPaths().isEmpty())\n            return null;\n        return getPathsAsSortedList().get(0);\n    }\n\n    /**\n     * @return a list of paths, shortest first\n     */\n    public List<TransitionPath> getPathsAsSortedList()\n    {\n        final LinkedList<TransitionPath> pathList = new LinkedList<TransitionPath>(getPaths());\n        Collections.sort(pathList);\n        return pathList;\n    }\n\n    /**\n     * @return the number of paths available between two states\n     */\n    public int size()\n    {\n        return this.paths.size();\n    }\n    \n    /**\n     * @return true if there are no paths between the two states\n     */\n    public boolean isEmpty()\n    {\n        return size() == 0;\n    }\n\n\n    /**\n     * @return the iterator\n     */\n    @Override\n    public Iterator<TransitionPath> iterator()\n    {\n        return getPathsAsSortedList().iterator();\n    }\n\n    /**\n     * @param names the name(s) of the transition(s) to include\n     * @return a {@link TransitionPaths} object which contains a subset of this paths object which contain the transition identified by the given name \n     */\n    public final TransitionPaths getPathsWithTransitions(final String ... names)\n    {\n        return filterPaths(PathFilters.byNames(names));\n    }\n\n    /**\n     * @name the name of the transition\n     * @return a {@link TransitionPaths} object which contains a subset of this paths object which does NOT contain the transition identified by the given name \n     */\n    public final TransitionPaths getPathsAvoidingTransitions(final String ... names)\n    {\n        final Predicate<TransitionPath> filter = PathFilters.byNames(names); \n        return filterPaths(Predicates.not(filter));\n    }\n    \n    /**\n     * @param filter the filter to apply to child paths\n     * @return a new TransitionPaths object which only contains TransitionPaths which match the given filter \n     */\n    public TransitionPaths filterPaths(final Predicate<TransitionPath> filter)\n    {\n        final TransitionPaths matchingPaths = new TransitionPaths();\n        for (final TransitionPath path : this)\n        {\n            if (filter.apply(path))\n            {\n                matchingPaths.add(path);\n            }\n        }\n        return matchingPaths;\n    }\n    \n    /**\n     * @return a string representation\n     */\n    @Override\n    public String toString()\n    {\n        final String newLine = String.format(""%n"");\n        final StringBuilder b = new StringBuilder();\n        for (final Object path : this.paths)\n        {\n            b.append(path).append(newLine);\n        }\n        return b.toString();\n    }\n    \n}')",[281822]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_rejectToDeliveryTeam(aaron.test.test.ClaimsReceivedByHeadOfDeliveryTest)')","[13019, 13050, 13081, 16367, 16398, 16429, 26181, 26205, 26229, 38648, 38678, 38708, 55160, 55195, 55230, 58940, 58975, 59010, 70210, 70238, 70266, 80722, 80750, 80778, 96246, 96279, 96312, 99810, 99843, 99876, 110352, 110378, 110404, 121549, 121581, 121613, 139049, 139086, 139123, 143045, 143082, 143119, 155043, 155073, 155103, 167642, 167677, 167712, 186624, 186664, 186704, 190944, 190984, 191024, 204034, 204067, 204100, 217326, 217363, 217400, 237296, 237338, 237380, 241832, 241874, 241916, 300533, 300573, 300613, 301849, 301891, 301933]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\n/**\n * tests for ClaimsStateMachine\n */\npublic class ListenerAdapter implements StateListener \n{\n    private TransitionGuard entranceGuard;\n    private TransitionGuard exitGuard;\n\n    /**\n     * Default Constructor\n     */\n    public ListenerAdapter()\n    {\n        this(TransitionGuard.ok(), TransitionGuard.ok());\n    }\n\n    /**\n     * @param entrance the entrance guard\n     * @param exit the exit guard\n     */\n    public ListenerAdapter(final TransitionGuard entrance, final TransitionGuard exit)\n    {\n        if (entrance == null)\n        {\n            throw new NullPointerException(""entrance guard type cannot be null"");\n        }\n        if (exit == null)\n        {\n            throw new NullPointerException(""exit guard type cannot be null"");\n        }\n        this.entranceGuard = entrance;\n        this.exitGuard = exit;\n    }\n\n    /**\n     * @param transition\n     * @return \'continue\'\n     */\n    public TransitionGuard onExit(final Transition transition)\n    {\n        return this.exitGuard;\n    }\n\n    /**\n     * @param transition\n     * @return \'continue\'\n     */\n    public TransitionGuard onEnter(final Transition transition)\n    {\n        return this.entranceGuard;\n    }\n}\n')",[260378]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsRejectToMo extends AbstractTransition<ClaimsReceivedByDeliveryTeam, ClaimsReceivedByMonitoringOfficer>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""reject to mo"";\n\n    TransitionClaimsRejectToMo(final ClaimsReceivedByDeliveryTeam from, final ClaimsReceivedByMonitoringOfficer to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[267354]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsReceivedByMonitoringOfficerAndClaimsReceivedByDeliveryTeam(aaron.test.test.ClaimsReceivedByMonitoringOfficerTest)')","[10663, 10694, 10725, 14011, 14042, 14073, 25125, 25149, 25173, 37191, 37221, 37251, 52500, 52535, 52570, 56280, 56315, 56350, 68978, 69006, 69034, 79363, 79391, 79419, 93738, 93771, 93804, 97302, 97335, 97368, 109208, 109234, 109260, 119994, 120026, 120058, 136237, 136274, 136311, 140233, 140270, 140307, 153723, 153753, 153783, 165940, 165975, 166010, 183584, 183624, 183664, 187904, 187944, 187984, 202582, 202615, 202648, 215526, 215563, 215600, 234104, 234146, 234188, 238640, 238682, 238724, 296831, 296871, 296911, 298627, 298669, 298711]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'class one class two enum three')",[288191]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsPaymentRejected\n */\npublic class ClaimsPaymentRejectedTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the \'ClaimsPaymentRejected\' state\n     */\n    @Test\n    public void test_executeToClaimsPaymentRejected()\n    {\n        Assert.assertNotNull(moveToClaimsPaymentRejected());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for \'paymentRejected\' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.paymentRejected().getName();\n        Assert.assertEquals(fsm.paymentRejected(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the paymentRejected state\n     */\n    final ClaimsPaymentRejected moveToClaimsPaymentRejected()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsPaymentRejected paymentRejected = fsm.paymentRejected();\n\n        // call the method under test\n        fsm.executeToState(paymentRejected);\n\n        Assert.assertSame(paymentRejected, fsm.getCurrentState());\n        Assert.assertEquals(paymentRejected.getName(), fsm.getCurrentStateName());\n        \n        return paymentRejected;\n    }\n\n    \n    @Test\n    public void test_getPathBetweenClaimsPaymentRejectedAndClaimsReadyForPayment()\n    {\n\n        final ClaimsPaymentRejected paymentRejected = moveToClaimsPaymentRejected();\n        final ClaimsStateMachine fsm = paymentRejected.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'paymentRejected\'"", paymentRejected, fsm.getCurrentState());\n\n        final TransitionPaths paths = paymentRejected.getPaths(fsm.readyForPayment());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        paymentRejected.registerResubmitForPaymentListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'paymentRejected\'"", paymentRejected, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.readyForPayment(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'resubmitForPayment\' transition \n     */\n    @Test\n    public void test_resubmitForPayment()\n    {\n        final ClaimsPaymentRejected paymentRejected = moveToClaimsPaymentRejected();\n        final ClaimsStateMachine fsm = paymentRejected.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        paymentRejected.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        paymentRejected.resubmitForPayment();\n\n        //\n        // assert the current state is now ClaimsReadyForPayment\n        //\n        Assert.assertEquals(fsm.readyForPayment(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.readyForPayment().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsResubmitForPayment.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsResubmitForPayment.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(paymentRejected.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsPaymentRejected\' can be moved into the ClaimsReadyForPayment state\n     */\n    @Test\n    public void test_moveToClaimsReadyForPayment()\n    {\n        final ClaimsPaymentRejected paymentRejected = moveToClaimsPaymentRejected();\n        final ClaimsStateMachine fsm = paymentRejected.getStateMachine();\n        paymentRejected.getPaths(fsm.readyForPayment());\n        \n    }\n}\n')",[269916]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsPaymentRejected extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""Payment Rejected"";\n\n    private TransitionClaimsResubmitForPayment resubmitForPayment; \n    \n    /**\n     * @param fsm\n     */\n    ClaimsPaymentRejected(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        // Transition resubmit for payment\n        this.resubmitForPayment = new TransitionClaimsResubmitForPayment(this, getStateMachine().readyForPayment());\n        allTransitions.add(this.resubmitForPayment); \n\n        return allTransitions;    \n    }\n    \n    /**\n     * execute the resubmit for payment transition\n     * @return true if the transition was successful\n     */\n    public boolean resubmitForPayment() {\n        this.resubmitForPayment.execute();\n        return this.resubmitForPayment.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerResubmitForPaymentListener(final T listener)\n    {\n        return this.resubmitForPayment.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterResubmitForPaymentListener(final TransitionListener listener)\n    {\n        return this.resubmitForPayment.unregisterListener(listener);\n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[263657]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * <p>\n * A TransitionPathResult represents the result of trying to execute a {@link TransitionPath}.\n * You can query the result, asking if it was successful or not. In the case where it was not\n * successful, you can retrieve a collection of \'reason\' enumerations, which indicate why the\n * path was not successful. The reasons given will be those from the exit/enter state guards or \n * transition guards. \n * </p>\n * See {@link TransitionPath#execute()}.\n */\npublic final class TransitionPathResult\n{\n    private Collection<Enum<?>> reasons;\n    private PathEntry failedEntry;\n    \n    private TransitionPathResult(final PathEntry failedEntryValue, final Collection<Enum<?>> reasonValues)\n    {\n        this.reasons = reasonValues;\n        this.failedEntry = failedEntryValue;\n    }\n    \n    /**\n     * @return the failure reasons\n     */\n    public Collection<Enum<?>> getFailureReasons()\n    {\n        return Collections.unmodifiableCollection(this.reasons);\n    }\n    \n    /**\n     * @return the failed path entry\n     */\n    public PathEntry getFailedEntry()\n    {\n        return this.failedEntry;\n    }\n    \n    /**\n     * @return true if the transition was successful\n     */\n    public boolean isSuccess()\n    {\n        return this.reasons.isEmpty();\n    }\n    \n    /**\n     * @return true if the transition failed\n     */\n    public boolean isFail()\n    {\n        return !isSuccess();\n    }\n    \n    /**\n     * factory method for success results\n     * @return a new success result\n     */\n    static TransitionPathResult success()\n    {\n        final Collection<Enum<?>> r = Collections.emptyList();\n        return new TransitionPathResult(null, r);\n    }\n\n    /**\n     * factory method for failure results\n     * @return a new failure result\n     */\n    static TransitionPathResult fail(final PathEntry failedEntryValue, final Collection<Enum<?>> reasonValues)\n    {\n        return new TransitionPathResult(failedEntryValue, reasonValues);\n    }\n\n    /**\n     * factory method for failure results\n     * @return a new failure result\n     */\n    static TransitionPathResult fail(final Enum<?> ... reasonValues)\n    {\n        final Collection<Enum<?>> r = new ArrayList<Enum<?>>();\n        if (reasonValues == null || reasonValues.length == 0)\n        {\n            r.add(TransitionGuard.Reasons.NO_REASON_GIVEN);\n        }\n        else\n        {\n            r.addAll(Arrays.asList(reasonValues));\n        }\n        return new TransitionPathResult(null, r);\n    }\n    \n    /** \n     * @return the string representation\n     */\n    @Override\n    public String toString()\n    {\n        if(isSuccess())\n        {\n            return ""SUCCESS"";\n        }\n        return String.format(""FAIL: entry=%s reasons=%s"", this.failedEntry, this.reasons);\n    }\n}\n')",[260298]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsStartState extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""start-state"";\n\n    private TransitionClaimsInit init; \n    \n    /**\n     * @param fsm\n     */\n    ClaimsStartState(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        // Transition init\n        this.init = new TransitionClaimsInit(this, getStateMachine().notReceived());\n        allTransitions.add(this.init); \n\n        return allTransitions;    \n    }\n    \n    /**\n     * execute the init transition\n     * @return true if the transition was successful\n     */\n    public boolean init() {\n        this.init.execute();\n        return this.init.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerInitListener(final T listener)\n    {\n        return this.init.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterInitListener(final TransitionListener listener)\n    {\n        return this.init.unregisterListener(listener);\n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[268097]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_moveToClaimsReceivedByDeliveryTeam(aaron.test.test.ClaimsReceivedByMonitoringOfficerTest)')","[10291, 10322, 10353, 13639, 13670, 13701, 24837, 24861, 24885, 36831, 36861, 36891, 52080, 52115, 52150, 55860, 55895, 55930, 68642, 68670, 68698, 79027, 79055, 79083, 93342, 93375, 93408, 96906, 96939, 96972, 108896, 108922, 108948, 119610, 119642, 119674, 135793, 135830, 135867, 139789, 139826, 139863, 153363, 153393, 153423, 165520, 165555, 165590, 183104, 183144, 183184, 187424, 187464, 187504, 202186, 202219, 202252, 215082, 215119, 215156, 233600, 233642, 233684, 238136, 238178, 238220, 296351, 296391, 296431, 298123, 298165, 298207]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * A PathEntry represents a link in the chain of a \'path\' from one state to another.\n * Each link in a path denotes a new target state and the transition used to get there. \n */\nfinal class PathEntry\n{\n    private final State      state;\n    private final Transition viaTransition;\n\n    PathEntry(final State stateValue, final Transition transitionValue)\n    {\n        this.state = stateValue;\n        this.viaTransition = transitionValue;\n    }\n\n    PathEntry(final State startState)\n    {\n        this(startState, null);\n    }\n\n    /**\n     * @return the state from this transition\n     */\n    public State getState()\n    {\n        return this.state;\n    }\n\n    /**\n     * @return the transition used to arrive at the next state\n     */\n    public Transition getTransition()\n    {\n        return this.viaTransition;\n    }\n\n    /**\n     * execute the given path. Return true if all transitions executed successfully\n     * \n     * @return a non-null collection of reasons should the transition fail\n     */\n    final Collection<Enum<?>> execute()\n    {\n        if (getTransition() != null)\n        {\n            return getTransition().execute();\n        }\n        return Collections.emptyList();\n    }\n\n    @Override\n    public int hashCode()\n    {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((this.state == null) ? 0 : this.state.hashCode());\n        result = prime * result + ((this.viaTransition == null) ? 0 : this.viaTransition.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(final Object obj)\n    {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        final PathEntry other = (PathEntry) obj;\n        if (this.state == null)\n        {\n            if (other.state != null)\n                return false;\n        }\n        else if (!this.state.equals(other.state))\n            return false;\n        if (this.viaTransition == null)\n        {\n            if (other.viaTransition != null)\n                return false;\n        }\n        else if (!this.viaTransition.equals(other.viaTransition))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString()\n    {\n        if (this.viaTransition == null)\n            return this.state.getName();\n        return String.format(""--[%s]-->%s"", this.viaTransition.getName(), this.state.getName());\n    }\n}')",[282690]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.HashMap;\n        \nabstract class AbstractTestState implements State\n{\n    private final Map<String, Transition> transitionsByName;\n\n    private final TestStateMachine stateMachine;\n    private final StateNotifier notifier;\n    \n    AbstractTestState(final TestStateMachine fsm)\n    {\n        if (fsm == null)\n        {\n            throw new NullPointerException(""state machine cannot be null"");\n        }\n        this.stateMachine = fsm;\n        this.notifier = fsm.newNotifier();\n        this.transitionsByName = new HashMap<String, Transition>();\n    }\n    \n    public TestStateMachine getStateMachine()\n    {\n        return this.stateMachine;\n    }\n\n\n    /**\n     * @param fsm\n     */\n    void initialise()\n    {\n        for(final Transition transition  : initialiseTransitions())\n        {\n            this.transitionsByName.put(transition.getName(), transition);\n        }    \n    }\n    \n    Collection<Transition> getTransitions()\n    {\n        return this.transitionsByName.values();\n    }\n\n    Collection<String> getTransitionNames()\n    {\n        return this.transitionsByName.keySet();\n    }\n    \n    final Transition getTransitionForName(final String name)\n    {\n        return this.transitionsByName.get(name);\n    }\n\n    abstract Collection<Transition> initialiseTransitions();\n\n    /**\n     * @return true if the listener was successfully registered\n     */\n    public <T extends StateListener> T registerListener(final T listener)\n    {\n        final boolean registered = this.notifier.registerListener(listener);\n        assert registered : ""listener not registered: "" + listener;\n        return listener;\n    }\n\n    public boolean unregisterListener(final StateListener listener)\n    {\n        return this.notifier.unregisterListener(listener);\n    }\n\n    final TransitionGuard onExit(final Transition transition)\n    {\n        return this.notifier.onBeforeTransition(transition);\n    }\n\n    final TransitionGuard onEnter(final Transition transition)\n    {\n        return this.notifier.onAfterTransition(transition);\n    }\n\n    /**\n     * @param the target state\n     * @return the transition paths\n     */\n    public TransitionPaths getPaths(final State toState)\n    {\n        final TransitionPaths paths = new TransitionPaths();\n        final TransitionPath path = new TransitionPath(this);\n\n        appendPathRecursive(paths, path, toState);\n\n        return paths;\n    }\n\n    private void appendPathRecursive(final TransitionPaths paths, final TransitionPath srcPath, final State goal)\n    {\n        for (final Transition transition : getTransitions())\n        {\n            final TransitionPath path = srcPath.clonePath();\n            final AbstractTestState targetState = (AbstractTestState) transition.getTarget();\n\n            final boolean notRecursivePathLoop = path.add(targetState, transition);\n\n            if (notRecursivePathLoop)\n            {\n                if (targetState.equals(goal))\n                {\n                   paths.add(path); \n                }\n                else\n                {\n                    targetState.appendPathRecursive(paths, path, goal);\n                }\n            }\n        }\n    }\n    \n    /**\n     *\n     */\n    @Override\n    public String toString()\n    {\n        final StringBuilder builder = new StringBuilder();\n        final String newLine = String.format(""%n"");\n        builder.append(getName()).append(newLine);\n        for (final Transition transition : getTransitions())\n        {\n            builder.append(""\\t"").append(transition).append(newLine);\n        }\n        builder.append(""\\t"").append(this.notifier).append(newLine);\n        return builder.toString();\n    }\n}\n')",[286637]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\binterface (\\w+).*', 'package aaron.test;\n\n/**\n * represents the state in a state machine\n */\npublic interface State extends NamedObject\n{\n    /**\n     * Return a unique name for this state.\n     * \n     * A state may need to be persisted, a common way to do this is \n     * to persist an enumeration of state values.\n     *   \n     * @return the unique name of this state\n     */\n    @Override\n    public String getName();\n    \n    /**\n     * allow callbacks to register their interest\n     * @param listener the listener to register\n     * @return true if the listener was registered successfully\n     */\n    <T extends StateListener> T registerListener(final T listener);\n\n    /**\n     * allow callbacks (listeners) to unregister their interest\n     * @param listener the listener to unregister\n     * @return true if the listener was unregistered successfully\n     */\n    boolean unregisterListener(final StateListener listener);\n    \n    /**\n     * @return an object representing all paths to the given state from this state\n     */\n    TransitionPaths getPaths(final State to);\n}\n')",[254614]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', ""package p.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport p.*;\nimport p.TransitionGuard.Reasons;\nimport p.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for TestStartState\n */\npublic class TestStartStateTest extends AbstractTestTest\n{\n    /**\n     * test the state machine can move into the 'TestStartState' state\n     */\n    @Test\n    public void test_executeToTestStartState()\n    {\n        Assert.assertNotNull(moveToTestStartState());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for 'startState' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final TestStateMachine fsm = newStateMachine();\n        final String name =fsm.startState().getName();\n        Assert.assertEquals(fsm.startState(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the startState state\n     */\n    final TestStartState moveToTestStartState()\n    {\n        final TestStateMachine fsm = newStateMachine();\n        final TestStartState startState = fsm.startState();\n\n        // call the method under test\n        fsm.executeToState(startState);\n\n        Assert.assertSame(startState, fsm.getCurrentState());\n        Assert.assertEquals(startState.getName(), fsm.getCurrentStateName());\n        \n        return startState;\n    }\n\n}\n"")",[287372]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\nimport com.google.common.base.Predicate;\n\n/** \n */\npublic final class ConditionalTransitionListener implements TransitionListener\n{\n    private final  TransitionGuard onFalseResult;\n    private final Predicate<Transition> filter;\n    private final TransitionListener delegate;    \n    /**\n     * @param predicate\n     */\n    public ConditionalTransitionListener(final Predicate<Transition> predicate, final TransitionListener wrappedListener)\n    {\n        this(predicate, wrappedListener, TransitionGuard.ok());\n    }\n    \n    /**\n     * @param predicate\n     */\n    public ConditionalTransitionListener(final Predicate<Transition> predicate, final TransitionListener wrappedListener, final TransitionGuard onFalseResultParam)\n    {\n        if (predicate == null)\n        {\n            throw new NullPointerException(""predicate cannot be null"");        \n        }\n        if (wrappedListener == null)\n        {\n            throw new NullPointerException(""wrappedListener cannot be null"");        \n        }\n        if (onFalseResultParam == null)\n        {\n            throw new NullPointerException(""onFalseResultParam cannot be null"");        \n        }\n        this.filter = predicate;\n        this.onFalseResult = onFalseResultParam;\n        this.delegate = wrappedListener; \n    }\n    \n    /**\n     * fired when a transition is executed\n     * \n     * @return the transition guard\n     */\n    @Override\n    public TransitionGuard onTransition(final Transition transition)\n    {\n        if (this.filter.apply(transition))\n        {\n            return this.delegate.onTransition(transition);\n        }\n        return this.onFalseResult;\n    }\n}\n')",[279443]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsResubmitForPayment extends AbstractTransition<ClaimsPaymentRejected, ClaimsReadyForPayment>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""resubmit for payment"";\n\n    TransitionClaimsResubmitForPayment(final ClaimsPaymentRejected from, final ClaimsReadyForPayment to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[263763]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\n\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Set;\nimport java.util.HashSet;\n\n/**\n * A TransitionPath represents a chain of transitions from one state to another\n */\nenum PathFilters\n{\n    ; // uninstantiable\n\n    /**\n     * @return a TransitionPath filter which returns \'true\' when a path contains a transition\n     * with the given name\n     */\n    public static final Predicate<TransitionPath> byName(final String name)\n    {\n        return new Predicate<TransitionPath>() {\n            public boolean apply(final TransitionPath path) {\n                return path.containsTransition(name);\n            }\n        };\n    }\n\n    /**\n     * @return a TransitionPath filter which returns \'true\' when a path contains a transition with one of the given names\n     */\n     @SuppressWarnings(""unchecked"")\n    public static final Predicate<TransitionPath> byNames(final String ... names)\n    {\n        final Set<String> uniqueNames = new HashSet<String>(Arrays.asList(names));\n        final Collection<Predicate<TransitionPath>> filters = new ArrayList<Predicate<TransitionPath>>(uniqueNames.size());\n        for (final String name : uniqueNames)\n        {\n            if (name != null)\n            {\n                filters.add(byName(name));\n            }\n        }\n        Predicate<TransitionPath>[] filtersArray = new Predicate[filters.size()];\n        filtersArray = filters.toArray(filtersArray);\n        return Predicates.or(filtersArray);\n    }\n}\n')",[258783]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_rejectPayment(aaron.test.test.ClaimsReadyForPaymentTest)')","[8059, 8090, 8121, 11779, 11810, 11841, 24165, 24189, 24213, 35854, 35884, 35914, 49560, 49595, 49630, 53760, 53795, 53830, 67858, 67886, 67914, 78116, 78144, 78172, 90966, 90999, 91032, 94926, 94959, 94992, 108168, 108194, 108220, 118567, 118599, 118631, 133129, 133166, 133203, 137569, 137606, 137643, 152523, 152553, 152583, 164378, 164413, 164448, 180224, 180264, 180304, 185024, 185064, 185104, 201262, 201295, 201328, 213874, 213911, 213948, 230576, 230618, 230660, 235616, 235658, 235700, 293793, 293833, 293873, 295093, 295135, 295177]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\binterface (\\w+).*', 'package p;\n\n/**\n * if you use google collections, refactor to use that instead \n */\npublic enum StateLog\n{\n    ;// uninstantiable\n\n    public static String error(final String format, final Object... args)\n    {\n        final String log = ""_error:"" + String.format(format, args);\n        System.out.println(log);\n        return log;\n    }\n\n    public static String info(final String format, final Object... args)\n    {\n        final String log = ""_info:"" + String.format(format, args);\n        System.out.println(log);\n        return log;\n    }\n\n    public static String debug(final String format, final Object... args)\n    {\n        final String log = ""_debug:"" + String.format(format, args);\n        System.out.println(log);\n        return log;\n    }\n    \n    public static String trace(final String format, final Object... args)\n    {\n        return ""_trace:"" + String.format(format, args);\n    }\n}\n')",[278163]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * A PathEntry represents a link in the chain of a \'path\' from one state to another.\n * Each link in a path denotes a new target state and the transition used to get there. \n */\nfinal class PathEntry\n{\n    private final State      state;\n    private final Transition viaTransition;\n\n    PathEntry(final State stateValue, final Transition transitionValue)\n    {\n        this.state = stateValue;\n        this.viaTransition = transitionValue;\n    }\n\n    PathEntry(final State startState)\n    {\n        this(startState, null);\n    }\n\n    /**\n     * @return the state from this transition\n     */\n    public State getState()\n    {\n        return this.state;\n    }\n\n    /**\n     * @return the transition used to arrive at the next state\n     */\n    public Transition getTransition()\n    {\n        return this.viaTransition;\n    }\n\n    /**\n     * execute the given path. Return true if all transitions executed successfully\n     * \n     * @return a non-null collection of reasons should the transition fail\n     */\n    final Collection<Enum<?>> execute()\n    {\n        if (getTransition() != null)\n        {\n            return getTransition().execute();\n        }\n        return Collections.emptyList();\n    }\n\n    @Override\n    public int hashCode()\n    {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((this.state == null) ? 0 : this.state.hashCode());\n        result = prime * result + ((this.viaTransition == null) ? 0 : this.viaTransition.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(final Object obj)\n    {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        final PathEntry other = (PathEntry) obj;\n        if (this.state == null)\n        {\n            if (other.state != null)\n                return false;\n        }\n        else if (!this.state.equals(other.state))\n            return false;\n        if (this.viaTransition == null)\n        {\n            if (other.viaTransition != null)\n                return false;\n        }\n        else if (!this.viaTransition.equals(other.viaTransition))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString()\n    {\n        if (this.viaTransition == null)\n            return this.state.getName();\n        return String.format(""--[%s]-->%s"", this.viaTransition.getName(), this.state.getName());\n    }\n}')",[259139]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_approveForHeadOfDelivery(aaron.test.test.ClaimsReceivedByMonitoringOfficerTest)')","[11035, 11066, 11097, 14383, 14414, 14445, 25413, 25437, 25461, 37551, 37581, 37611, 52920, 52955, 52990, 56700, 56735, 56770, 69314, 69342, 69370, 79699, 79727, 79755, 94134, 94167, 94200, 97698, 97731, 97764, 109520, 109546, 109572, 120378, 120410, 120442, 136681, 136718, 136755, 140677, 140714, 140751, 154083, 154113, 154143, 166360, 166395, 166430, 184064, 184104, 184144, 188384, 188424, 188464, 202978, 203011, 203044, 215970, 216007, 216044, 234608, 234650, 234692, 239144, 239186, 239228, 297311, 297351, 297391, 299131, 299173, 299215]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'aaron.test.test.ClaimsPaymentRejectedTest')","[1949, 42658, 84460, 125831, 172332, 222288]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport com.google.common.base.Predicate;\n\n/**\n * A PredicateToggle provides a means for toggling a {@link Predicate}\n */\npublic final class PredicateToggle\n{\n    private final AtomicBoolean     enabled;\n    private final Predicate<Object> predicate;\n\n    private PredicateToggle(final boolean firstValue)\n    {\n        this.enabled = new AtomicBoolean(firstValue);\n        this.predicate = new Predicate<Object>() {\n            @Override\n            public boolean apply(final Object value)\n            {\n                return isEnabled();\n            }\n\n            @Override\n            public String toString()\n            {\n                return String.format(""Toggle %b"", Boolean.valueOf(isEnabled()));\n            }\n        };\n    }\n\n    /**\n     * @return a new enabled toggle\n     */\n    public static PredicateToggle on()\n    {\n        return new PredicateToggle(true);\n    }\n\n    /**\n     * @return a new disabled toggle\n     */\n    public static PredicateToggle off()\n    {\n        return new PredicateToggle(false);\n    }\n\n    /**\n     * enable the toggle\n     * \n     * @return true if this method call changed the toggle value\n     */\n    public boolean enable()\n    {\n        return this.enabled.compareAndSet(false, true);\n    }\n\n    /**\n     * disable the toggle\n     * \n     * @return true if this method call changed the toggle value\n     */\n    public boolean disable()\n    {\n        return this.enabled.compareAndSet(true, false);\n    }\n\n    /**\n     * switch the toggle value - going from off to on or from on to off.\n     */\n    public void toggle()\n    {\n        this.enabled.set(!isEnabled());\n    }\n\n    /**\n     * @return true if the toggle is currently enabled\n     */\n    public boolean isEnabled()\n    {\n        return this.enabled.get();\n    }\n\n    /**\n     * @return a transition filter representing the current state of the toggle\n     */\n    @SuppressWarnings(""unchecked"")\n    public <T> Predicate<T> predicate()\n    {\n        return (Predicate<T>) this.predicate;\n    }\n}\n')",[257198]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsReadyForPayment extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""Ready For Payment"";\n\n    private TransitionClaimsRejectPayment rejectPayment; \n    private TransitionClaimsMarkPaymentAsReceived markPaymentAsReceived; \n    \n    /**\n     * @param fsm\n     */\n    ClaimsReadyForPayment(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        // Transition reject payment\n        this.rejectPayment = new TransitionClaimsRejectPayment(this, getStateMachine().paymentRejected());\n        allTransitions.add(this.rejectPayment); \n\n        // Transition mark payment as received\n        this.markPaymentAsReceived = new TransitionClaimsMarkPaymentAsReceived(this, getStateMachine().paymentReceived());\n        allTransitions.add(this.markPaymentAsReceived); \n\n        return allTransitions;    \n    }\n    \n    /**\n     * execute the reject payment transition\n     * @return true if the transition was successful\n     */\n    public boolean rejectPayment() {\n        this.rejectPayment.execute();\n        return this.rejectPayment.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerRejectPaymentListener(final T listener)\n    {\n        return this.rejectPayment.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterRejectPaymentListener(final TransitionListener listener)\n    {\n        return this.rejectPayment.unregisterListener(listener);\n    }\n    \n    /**\n     * execute the mark payment as received transition\n     * @return true if the transition was successful\n     */\n    public boolean markPaymentAsReceived() {\n        this.markPaymentAsReceived.execute();\n        return this.markPaymentAsReceived.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerMarkPaymentAsReceivedListener(final T listener)\n    {\n        return this.markPaymentAsReceived.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterMarkPaymentAsReceivedListener(final TransitionListener listener)\n    {\n        return this.markPaymentAsReceived.unregisterListener(listener);\n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[263960]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test.test;\n\nimport aaron.test.*;\n\nimport org.junit.*;\n\n/**\n * tests for ClaimsStateMachine\n */\npublic class ClaimsStateMachineTest \n{\n    /**\n     *\n     */\n    @Test\n    public void test_generalListeners()\n    {\n        final ClaimsStateMachine fsm = ClaimsStateMachine.create(); \n        Assert.assertNotNull(fsm);\n    }\n\n}\n')",[269324]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\nimport java.util.Collection;\n\n/**\n * Transition represents a transition between two states \n */\npublic interface Transition extends NamedObject\n{\n    /**\n     * General failure reasons for transitions\n     */\n    enum Reasons\n    {\n        /** \n         * The current state of the state machine does not match the source state of the transition\n         */\n        INVALID_SOURCE_STATE;\n    }\n\n    /** \n     * execute the transition\n     * @return the new state\n     */\n    Collection<Enum<?>> execute();\n     \n    /**\n     * @return the source state\n     */\n    State getSource();\n     \n    /**\n     * @return the target state\n     */\n    State getTarget();\n\n    /**\n     * @param listener\n     * @return the registered listener\n     */\n    <T extends TransitionListener> T registerListener(final T listener);\n\n    /**\n     * @param listener\n     * @return true if the listener was removed successfully\n     */\n    boolean unregisterListener(final TransitionListener listener);\n}\n')",[285224]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getStateForName(aaron.test.test.ClaimsReceivedByDeliveryTeamTest)')","[1529, 1553, 1577, 14879, 14910, 14941, 17483, 17514, 17545, 26565, 26589, 26613, 30278, 39265, 39295, 39325, 40246, 40274, 40302, 57260, 57295, 57330, 60200, 60235, 60270, 70658, 70686, 70714, 81297, 81325, 81353, 82212, 82238, 82264, 98226, 98259, 98292, 100998, 101031, 101064, 110768, 110794, 110820, 122208, 122240, 122272, 123255, 123285, 123315, 141269, 141306, 141343, 144377, 144414, 144451, 155523, 155553, 155583, 168364, 168399, 168434, 169510, 169543, 169576, 189024, 189064, 189104, 192384, 192424, 192464, 204562, 204595, 204628, 218090, 218127, 218164, 219302, 219337, 219372, 239816, 239858, 239900, 243344, 243386, 243428, 302611, 302651, 302691, 303895, 303937, 303979]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_joinStartState(com.porpoise.fsm.model.StartStateTest)')","[125, 149, 173, 2851, 2882, 2913, 21189, 21213, 21237, 28862, 30901, 30931, 30961, 31042, 31070, 31098, 43680, 43715, 43750, 64386, 64414, 64442, 73366, 73394, 73422, 73501, 73529, 73557, 73632, 73658, 73684, 85422, 85455, 85488, 104944, 104970, 104996, 113276, 113308, 113340, 113427, 113457, 113487, 126913, 126950, 126987, 148803, 148833, 148863, 158425, 158455, 158485, 158580, 158615, 158650, 158746, 158779, 158812, 173504, 173544, 173584, 197170, 197203, 197236, 207738, 207775, 207812, 207914, 207949, 207984, 223520, 223562, 223604, 248380, 248420, 248460, 248544, 248586, 248628]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsReadyForPayment extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""Ready For Payment"";\n\n    private TransitionClaimsRejectPayment rejectPayment; \n    private TransitionClaimsMarkPaymentAsReceived markPaymentAsReceived; \n    \n    /**\n     * @param fsm\n     */\n    ClaimsReadyForPayment(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        // Transition reject payment\n        this.rejectPayment = new TransitionClaimsRejectPayment(this, getStateMachine().paymentRejected());\n        allTransitions.add(this.rejectPayment); \n\n        // Transition mark payment as received\n        this.markPaymentAsReceived = new TransitionClaimsMarkPaymentAsReceived(this, getStateMachine().paymentReceived());\n        allTransitions.add(this.markPaymentAsReceived); \n\n        return allTransitions;    \n    }\n    \n    /**\n     * execute the reject payment transition\n     * @return true if the transition was successful\n     */\n    public boolean rejectPayment() {\n        this.rejectPayment.execute();\n        return this.rejectPayment.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerRejectPaymentListener(final T listener)\n    {\n        return this.rejectPayment.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterRejectPaymentListener(final TransitionListener listener)\n    {\n        return this.rejectPayment.unregisterListener(listener);\n    }\n    \n    /**\n     * execute the mark payment as received transition\n     * @return true if the transition was successful\n     */\n    public boolean markPaymentAsReceived() {\n        this.markPaymentAsReceived.execute();\n        return this.markPaymentAsReceived.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerMarkPaymentAsReceivedListener(final T listener)\n    {\n        return this.markPaymentAsReceived.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterMarkPaymentAsReceivedListener(final TransitionListener listener)\n    {\n        return this.markPaymentAsReceived.unregisterListener(listener);\n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[264248]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_executeToClaimsPaymentComplete(aaron.test.test.ClaimsPaymentCompleteTest)')","[944, 968, 992, 5703, 5734, 5765, 7563, 7594, 7625, 22725, 22749, 22773, 29338, 33780, 33810, 33840, 34041, 34069, 34097, 46900, 46935, 46970, 49000, 49035, 49070, 66178, 66206, 66234, 76182, 76210, 76238, 76425, 76451, 76477, 88458, 88491, 88524, 90438, 90471, 90504, 106608, 106634, 106660, 116353, 116385, 116417, 116632, 116662, 116692, 130317, 130354, 130391, 132537, 132574, 132611, 150723, 150753, 150783, 161954, 161989, 162024, 162260, 162293, 162326, 177184, 177224, 177264, 179584, 179624, 179664, 199282, 199315, 199348, 211310, 211347, 211384, 211634, 211669, 211704, 227384, 227426, 227468, 229904, 229946, 229988, 289021, 289061, 289101, 289345, 289387, 289429]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'aaron.test.test.ClaimsReceivedByHeadOfDeliveryTest')","[1364, 39093, 81137, 122024, 168162, 217876]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'com.porpoise.fsm.generator.context.ContextTest')","[289621, 289644, 289668, 289691]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsStartStateAndClaimsNotReceived(aaron.test.test.ClaimsStartStateTest)')","[17204, 18940, 27597, 30529, 40692, 59885, 61845, 71862, 82628, 100701, 102549, 111886, 123731, 144044, 146116, 156813, 170031, 192024, 194264, 205981, 219853, 242966, 245318, 305769, 306595]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test.test;\n\nimport aaron.test.*;\n\nimport org.junit.*;\n\n/**\n * tests for ClaimsStateMachine\n */\npublic class ClaimsStateMachineTest \n{\n    /**\n     *\n     */\n    @Test\n    public void test_generalListeners()\n    {\n        final ClaimsStateMachine fsm = ClaimsStateMachine.create(); \n        Assert.assertNotNull(fsm);\n    }\n\n}\n')",[269420]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\nimport java.util.Collection;\n\n/**\n * Transition represents a transition between two states \n */\npublic interface Transition extends NamedObject\n{\n    /**\n     * General failure reasons for transitions\n     */\n    enum Reasons\n    {\n        /** \n         * The current state of the state machine does not match the source state of the transition\n         */\n        INVALID_SOURCE_STATE;\n    }\n\n    /** \n     * execute the transition\n     * @return the new state\n     */\n    Collection<Enum<?>> execute();\n     \n    /**\n     * @return the source state\n     */\n    State getSource();\n     \n    /**\n     * @return the target state\n     */\n    State getTarget();\n\n    /**\n     * @param listener\n     * @return the registered listener\n     */\n    <T extends TransitionListener> T registerListener(final T listener);\n\n    /**\n     * @param listener\n     * @return true if the listener was removed successfully\n     */\n    boolean unregisterListener(final TransitionListener listener);\n}\n')",[285446]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_moveToClaimsReceivedByHeadOfDelivery(aaron.test.test.ClaimsReceivedByMonitoringOfficerTest)')","[10384, 13732, 24909, 29881, 36921, 52185, 55965, 68726, 79111, 93441, 97005, 108974, 119706, 135904, 139900, 153453, 165625, 183224, 187544, 202285, 215193, 233726, 238262, 296471, 298249]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\n/**\n * listener callback interface \n */\npublic interface TransitionListener\n{\n\n    /**\n     * fired when a transition is executed\n     * @return the transition guard\n     */\n    TransitionGuard onTransition(final Transition transition);\n}\n')",[256960]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.HashMap;\n        \nabstract class AbstractTestState implements State\n{\n    private final Map<String, Transition> transitionsByName;\n\n    private final TestStateMachine stateMachine;\n    private final StateNotifier notifier;\n    \n    AbstractTestState(final TestStateMachine fsm)\n    {\n        if (fsm == null)\n        {\n            throw new NullPointerException(""state machine cannot be null"");\n        }\n        this.stateMachine = fsm;\n        this.notifier = fsm.newNotifier();\n        this.transitionsByName = new HashMap<String, Transition>();\n    }\n    \n    public TestStateMachine getStateMachine()\n    {\n        return this.stateMachine;\n    }\n\n\n    /**\n     * @param fsm\n     */\n    void initialise()\n    {\n        for(final Transition transition  : initialiseTransitions())\n        {\n            this.transitionsByName.put(transition.getName(), transition);\n        }    \n    }\n    \n    Collection<Transition> getTransitions()\n    {\n        return this.transitionsByName.values();\n    }\n\n    Collection<String> getTransitionNames()\n    {\n        return this.transitionsByName.keySet();\n    }\n    \n    final Transition getTransitionForName(final String name)\n    {\n        return this.transitionsByName.get(name);\n    }\n\n    abstract Collection<Transition> initialiseTransitions();\n\n    /**\n     * @return true if the listener was successfully registered\n     */\n    public <T extends StateListener> T registerListener(final T listener)\n    {\n        final boolean registered = this.notifier.registerListener(listener);\n        assert registered : ""listener not registered: "" + listener;\n        return listener;\n    }\n\n    public boolean unregisterListener(final StateListener listener)\n    {\n        return this.notifier.unregisterListener(listener);\n    }\n\n    final TransitionGuard onExit(final Transition transition)\n    {\n        return this.notifier.onBeforeTransition(transition);\n    }\n\n    final TransitionGuard onEnter(final Transition transition)\n    {\n        return this.notifier.onAfterTransition(transition);\n    }\n\n    /**\n     * @param the target state\n     * @return the transition paths\n     */\n    public TransitionPaths getPaths(final State toState)\n    {\n        final TransitionPaths paths = new TransitionPaths();\n        final TransitionPath path = new TransitionPath(this);\n\n        appendPathRecursive(paths, path, toState);\n\n        return paths;\n    }\n\n    private void appendPathRecursive(final TransitionPaths paths, final TransitionPath srcPath, final State goal)\n    {\n        for (final Transition transition : getTransitions())\n        {\n            final TransitionPath path = srcPath.clonePath();\n            final AbstractTestState targetState = (AbstractTestState) transition.getTarget();\n\n            final boolean notRecursivePathLoop = path.add(targetState, transition);\n\n            if (notRecursivePathLoop)\n            {\n                if (targetState.equals(goal))\n                {\n                   paths.add(path); \n                }\n                else\n                {\n                    targetState.appendPathRecursive(paths, path, goal);\n                }\n            }\n        }\n    }\n    \n    /**\n     *\n     */\n    @Override\n    public String toString()\n    {\n        final StringBuilder builder = new StringBuilder();\n        final String newLine = String.format(""%n"");\n        builder.append(getName()).append(newLine);\n        for (final Transition transition : getTransitions())\n        {\n            builder.append(""\\t"").append(transition).append(newLine);\n        }\n        builder.append(""\\t"").append(this.notifier).append(newLine);\n        return builder.toString();\n    }\n}\n')",[286474]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsPaymentRejectedAndClaimsReadyForPayment(aaron.test.test.ClaimsPaymentRejectedTest)')","[20304, 28653, 30820, 42423, 63385, 73094, 84241, 104001, 113030, 125580, 147744, 158133, 172057, 196024, 207433, 221997, 247166, 309659, 310485]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\n/**\n * a listener callback used to respond to state changes.\n */\npublic interface StateListener\n{\n    /**\n     *\n     */\n    TransitionGuard onExit(final Transition transition);\n    \n    /**\n     *\n     */\n    TransitionGuard onEnter(final Transition transition);\n}\n')",[256800]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\binterface (\\w+).*', 'package p;\n\nimport java.util.Collection;\n\n/**\n * Transition represents a transition between two states \n */\npublic interface Transition extends NamedObject\n{\n    /**\n     * General failure reasons for transitions\n     */\n    enum Reasons\n    {\n        /** \n         * The current state of the state machine does not match the source state of the transition\n         */\n        INVALID_SOURCE_STATE;\n    }\n\n    /** \n     * execute the transition\n     * @return the new state\n     */\n    Collection<Enum<?>> execute();\n     \n    /**\n     * @return the source state\n     */\n    State getSource();\n     \n    /**\n     * @return the target state\n     */\n    State getTarget();\n\n    /**\n     * @param listener\n     * @return the registered listener\n     */\n    <T extends TransitionListener> T registerListener(final T listener);\n\n    /**\n     * @param listener\n     * @return true if the listener was removed successfully\n     */\n    boolean unregisterListener(final TransitionListener listener);\n}\n')",[285298]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsReceivedByHeadOfDeliveryAndClaimsReadyForPayment(aaron.test.test.ClaimsReceivedByHeadOfDeliveryTest)')","[13112, 16460, 26253, 30195, 38738, 55265, 59045, 70294, 80806, 96345, 99909, 110430, 121645, 139160, 143156, 155133, 167747, 186744, 191064, 204133, 217437, 237422, 241958, 300653, 301975]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_moveToClaimsPaymentRejected(aaron.test.test.ClaimsReadyForPaymentTest)')","[8152, 11872, 24237, 29714, 35944, 49665, 53865, 67942, 78200, 91065, 95025, 108246, 118663, 133240, 137680, 152613, 164483, 180344, 185144, 201361, 213985, 230702, 235742, 293913, 295219]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsNotReceived extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""Not Received"";\n\n    private TransitionClaimsSubmitToMonitoringOfficer submitToMonitoringOfficer; \n    private TransitionClaimsSubmitToDeliveryTeam submitToDeliveryTeam; \n    private TransitionClaimsSubmitToHeadOfDelivery submitToHeadOfDelivery; \n    \n    /**\n     * @param fsm\n     */\n    ClaimsNotReceived(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        // Transition submit to monitoring officer\n        this.submitToMonitoringOfficer = new TransitionClaimsSubmitToMonitoringOfficer(this, getStateMachine().receivedByMonitoringOfficer());\n        allTransitions.add(this.submitToMonitoringOfficer); \n\n        // Transition submit to delivery team\n        this.submitToDeliveryTeam = new TransitionClaimsSubmitToDeliveryTeam(this, getStateMachine().receivedByDeliveryTeam());\n        allTransitions.add(this.submitToDeliveryTeam); \n\n        // Transition submit to head of delivery\n        this.submitToHeadOfDelivery = new TransitionClaimsSubmitToHeadOfDelivery(this, getStateMachine().receivedByHeadOfDelivery());\n        allTransitions.add(this.submitToHeadOfDelivery); \n\n        return allTransitions;    \n    }\n    \n    /**\n     * execute the submit to monitoring officer transition\n     * @return true if the transition was successful\n     */\n    public boolean submitToMonitoringOfficer() {\n        this.submitToMonitoringOfficer.execute();\n        return this.submitToMonitoringOfficer.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerSubmitToMonitoringOfficerListener(final T listener)\n    {\n        return this.submitToMonitoringOfficer.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterSubmitToMonitoringOfficerListener(final TransitionListener listener)\n    {\n        return this.submitToMonitoringOfficer.unregisterListener(listener);\n    }\n    \n    /**\n     * execute the submit to delivery team transition\n     * @return true if the transition was successful\n     */\n    public boolean submitToDeliveryTeam() {\n        this.submitToDeliveryTeam.execute();\n        return this.submitToDeliveryTeam.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerSubmitToDeliveryTeamListener(final T listener)\n    {\n        return this.submitToDeliveryTeam.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterSubmitToDeliveryTeamListener(final TransitionListener listener)\n    {\n        return this.submitToDeliveryTeam.unregisterListener(listener);\n    }\n    \n    /**\n     * execute the submit to head of delivery transition\n     * @return true if the transition was successful\n     */\n    public boolean submitToHeadOfDelivery() {\n        this.submitToHeadOfDelivery.execute();\n        return this.submitToHeadOfDelivery.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerSubmitToHeadOfDeliveryListener(final T listener)\n    {\n        return this.submitToHeadOfDelivery.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterSubmitToHeadOfDeliveryListener(final TransitionListener listener)\n    {\n        return this.submitToHeadOfDelivery.unregisterListener(listener);\n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[265678]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_join(com.porpoise.fsm.model.StateTest)')","[359, 383, 407, 2975, 3006, 3037, 4091, 4122, 4153, 21861, 21885, 21909, 29049, 32015, 32045, 32075, 32276, 32304, 32332, 43820, 43855, 43890, 45080, 45115, 45150, 65170, 65198, 65226, 74539, 74567, 74595, 74782, 74808, 74834, 85554, 85587, 85620, 86742, 86775, 86808, 105672, 105698, 105724, 114466, 114498, 114530, 114745, 114775, 114805, 127061, 127098, 127135, 128393, 128430, 128467, 149643, 149673, 149703, 159884, 159919, 159954, 160190, 160223, 160256, 173664, 173704, 173744, 175104, 175144, 175184, 198094, 198127, 198160, 209118, 209155, 209192, 209442, 209477, 209512, 223688, 223730, 223772, 225200, 225242, 225284, 250770, 250810, 250850, 251094, 251136, 251178]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsPaymentReceived\n */\npublic class ClaimsPaymentReceivedTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the \'ClaimsPaymentReceived\' state\n     */\n    @Test\n    public void test_executeToClaimsPaymentReceived()\n    {\n        Assert.assertNotNull(moveToClaimsPaymentReceived());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for \'paymentReceived\' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.paymentReceived().getName();\n        Assert.assertEquals(fsm.paymentReceived(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the paymentReceived state\n     */\n    final ClaimsPaymentReceived moveToClaimsPaymentReceived()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsPaymentReceived paymentReceived = fsm.paymentReceived();\n\n        // call the method under test\n        fsm.executeToState(paymentReceived);\n\n        Assert.assertSame(paymentReceived, fsm.getCurrentState());\n        Assert.assertEquals(paymentReceived.getName(), fsm.getCurrentStateName());\n        \n        return paymentReceived;\n    }\n\n    \n    @Test\n    public void test_getPathBetweenClaimsPaymentReceivedAndClaimsPaymentComplete()\n    {\n\n        final ClaimsPaymentReceived paymentReceived = moveToClaimsPaymentReceived();\n        final ClaimsStateMachine fsm = paymentReceived.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'paymentReceived\'"", paymentReceived, fsm.getCurrentState());\n\n        final TransitionPaths paths = paymentReceived.getPaths(fsm.paymentComplete());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        paymentReceived.registerMarkPaymentAsCompleteListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'paymentReceived\'"", paymentReceived, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.paymentComplete(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'markPaymentAsComplete\' transition \n     */\n    @Test\n    public void test_markPaymentAsComplete()\n    {\n        final ClaimsPaymentReceived paymentReceived = moveToClaimsPaymentReceived();\n        final ClaimsStateMachine fsm = paymentReceived.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        paymentReceived.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        paymentReceived.markPaymentAsComplete();\n\n        //\n        // assert the current state is now ClaimsPaymentComplete\n        //\n        Assert.assertEquals(fsm.paymentComplete(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.paymentComplete().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsMarkPaymentAsComplete.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsMarkPaymentAsComplete.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(paymentReceived.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsPaymentReceived\' can be moved into the ClaimsPaymentComplete state\n     */\n    @Test\n    public void test_moveToClaimsPaymentComplete()\n    {\n        final ClaimsPaymentReceived paymentReceived = moveToClaimsPaymentReceived();\n        final ClaimsStateMachine fsm = paymentReceived.getStateMachine();\n        paymentReceived.getPaths(fsm.paymentComplete());\n        \n    }\n}\n')",[273419]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getStateForName(aaron.test.test.ClaimsStartStateTest)')","[1646, 1670, 1694, 16863, 16894, 16925, 18599, 18630, 18661, 27333, 27357, 27381, 30466, 40362, 40392, 40422, 40983, 41011, 41039, 59500, 59535, 59570, 61460, 61495, 61530, 71554, 71582, 71610, 82320, 82348, 82376, 82899, 82925, 82951, 100338, 100371, 100404, 102186, 102219, 102252, 111600, 111626, 111652, 123379, 123411, 123443, 124042, 124072, 124102, 143637, 143674, 143711, 145709, 145746, 145783, 156483, 156513, 156543, 169646, 169681, 169716, 170372, 170405, 170438, 191584, 191624, 191664, 193824, 193864, 193904, 205618, 205651, 205684, 219446, 219483, 219520, 220214, 220249, 220284, 242504, 242546, 242588, 244856, 244898, 244940, 305329, 305369, 305409, 306133, 306175, 306217]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_init(aaron.test.test.ClaimsStartStateTest)')","[17328, 19064, 27693, 30550, 40812, 60025, 61985, 71974, 82740, 100833, 102681, 111990, 123859, 144192, 146264, 156933, 170171, 192184, 194424, 206113, 220001, 243134, 245486, 305929, 306763]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsReceivedByHeadOfDeliveryAndClaimsReceivedByDeliveryTeam(aaron.test.test.ClaimsReceivedByHeadOfDeliveryTest)')","[12864, 16212, 26061, 30153, 38498, 54985, 58765, 70070, 80582, 96081, 99645, 110222, 121389, 138864, 142860, 154893, 167467, 186424, 190744, 203869, 217141, 237086, 241622, 300333, 301639]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_asJavaName(com.porpoise.fsm.generator.context.ContextTest)')","[827, 851, 875, 5207, 5238, 5269, 5951, 5982, 6013, 22533, 22557, 22581, 29276, 33403, 33433, 33463, 33664, 33692, 33720, 46340, 46375, 46410, 47180, 47215, 47250, 65954, 65982, 66010, 75831, 75859, 75887, 76074, 76100, 76126, 87930, 87963, 87996, 88722, 88755, 88788, 106400, 106426, 106452, 115950, 115982, 116014, 116229, 116259, 116289, 129725, 129762, 129799, 130613, 130650, 130687, 150483, 150513, 150543, 161512, 161547, 161582, 161818, 161851, 161884, 176544, 176584, 176624, 177504, 177544, 177584, 199018, 199051, 199084, 210842, 210879, 210916, 211166, 211201, 211236, 226712, 226754, 226796, 227720, 227762, 227804, 288271, 288311, 288351, 288595, 288637, 288679]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\n\n/**\n * A holder for \'paths\' -- chains of transitions through the state machine\n */\npublic final class TransitionPaths implements Iterable<TransitionPath>\n{\n    private final Collection<TransitionPath> paths;\n\n    TransitionPaths()\n    {\n        this.paths = new ArrayList<TransitionPath>();\n    }\n\n    boolean add(final TransitionPath path)\n    {\n        if (!this.paths.contains(path))\n        {\n            return this.paths.add(path);\n        }\n        return false;\n    }\n \n    /** \n     * @return the paths\n     */\n    public Collection<TransitionPath> getPaths()\n    {\n        return Collections.unmodifiableCollection(this.paths);\n    }\n\n    /** \n     * get the path at index i\n     */\n    public TransitionPath getPath(final int i)\n    {\n        if (i < 0 || i > getPaths().size())\n        {\n            return null;\n        }\n        int index = 0;\n        for (final TransitionPath path : getPaths())\n        {\n            if (index == i)\n                return path;\n            index++;\n        }\n        return null;\n    }\n\n    /**\n     * return the shorted path. Multiple paths may exist with the same length\n     * \n     * @return the shorted path\n     */\n    public TransitionPath getShortestPath()\n    {\n        if (getPaths().isEmpty())\n            return null;\n        return getPathsAsSortedList().get(0);\n    }\n\n    /**\n     * @return a list of paths, shortest first\n     */\n    public List<TransitionPath> getPathsAsSortedList()\n    {\n        final LinkedList<TransitionPath> pathList = new LinkedList<TransitionPath>(getPaths());\n        Collections.sort(pathList);\n        return pathList;\n    }\n\n    /**\n     * @return the number of paths available between two states\n     */\n    public int size()\n    {\n        return this.paths.size();\n    }\n    \n    /**\n     * @return true if there are no paths between the two states\n     */\n    public boolean isEmpty()\n    {\n        return size() == 0;\n    }\n\n\n    /**\n     * @return the iterator\n     */\n    @Override\n    public Iterator<TransitionPath> iterator()\n    {\n        return getPathsAsSortedList().iterator();\n    }\n\n    /**\n     * @param names the name(s) of the transition(s) to include\n     * @return a {@link TransitionPaths} object which contains a subset of this paths object which contain the transition identified by the given name \n     */\n    public final TransitionPaths getPathsWithTransitions(final String ... names)\n    {\n        return filterPaths(PathFilters.byNames(names));\n    }\n\n    /**\n     * @name the name of the transition\n     * @return a {@link TransitionPaths} object which contains a subset of this paths object which does NOT contain the transition identified by the given name \n     */\n    public final TransitionPaths getPathsAvoidingTransitions(final String ... names)\n    {\n        final Predicate<TransitionPath> filter = PathFilters.byNames(names); \n        return filterPaths(Predicates.not(filter));\n    }\n    \n    /**\n     * @param filter the filter to apply to child paths\n     * @return a new TransitionPaths object which only contains TransitionPaths which match the given filter \n     */\n    public TransitionPaths filterPaths(final Predicate<TransitionPath> filter)\n    {\n        final TransitionPaths matchingPaths = new TransitionPaths();\n        for (final TransitionPath path : this)\n        {\n            if (filter.apply(path))\n            {\n                matchingPaths.add(path);\n            }\n        }\n        return matchingPaths;\n    }\n    \n    /**\n     * @return a string representation\n     */\n    @Override\n    public String toString()\n    {\n        final String newLine = String.format(""%n"");\n        final StringBuilder b = new StringBuilder();\n        for (final Object path : this.paths)\n        {\n            b.append(path).append(newLine);\n        }\n        return b.toString();\n    }\n    \n}')",[258706]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsReceivedByHeadOfDelivery extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""Received By Head of Delivery"";\n\n    private TransitionClaimsRejectToDeliveryTeam rejectToDeliveryTeam; \n    private TransitionClaimsMarkAsReadyForPayment markAsReadyForPayment; \n    \n    /**\n     * @param fsm\n     */\n    ClaimsReceivedByHeadOfDelivery(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        // Transition reject to delivery team\n        this.rejectToDeliveryTeam = new TransitionClaimsRejectToDeliveryTeam(this, getStateMachine().receivedByDeliveryTeam());\n        allTransitions.add(this.rejectToDeliveryTeam); \n\n        // Transition mark as ready for payment\n        this.markAsReadyForPayment = new TransitionClaimsMarkAsReadyForPayment(this, getStateMachine().readyForPayment());\n        allTransitions.add(this.markAsReadyForPayment); \n\n        return allTransitions;    \n    }\n    \n    /**\n     * execute the reject to delivery team transition\n     * @return true if the transition was successful\n     */\n    public boolean rejectToDeliveryTeam() {\n        this.rejectToDeliveryTeam.execute();\n        return this.rejectToDeliveryTeam.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerRejectToDeliveryTeamListener(final T listener)\n    {\n        return this.rejectToDeliveryTeam.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterRejectToDeliveryTeamListener(final TransitionListener listener)\n    {\n        return this.rejectToDeliveryTeam.unregisterListener(listener);\n    }\n    \n    /**\n     * execute the mark as ready for payment transition\n     * @return true if the transition was successful\n     */\n    public boolean markAsReadyForPayment() {\n        this.markAsReadyForPayment.execute();\n        return this.markAsReadyForPayment.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerMarkAsReadyForPaymentListener(final T listener)\n    {\n        return this.markAsReadyForPayment.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterMarkAsReadyForPaymentListener(final TransitionListener listener)\n    {\n        return this.markAsReadyForPayment.unregisterListener(listener);\n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[264998]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\n/**\n * if you use google collections, refactor to use that instead \n */\npublic enum StateLog\n{\n    ;// uninstantiable\n\n    public static String error(final String format, final Object... args)\n    {\n        final String log = ""_error:"" + String.format(format, args);\n        System.out.println(log);\n        return log;\n    }\n\n    public static String info(final String format, final Object... args)\n    {\n        final String log = ""_info:"" + String.format(format, args);\n        System.out.println(log);\n        return log;\n    }\n\n    public static String debug(final String format, final Object... args)\n    {\n        final String log = ""_debug:"" + String.format(format, args);\n        System.out.println(log);\n        return log;\n    }\n    \n    public static String trace(final String format, final Object... args)\n    {\n        return ""_trace:"" + String.format(format, args);\n    }\n}\n')",[278285]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_asJavaName(com.porpoise.fsm.generator.context.ContextTest)')","[803, 5176, 5920, 22509, 29256, 33373, 33636, 46305, 47145, 65926, 75803, 76048, 87897, 88689, 106374, 115918, 116199, 129688, 130576, 150453, 161477, 161785, 176504, 177464, 198985, 210805, 211131, 226670, 227678, 288231, 288553]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\n/**\n * if you use google collections, refactor to use that instead \n */\npublic enum StateLog\n{\n    ;// uninstantiable\n\n    public static String error(final String format, final Object... args)\n    {\n        final String log = ""_error:"" + String.format(format, args);\n        System.out.println(log);\n        return log;\n    }\n\n    public static String info(final String format, final Object... args)\n    {\n        final String log = ""_info:"" + String.format(format, args);\n        System.out.println(log);\n        return log;\n    }\n\n    public static String debug(final String format, final Object... args)\n    {\n        final String log = ""_debug:"" + String.format(format, args);\n        System.out.println(log);\n        return log;\n    }\n    \n    public static String trace(final String format, final Object... args)\n    {\n        return ""_trace:"" + String.format(format, args);\n    }\n}\n')",[254923]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'aaron.test.test.ClaimsReceivedByDeliveryTeamTest')","[306913, 306936, 306960, 306983]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * <p>\n * state transitions are checked using guard conditions. There may be state exit conditions, transition conditions, and state enter\n * conditions. Each of these conditions will return a {@link TransitionGuard}, signaling if the state transition should be allowed to continue.\n * If all guards allow the transition to continue, then a state transition will take place. However, a guard condition may signal that the\n * state transition should not continue, either stopping immediately or stop once the remaining transition listeners are notified.\n * </p>\n * <p>\n * In addition to controlling the state transitions, a transition guard may also specify a \'reason\' should the guard not allow processing.\n * The reason can be a generic {@link Enum} type. If no reason is given then {@link #getReason()} will return\n * {@link Reasons#NO_REASON_GIVEN}.\n * </p>\n */\npublic class TransitionGuard\n{\n    /**\n     * Default \'stop\' Reasons\n     */\n    public enum Reasons\n    {\n        NO_REASON_GIVEN,//\n        ALREADY_IN_TARGET_STATE, // \n        TARGET_STATE_UNREACHABLE;\n    }\n\n    /**\n     * This enumeration allows listeners to notify the state machine whether or not it should continue processing. Using this mechanism we\n     * avoid listeners having to throw exceptions for process flow.\n     */\n    public enum Type\n    {\n        /**\n        *\n        */\n        CONTINUE\n        {\n            @Override\n            boolean continueProcessingInternal()\n            {\n                return true;\n            }\n\n            @Override\n            boolean stopInternal()\n            {\n                return false;\n            }\n        }, //\n        /**\n        *\n        */\n        STOP_IMMEDIATELY\n        {\n            @Override\n            boolean continueProcessingInternal()\n            {\n                return false;\n            }\n\n            @Override\n            boolean stopInternal()\n            {\n                return true;\n            }\n        }, //\n        /**\n        *\n        */\n        STOP_AFTER_PROCESSING_REMAINING_LISTENERS\n        {\n            @Override\n            boolean continueProcessingInternal()\n            {\n                return false;\n            }\n\n            @Override\n            boolean stopInternal()\n            {\n                return false;\n            }\n        }\n\n        ;//\n\n        abstract boolean continueProcessingInternal();\n\n        boolean continueProcessing()\n        {\n            final boolean result = continueProcessingInternal();\n            if (!result)\n            {\n                StateLog.trace(""asked to stop eventually"");\n            }\n            return result;\n        }\n\n        abstract boolean stopInternal();\n\n        boolean stop()\n        {\n            final boolean result = stopInternal();\n            if (result)\n            {\n                StateLog.trace(""asked to stop immediately"");\n            }\n            return result;\n        }\n    }\n\n    private final Type    type;\n    private final Enum<?> reason;\n\n    /**\n     * @return the type\n     */\n    public Type getType()\n    {\n        return this.type;\n    }\n\n    /**\n     * @return the reason, or {@link Reasons#NO_REASON_GIVEN} if no reason was specified\n     */\n    public Enum<?> getReason()\n    {\n        return this.reason == null ? Reasons.NO_REASON_GIVEN : this.reason;\n    }\n    \n    /**\n     * @return the reason as a collection\n     */\n    final  Collection<Enum<?>> getReasons()\n    {\n        if (this.reason == null)\n        {\n            return Collections.emptyList();\n        }\n        final Collection<Enum<?>> reasons = new ArrayList<Enum<?>>();\n        reasons.add(getReason());\n        return reasons;\n    }\n    public TransitionGuard(final Type t, final Enum<?> reasonValue)\n    {\n        this.type = t;\n        this.reason = reasonValue;\n    }\n\n    /**\n     * return a collection of reasons given for any stopping guards given.\n     * If all guards are of type \'continue\' then an empty collection is returned. \n     * @return a collection of reason enumerations for the given guards\n     */\n    static Collection<Enum<?>> filterReasons(final TransitionGuard... guards)\n    {\n        Collection<Enum<?>> reasons = null;\n        for (final TransitionGuard guard : guards)\n        {\n            if (!guard.continueProcessing())\n            {\n                if (reasons == null)\n                {\n                    reasons = new ArrayList<Enum<?>>();\n                }\n                reasons.add(guard.getReason());\n            }\n        }\n        if (reasons == null)\n        {\n            reasons = Collections.emptyList();\n        }\n\n        return reasons;\n    }\n\n    private static final TransitionGuard GUARD_CONTINUE         = new TransitionGuard(Type.CONTINUE, null);\n    private static final TransitionGuard GUARD_STOP_IMMIDIATELY = new TransitionGuard(Type.STOP_IMMEDIATELY, null);\n    private static final TransitionGuard GUARD_STOP_EVENTUALLY  = new TransitionGuard(Type.STOP_AFTER_PROCESSING_REMAINING_LISTENERS, null);\n\n    /**\n     * @return true if the transition should stop\n     */\n    public boolean stop()\n    {\n        return this.type.stop();\n    }\n\n    /**\n     * @return true if the transition should continue\n     */\n    public boolean continueProcessing()\n    {\n        return this.type.continueProcessing();\n    }\n\n    /**\n     * @return a generic \'continue\' transition guard\n     */\n    public static TransitionGuard ok()\n    {\n        return GUARD_CONTINUE;\n    }\n\n    /**\n     * @return a generic stop immediately transition guard\n     */\n    public static TransitionGuard stopImmediately()\n    {\n        return GUARD_STOP_IMMIDIATELY;\n    }\n\n    /**\n     * @param reason\n     * @return a generic stop eventually transition guard\n     */\n    public static TransitionGuard stopImmediately(final Enum<?> stopReason)\n    {\n        return new TransitionGuard(Type.STOP_IMMEDIATELY, stopReason);\n    }\n\n    /**\n     * @return a generic stop eventually transition guard\n     */\n    public static TransitionGuard stopEventually()\n    {\n        return GUARD_STOP_EVENTUALLY;\n    }\n\n    /**\n     * @param reason\n     * @return a generic stop eventually transition guard\n     */\n    public static TransitionGuard stopEventually(final Enum<?> stopReason)\n    {\n        return new TransitionGuard(Type.STOP_AFTER_PROCESSING_REMAINING_LISTENERS, stopReason);\n    }\n    \n    /**\n     * @return the string representation\n     */\n    @Override\n    public String toString()\n    {\n        return String.format(""%s [%s]"", this.type, this.reason);\n    }\n}\n')",[281452]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'com.porpoise.fsm.model.StateTest')","[251698, 251721, 251745, 251768]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsPaymentReceived\n */\npublic class ClaimsPaymentReceivedTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the \'ClaimsPaymentReceived\' state\n     */\n    @Test\n    public void test_executeToClaimsPaymentReceived()\n    {\n        Assert.assertNotNull(moveToClaimsPaymentReceived());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for \'paymentReceived\' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.paymentReceived().getName();\n        Assert.assertEquals(fsm.paymentReceived(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the paymentReceived state\n     */\n    final ClaimsPaymentReceived moveToClaimsPaymentReceived()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsPaymentReceived paymentReceived = fsm.paymentReceived();\n\n        // call the method under test\n        fsm.executeToState(paymentReceived);\n\n        Assert.assertSame(paymentReceived, fsm.getCurrentState());\n        Assert.assertEquals(paymentReceived.getName(), fsm.getCurrentStateName());\n        \n        return paymentReceived;\n    }\n\n    \n    @Test\n    public void test_getPathBetweenClaimsPaymentReceivedAndClaimsPaymentComplete()\n    {\n\n        final ClaimsPaymentReceived paymentReceived = moveToClaimsPaymentReceived();\n        final ClaimsStateMachine fsm = paymentReceived.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'paymentReceived\'"", paymentReceived, fsm.getCurrentState());\n\n        final TransitionPaths paths = paymentReceived.getPaths(fsm.paymentComplete());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        paymentReceived.registerMarkPaymentAsCompleteListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'paymentReceived\'"", paymentReceived, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.paymentComplete(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'markPaymentAsComplete\' transition \n     */\n    @Test\n    public void test_markPaymentAsComplete()\n    {\n        final ClaimsPaymentReceived paymentReceived = moveToClaimsPaymentReceived();\n        final ClaimsStateMachine fsm = paymentReceived.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        paymentReceived.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        paymentReceived.markPaymentAsComplete();\n\n        //\n        // assert the current state is now ClaimsPaymentComplete\n        //\n        Assert.assertEquals(fsm.paymentComplete(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.paymentComplete().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsMarkPaymentAsComplete.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsMarkPaymentAsComplete.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(paymentReceived.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsPaymentReceived\' can be moved into the ClaimsPaymentComplete state\n     */\n    @Test\n    public void test_moveToClaimsPaymentComplete()\n    {\n        final ClaimsPaymentReceived paymentReceived = moveToClaimsPaymentReceived();\n        final ClaimsStateMachine fsm = paymentReceived.getStateMachine();\n        paymentReceived.getPaths(fsm.paymentComplete());\n        \n    }\n}\n')",[273240]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsApproveForHod extends AbstractTransition<ClaimsReceivedByDeliveryTeam, ClaimsReceivedByHeadOfDelivery>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""approve for hod"";\n\n    TransitionClaimsApproveForHod(final ClaimsReceivedByDeliveryTeam from, final ClaimsReceivedByHeadOfDelivery to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[267460]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsReceivedByMonitoringOfficer extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""Received By Monitoring Officer"";\n\n    private TransitionClaimsApproveForDeliveryTeam approveForDeliveryTeam; \n    private TransitionClaimsApproveForHeadOfDelivery approveForHeadOfDelivery; \n    private TransitionClaimsRejectToParticipant rejectToParticipant; \n    \n    /**\n     * @param fsm\n     */\n    ClaimsReceivedByMonitoringOfficer(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        // Transition approve for delivery team\n        this.approveForDeliveryTeam = new TransitionClaimsApproveForDeliveryTeam(this, getStateMachine().receivedByDeliveryTeam());\n        allTransitions.add(this.approveForDeliveryTeam); \n\n        // Transition approve for head of delivery\n        this.approveForHeadOfDelivery = new TransitionClaimsApproveForHeadOfDelivery(this, getStateMachine().receivedByHeadOfDelivery());\n        allTransitions.add(this.approveForHeadOfDelivery); \n\n        // Transition reject to participant\n        this.rejectToParticipant = new TransitionClaimsRejectToParticipant(this, getStateMachine().notReceived());\n        allTransitions.add(this.rejectToParticipant); \n\n        return allTransitions;    \n    }\n    \n    /**\n     * execute the approve for delivery team transition\n     * @return true if the transition was successful\n     */\n    public boolean approveForDeliveryTeam() {\n        this.approveForDeliveryTeam.execute();\n        return this.approveForDeliveryTeam.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerApproveForDeliveryTeamListener(final T listener)\n    {\n        return this.approveForDeliveryTeam.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterApproveForDeliveryTeamListener(final TransitionListener listener)\n    {\n        return this.approveForDeliveryTeam.unregisterListener(listener);\n    }\n    \n    /**\n     * execute the approve for head of delivery transition\n     * @return true if the transition was successful\n     */\n    public boolean approveForHeadOfDelivery() {\n        this.approveForHeadOfDelivery.execute();\n        return this.approveForHeadOfDelivery.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerApproveForHeadOfDeliveryListener(final T listener)\n    {\n        return this.approveForHeadOfDelivery.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterApproveForHeadOfDeliveryListener(final TransitionListener listener)\n    {\n        return this.approveForHeadOfDelivery.unregisterListener(listener);\n    }\n    \n    /**\n     * execute the reject to participant transition\n     * @return true if the transition was successful\n     */\n    public boolean rejectToParticipant() {\n        this.rejectToParticipant.execute();\n        return this.rejectToParticipant.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerRejectToParticipantListener(final T listener)\n    {\n        return this.rejectToParticipant.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterRejectToParticipantListener(final TransitionListener listener)\n    {\n        return this.rejectToParticipant.unregisterListener(listener);\n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[268437]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsRejectToDeliveryTeam extends AbstractTransition<ClaimsReceivedByHeadOfDelivery, ClaimsReceivedByDeliveryTeam>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""reject to delivery team"";\n\n    TransitionClaimsRejectToDeliveryTeam(final ClaimsReceivedByHeadOfDelivery from, final ClaimsReceivedByDeliveryTeam to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[265104]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'class one class two enum three')",[288168]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport com.google.common.base.Predicate;\n\n/**\n * a listener which can be turned on and off by the given predicate\n */\npublic class ConditionalStateListener extends AbstractConditionalStateListener \n{\n    private final StateListener wrappedListener;\n\n    /**\n     * @param predicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener will be executed.\n     * @param listener\n     */\n    public ConditionalStateListener(final Predicate<Transition> predicate, final StateListener listener)\n    {\n        this(predicate, predicate, listener);\n    }\n\n    /**\n     * @param enterPredicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener\'s onEnter will be executed.\n     * @param exitPredicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener\'s onExit method will be executed.\n     * @param predicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener will be executed.\n     * @param listener\n     */\n    public ConditionalStateListener(final Predicate<Transition> enterPredicate, final Predicate<Transition> exitPredicate, final StateListener listener)\n    {\n        this(enterPredicate, exitPredicate, listener, TransitionGuard.ok(), TransitionGuard.ok());\n    }\n\n    /**\n     * @param enterPredicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener\'s onEnter will be executed.\n     * @param exitPredicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener\'s onExit method will be executed.\n     * @param predicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener will be executed.\n     * @param listener\n     * @param enterDefault the transition to return should the enter predicate filter return false\n     * @param exitDefault the transition to return should the exit predicate filter return false\n     */\n    public ConditionalStateListener(final Predicate<Transition> enterPredicate, final Predicate<Transition> exitPredicate, final StateListener listener, final TransitionGuard enterDefault, final TransitionGuard exitDefault)\n    {\n        super(enterPredicate, exitPredicate, exitDefault, exitDefault);\n        if (listener == null)\n        {\n            throw new NullPointerException(""listener cannot be null"");\n        }\n        this.wrappedListener = listener;\n    }\n   \n    /**\n     * @param transition\n     * @return the transition return value.  \n     */\n    @Override\n    protected TransitionGuard onExitInternal(final Transition transition)\n    {\n        return this.wrappedListener.onExit(transition);\n    }\n\n    /**\n     * @param transition\n     * @return the transition return value.  \n     */\n    @Override\n    protected TransitionGuard onEnterInternal(final Transition transition)\n    {\n        return this.wrappedListener.onEnter(transition);\n    }\n}\n')",[256237]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\n\n/**\n * A holder for \'paths\' -- chains of transitions through the state machine\n */\npublic final class TransitionPaths implements Iterable<TransitionPath>\n{\n    private final Collection<TransitionPath> paths;\n\n    TransitionPaths()\n    {\n        this.paths = new ArrayList<TransitionPath>();\n    }\n\n    boolean add(final TransitionPath path)\n    {\n        if (!this.paths.contains(path))\n        {\n            return this.paths.add(path);\n        }\n        return false;\n    }\n \n    /** \n     * @return the paths\n     */\n    public Collection<TransitionPath> getPaths()\n    {\n        return Collections.unmodifiableCollection(this.paths);\n    }\n\n    /** \n     * get the path at index i\n     */\n    public TransitionPath getPath(final int i)\n    {\n        if (i < 0 || i > getPaths().size())\n        {\n            return null;\n        }\n        int index = 0;\n        for (final TransitionPath path : getPaths())\n        {\n            if (index == i)\n                return path;\n            index++;\n        }\n        return null;\n    }\n\n    /**\n     * return the shorted path. Multiple paths may exist with the same length\n     * \n     * @return the shorted path\n     */\n    public TransitionPath getShortestPath()\n    {\n        if (getPaths().isEmpty())\n            return null;\n        return getPathsAsSortedList().get(0);\n    }\n\n    /**\n     * @return a list of paths, shortest first\n     */\n    public List<TransitionPath> getPathsAsSortedList()\n    {\n        final LinkedList<TransitionPath> pathList = new LinkedList<TransitionPath>(getPaths());\n        Collections.sort(pathList);\n        return pathList;\n    }\n\n    /**\n     * @return the number of paths available between two states\n     */\n    public int size()\n    {\n        return this.paths.size();\n    }\n    \n    /**\n     * @return true if there are no paths between the two states\n     */\n    public boolean isEmpty()\n    {\n        return size() == 0;\n    }\n\n\n    /**\n     * @return the iterator\n     */\n    @Override\n    public Iterator<TransitionPath> iterator()\n    {\n        return getPathsAsSortedList().iterator();\n    }\n\n    /**\n     * @param names the name(s) of the transition(s) to include\n     * @return a {@link TransitionPaths} object which contains a subset of this paths object which contain the transition identified by the given name \n     */\n    public final TransitionPaths getPathsWithTransitions(final String ... names)\n    {\n        return filterPaths(PathFilters.byNames(names));\n    }\n\n    /**\n     * @name the name of the transition\n     * @return a {@link TransitionPaths} object which contains a subset of this paths object which does NOT contain the transition identified by the given name \n     */\n    public final TransitionPaths getPathsAvoidingTransitions(final String ... names)\n    {\n        final Predicate<TransitionPath> filter = PathFilters.byNames(names); \n        return filterPaths(Predicates.not(filter));\n    }\n    \n    /**\n     * @param filter the filter to apply to child paths\n     * @return a new TransitionPaths object which only contains TransitionPaths which match the given filter \n     */\n    public TransitionPaths filterPaths(final Predicate<TransitionPath> filter)\n    {\n        final TransitionPaths matchingPaths = new TransitionPaths();\n        for (final TransitionPath path : this)\n        {\n            if (filter.apply(path))\n            {\n                matchingPaths.add(path);\n            }\n        }\n        return matchingPaths;\n    }\n    \n    /**\n     * @return a string representation\n     */\n    @Override\n    public String toString()\n    {\n        final String newLine = String.format(""%n"");\n        final StringBuilder b = new StringBuilder();\n        for (final Object path : this.paths)\n        {\n            b.append(path).append(newLine);\n        }\n        return b.toString();\n    }\n    \n}')",[281637]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getStateForName(aaron.test.test.ClaimsReceivedByHeadOfDeliveryTest)')","[1412, 1436, 1460, 12523, 12554, 12585, 15871, 15902, 15933, 25797, 25821, 25845, 30090, 38168, 38198, 38228, 39149, 39177, 39205, 54600, 54635, 54670, 58380, 58415, 58450, 69762, 69790, 69818, 80274, 80302, 80330, 81189, 81215, 81241, 95718, 95751, 95784, 99282, 99315, 99348, 109936, 109962, 109988, 121037, 121069, 121101, 122084, 122114, 122144, 138457, 138494, 138531, 142453, 142490, 142527, 154563, 154593, 154623, 167082, 167117, 167152, 168228, 168261, 168294, 185984, 186024, 186064, 190304, 190344, 190384, 203506, 203539, 203572, 216734, 216771, 216808, 217946, 217981, 218016, 236624, 236666, 236708, 241160, 241202, 241244, 299893, 299933, 299973, 301177, 301219, 301261]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\n/**\n * tests for ClaimsStateMachine\n */\npublic class ListenerAdapter implements StateListener \n{\n    private TransitionGuard entranceGuard;\n    private TransitionGuard exitGuard;\n\n    /**\n     * Default Constructor\n     */\n    public ListenerAdapter()\n    {\n        this(TransitionGuard.ok(), TransitionGuard.ok());\n    }\n\n    /**\n     * @param entrance the entrance guard\n     * @param exit the exit guard\n     */\n    public ListenerAdapter(final TransitionGuard entrance, final TransitionGuard exit)\n    {\n        if (entrance == null)\n        {\n            throw new NullPointerException(""entrance guard type cannot be null"");\n        }\n        if (exit == null)\n        {\n            throw new NullPointerException(""exit guard type cannot be null"");\n        }\n        this.entranceGuard = entrance;\n        this.exitGuard = exit;\n    }\n\n    /**\n     * @param transition\n     * @return \'continue\'\n     */\n    public TransitionGuard onExit(final Transition transition)\n    {\n        return this.exitGuard;\n    }\n\n    /**\n     * @param transition\n     * @return \'continue\'\n     */\n    public TransitionGuard onEnter(final Transition transition)\n    {\n        return this.entranceGuard;\n    }\n}\n')",[260458]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport com.google.common.base.Predicate;\n\n/**\n * A collection of useful implementations of StateListener\n */\npublic enum StateListeners \n{\n    ;//uninstantiable\n    \n    static class BlockEntryListener extends ListenerAdapter\n    {\n        private final Enum<?> reason;\n        public BlockEntryListener(final Enum<?> reason)\n        {\n            super(TransitionGuard.stopEventually(reason), TransitionGuard.ok());\n            this.reason = reason;\n        }\n        public BlockEntryListener()\n        {\n            this(null);\n        }\n\n        @Override\n        public String toString()\n        {\n            return String.format(""block entry (reason=%s)"", this.reason);\n        }\n    }\n\n    static class BlockExitListener extends ListenerAdapter\n    {\n        private final Enum<?> reason;\n        public BlockExitListener(final Enum<?> reason)\n        {\n            super(TransitionGuard.ok(), TransitionGuard.stopEventually(reason));\n            this.reason = reason;\n        }\n        public BlockExitListener()\n        {\n            this(null);\n        }\n\n        @Override\n        public String toString()\n        {\n            return String.format(""block exit (reason=%s)"", this.reason);\n        }\n    }\n\n    /**\n     */\n    public static RecordingListener recordingListener()\n    {\n        return new RecordingListener();\n    }\n\n    /**\n     * a listener which records the transitions\n     */\n    public static class RecordingListener extends ListenerAdapter\n    {\n        private final List<Transition> enterTransitions = new ArrayList<Transition>();\n        private final List<Transition> exitTransitions  = new ArrayList<Transition>();\n\n        @Override\n        public TransitionGuard onExit(final Transition transition)\n        {\n            this.exitTransitions.add(transition);\n            return TransitionGuard.ok();\n        }\n\n        @Override\n        public TransitionGuard onEnter(final Transition transition)\n        {\n            this.enterTransitions.add(transition);\n            return TransitionGuard.ok();\n        }\n\n        /**\n         * @return the exit transitions\n         */\n        public List<Transition> getExitTransitions()\n        {\n            return Collections.unmodifiableList(this.exitTransitions);\n        }\n\n        /**\n         * @return the enter transitions\n         */\n        public List<Transition> getEnterTransitions()\n        {\n            return Collections.unmodifiableList(this.enterTransitions);\n        }\n\n        @Override\n        public String toString()\n        {\n            return ""recording listener"";\n        }\n    }\n\n    /**\n     */\n    public static class EchoListener extends ListenerAdapter\n    {\n        private final PrintStream out;\n\n        public EchoListener(final PrintStream outStream)\n        {\n            if (outStream == null)\n            {\n                throw new NullPointerException();\n            }\n            this.out = outStream;\n        }\n\n        @Override\n        public TransitionGuard onEnter(final Transition transition)\n        {\n            this.out.println(String.format(""enter \'%s\' via \'%s\'"", transition.getTarget().getName(), transition.getName()));\n            return TransitionGuard.ok();\n        }\n\n        @Override\n        public TransitionGuard onExit(final Transition transition)\n        {\n            this.out.println(String.format(""exit \'%s\' via \'%s\'"", transition.getSource().getName(), transition.getName()));\n            return TransitionGuard.ok();\n        }\n        @Override\n        public String toString()\n        {\n            return ""echo listener"";\n        }\n    }\n\n    public static EchoListener echoListener(final PrintStream out)\n    {\n        return new EchoListener(out);\n    }\n\n    /**\n     * @return the registered listener\n     */\n    public static StateListener blockEntryListener()\n    {\n        return blockEntryListener(null);\n    }\n\n    /**\n     * @return the registered listener\n     */\n    public static StateListener blockEntryListener(final Enum<?> reason)\n    {\n        return new BlockEntryListener(reason);\n    }\n\n    /**\n     * @return the listener\n     */\n    public static StateListener blockExitListener()\n    {\n        return blockExitListener(null);\n    }\n\n    /**\n     * @return the listener\n     */\n    public static StateListener blockExitListener(final Enum<?> reason)\n    {\n        return new BlockExitListener(reason);\n    }\n\n    /**\n     * @param state\n     *            the state to match\n     * @return a predicate which will return true for transitions whos target state matches the given state\n     */\n    public static Predicate<Transition> targetStateEquals(final State state)\n    {\n        if (state == null)\n        {\n            throw new NullPointerException(""state cannot be null"");\n        }\n        return new Predicate<Transition>() {\n\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return value.getTarget().equals(state);\n            }\n        };\n    }\n\n    /**\n     * @param state\n     *            the state to match\n     * @return a predicate which will return true for transitions whos source state matches the given state\n     */\n    public static Predicate<Transition> sourceStateEquals(final State state)\n    {\n        if (state == null)\n        {\n            throw new NullPointerException(""state cannot be null"");\n        }\n        return new Predicate<Transition>() {\n\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return value.getSource().equals(state);\n            }\n        };\n    }\n\n    /**\n     * @param the reason\n     * @return the registered listener\n     */\n    public static StateListener blockEntry(final State state, final Enum<?> reason)\n    {\n        final StateListener listener = filter(targetStateEquals(state), blockEntryListener(reason));\n        return listener;\n    }\n\n    /**\n     * @param the reason\n     * @return the registered listener\n     */\n    public static StateListener blockExit(final State state, final Enum<?> reason)\n    {\n        final StateListener listener = filter(sourceStateEquals(state), blockExitListener(reason));\n        return listener;\n    }\n\n    /**\n     * @param filter\n     *            the filter to apply to the given listener\n     * @param listener\n     *            the listener to wrap\n     * @return the wrapped listener\n     */\n    public static ConditionalStateListener filter(final Predicate<Transition> filter, final StateListener listener)\n    {\n        return new ConditionalStateListener(filter, listener);\n    }\n\n    /**\n     * @param listeners\n     *            the listeners to treat as a single group\n     * @return the grouped listener\n     */\n    public static GroupStateListener group(final StateListener... listeners)\n    {\n        return new GroupStateListener(listeners);\n    }\n\n    /**\n     * @param listeners\n     *            the listeners to treat as a single group\n     * @return the group listener which you can turn on and off\n     */\n    public static ConditionalStateListener group(final Predicate<Transition> predicate, final StateListener... listeners)\n    {\n        return filter(predicate, group(listeners));\n    }\n }')",[284736]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsPaymentRejected\n */\npublic class ClaimsPaymentRejectedTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the \'ClaimsPaymentRejected\' state\n     */\n    @Test\n    public void test_executeToClaimsPaymentRejected()\n    {\n        Assert.assertNotNull(moveToClaimsPaymentRejected());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for \'paymentRejected\' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.paymentRejected().getName();\n        Assert.assertEquals(fsm.paymentRejected(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the paymentRejected state\n     */\n    final ClaimsPaymentRejected moveToClaimsPaymentRejected()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsPaymentRejected paymentRejected = fsm.paymentRejected();\n\n        // call the method under test\n        fsm.executeToState(paymentRejected);\n\n        Assert.assertSame(paymentRejected, fsm.getCurrentState());\n        Assert.assertEquals(paymentRejected.getName(), fsm.getCurrentStateName());\n        \n        return paymentRejected;\n    }\n\n    \n    @Test\n    public void test_getPathBetweenClaimsPaymentRejectedAndClaimsReadyForPayment()\n    {\n\n        final ClaimsPaymentRejected paymentRejected = moveToClaimsPaymentRejected();\n        final ClaimsStateMachine fsm = paymentRejected.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'paymentRejected\'"", paymentRejected, fsm.getCurrentState());\n\n        final TransitionPaths paths = paymentRejected.getPaths(fsm.readyForPayment());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        paymentRejected.registerResubmitForPaymentListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'paymentRejected\'"", paymentRejected, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.readyForPayment(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'resubmitForPayment\' transition \n     */\n    @Test\n    public void test_resubmitForPayment()\n    {\n        final ClaimsPaymentRejected paymentRejected = moveToClaimsPaymentRejected();\n        final ClaimsStateMachine fsm = paymentRejected.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        paymentRejected.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        paymentRejected.resubmitForPayment();\n\n        //\n        // assert the current state is now ClaimsReadyForPayment\n        //\n        Assert.assertEquals(fsm.readyForPayment(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.readyForPayment().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsResubmitForPayment.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsResubmitForPayment.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(paymentRejected.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsPaymentRejected\' can be moved into the ClaimsReadyForPayment state\n     */\n    @Test\n    public void test_moveToClaimsReadyForPayment()\n    {\n        final ClaimsPaymentRejected paymentRejected = moveToClaimsPaymentRejected();\n        final ClaimsStateMachine fsm = paymentRejected.getStateMachine();\n        paymentRejected.getPaths(fsm.readyForPayment());\n        \n    }\n}\n')",[269737]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'com.porpoise.fsm.model.StateTest')","[311, 32220, 74730, 114685, 160124, 209372]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsSubmitToDeliveryTeam extends AbstractTransition<ClaimsNotReceived, ClaimsReceivedByDeliveryTeam>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""submit to delivery team"";\n\n    TransitionClaimsSubmitToDeliveryTeam(final ClaimsNotReceived from, final ClaimsReceivedByDeliveryTeam to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[266177]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getStateForName(aaron.test.test.ClaimsReadyForPaymentTest)')","[1154, 7780, 11500, 23949, 29631, 35584, 36567, 49245, 53445, 67606, 77864, 78781, 90669, 94629, 107934, 118279, 119328, 132796, 137236, 152253, 164063, 165211, 179864, 184664, 200965, 213541, 214755, 230198, 235238, 293433, 294715]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\n\n/**\n * A collection of useful implementations of TransitionListener\n */\npublic enum TransitionListeners \n{\n    ;//uninstantiable\n\n    /**\n     * a listener which records the transitions\n     */\n    public static class RecordingTransitionListener implements TransitionListener\n    {\n        private final List<Transition> transitions = new ArrayList<Transition>();\n\n        @Override\n        public TransitionGuard onTransition(final Transition transition)\n        {\n            this.transitions.add(transition);\n            return TransitionGuard.ok();\n        }\n\n        /**\n         * @return the enter transitions\n         */\n        public List<Transition> getTransitions()\n        {\n            return Collections.unmodifiableList(this.transitions);\n        }\n    }\n    \n    private static class BlockingListener implements TransitionListener\n    {\n        private final Enum<?> reason;\n        public BlockingListener(final Enum<?> reasonValue)\n        {\n            this.reason = reasonValue;\n        }\n    \n        @Override\n        public TransitionGuard onTransition(final Transition transition)\n        {\n            return TransitionGuard.stopEventually(this.reason);\n        }\n    }\n    \n    private static TransitionListener BLOCKING_INSTANCE = new BlockingListener(null); \n\n    /**\n     * @return a new recording transition listener\n     */\n    public static RecordingTransitionListener recordingListener()\n    {\n        return new RecordingTransitionListener();\n    }\n    /**\n     * @return a listener which returns @{code TransitionGuard.stopEventually()}\n     */\n    public static TransitionListener blockingListener()\n    {\n        return BLOCKING_INSTANCE;\n    }\n    /**\n     * @return a listener which returns @{code TransitionGuard.stopEventually()}\n     */\n    public static TransitionListener blockingListener(final Enum<?> reason)\n    {\n        return new BlockingListener(reason);\n    }\n    \n    /**\n     * @return a listener which disallows transitions when the given condition returns false\n     */\n    public static TransitionListener blockOnFalse(final Predicate<Transition> condition, final Enum<?> reason)\n    {\n        final TransitionListener delegate = TransitionListeners.blockingListener(reason);\n        final TransitionListener listener = filter(condition, delegate);\n        return listener;\n    }\n\n    /**\n     * @param condition\n     *            the condition (predicate) used to evaluate whether or not the given listener should be invoked\n     * @param delegate\n     *            the listener to invoke when the condition returns true\n     * @return the conditional listener which wraps the given listener\n     */\n    public static ConditionalTransitionListener filter(final Predicate<Transition> condition, final TransitionListener delegate)\n    {\n        final ConditionalTransitionListener listener = new ConditionalTransitionListener(condition, delegate);\n        return listener;\n    }    \n    /**\n     * @return a listener which disallows transitions when the given condition returns true\n     */\n    public static TransitionListener blockOnTrue(final Predicate<Transition> condition, final Enum<?> reason)\n    {\n        return blockOnFalse(Predicates.not(condition), reason);\n    }\n\n }')",[278553]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport com.google.common.base.Predicate;\n\n/**\n * A PredicateToggle provides a means for toggling a {@link Predicate}\n */\npublic final class PredicateToggle\n{\n    private final AtomicBoolean     enabled;\n    private final Predicate<Object> predicate;\n\n    private PredicateToggle(final boolean firstValue)\n    {\n        this.enabled = new AtomicBoolean(firstValue);\n        this.predicate = new Predicate<Object>() {\n            @Override\n            public boolean apply(final Object value)\n            {\n                return isEnabled();\n            }\n\n            @Override\n            public String toString()\n            {\n                return String.format(""Toggle %b"", Boolean.valueOf(isEnabled()));\n            }\n        };\n    }\n\n    /**\n     * @return a new enabled toggle\n     */\n    public static PredicateToggle on()\n    {\n        return new PredicateToggle(true);\n    }\n\n    /**\n     * @return a new disabled toggle\n     */\n    public static PredicateToggle off()\n    {\n        return new PredicateToggle(false);\n    }\n\n    /**\n     * enable the toggle\n     * \n     * @return true if this method call changed the toggle value\n     */\n    public boolean enable()\n    {\n        return this.enabled.compareAndSet(false, true);\n    }\n\n    /**\n     * disable the toggle\n     * \n     * @return true if this method call changed the toggle value\n     */\n    public boolean disable()\n    {\n        return this.enabled.compareAndSet(true, false);\n    }\n\n    /**\n     * switch the toggle value - going from off to on or from on to off.\n     */\n    public void toggle()\n    {\n        this.enabled.set(!isEnabled());\n    }\n\n    /**\n     * @return true if the toggle is currently enabled\n     */\n    public boolean isEnabled()\n    {\n        return this.enabled.get();\n    }\n\n    /**\n     * @return a transition filter representing the current state of the toggle\n     */\n    @SuppressWarnings(""unchecked"")\n    public <T> Predicate<T> predicate()\n    {\n        return (Predicate<T>) this.predicate;\n    }\n}\n')",[280618]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * <p>\n * state transitions are checked using guard conditions. There may be state exit conditions, transition conditions, and state enter\n * conditions. Each of these conditions will return a {@link TransitionGuard}, signaling if the state transition should be allowed to continue.\n * If all guards allow the transition to continue, then a state transition will take place. However, a guard condition may signal that the\n * state transition should not continue, either stopping immediately or stop once the remaining transition listeners are notified.\n * </p>\n * <p>\n * In addition to controlling the state transitions, a transition guard may also specify a \'reason\' should the guard not allow processing.\n * The reason can be a generic {@link Enum} type. If no reason is given then {@link #getReason()} will return\n * {@link Reasons#NO_REASON_GIVEN}.\n * </p>\n */\npublic class TransitionGuard\n{\n    /**\n     * Default \'stop\' Reasons\n     */\n    public enum Reasons\n    {\n        NO_REASON_GIVEN,//\n        ALREADY_IN_TARGET_STATE, // \n        TARGET_STATE_UNREACHABLE;\n    }\n\n    /**\n     * This enumeration allows listeners to notify the state machine whether or not it should continue processing. Using this mechanism we\n     * avoid listeners having to throw exceptions for process flow.\n     */\n    public enum Type\n    {\n        /**\n        *\n        */\n        CONTINUE\n        {\n            @Override\n            boolean continueProcessingInternal()\n            {\n                return true;\n            }\n\n            @Override\n            boolean stopInternal()\n            {\n                return false;\n            }\n        }, //\n        /**\n        *\n        */\n        STOP_IMMEDIATELY\n        {\n            @Override\n            boolean continueProcessingInternal()\n            {\n                return false;\n            }\n\n            @Override\n            boolean stopInternal()\n            {\n                return true;\n            }\n        }, //\n        /**\n        *\n        */\n        STOP_AFTER_PROCESSING_REMAINING_LISTENERS\n        {\n            @Override\n            boolean continueProcessingInternal()\n            {\n                return false;\n            }\n\n            @Override\n            boolean stopInternal()\n            {\n                return false;\n            }\n        }\n\n        ;//\n\n        abstract boolean continueProcessingInternal();\n\n        boolean continueProcessing()\n        {\n            final boolean result = continueProcessingInternal();\n            if (!result)\n            {\n                StateLog.trace(""asked to stop eventually"");\n            }\n            return result;\n        }\n\n        abstract boolean stopInternal();\n\n        boolean stop()\n        {\n            final boolean result = stopInternal();\n            if (result)\n            {\n                StateLog.trace(""asked to stop immediately"");\n            }\n            return result;\n        }\n    }\n\n    private final Type    type;\n    private final Enum<?> reason;\n\n    /**\n     * @return the type\n     */\n    public Type getType()\n    {\n        return this.type;\n    }\n\n    /**\n     * @return the reason, or {@link Reasons#NO_REASON_GIVEN} if no reason was specified\n     */\n    public Enum<?> getReason()\n    {\n        return this.reason == null ? Reasons.NO_REASON_GIVEN : this.reason;\n    }\n    \n    /**\n     * @return the reason as a collection\n     */\n    final  Collection<Enum<?>> getReasons()\n    {\n        if (this.reason == null)\n        {\n            return Collections.emptyList();\n        }\n        final Collection<Enum<?>> reasons = new ArrayList<Enum<?>>();\n        reasons.add(getReason());\n        return reasons;\n    }\n    public TransitionGuard(final Type t, final Enum<?> reasonValue)\n    {\n        this.type = t;\n        this.reason = reasonValue;\n    }\n\n    /**\n     * return a collection of reasons given for any stopping guards given.\n     * If all guards are of type \'continue\' then an empty collection is returned. \n     * @return a collection of reason enumerations for the given guards\n     */\n    static Collection<Enum<?>> filterReasons(final TransitionGuard... guards)\n    {\n        Collection<Enum<?>> reasons = null;\n        for (final TransitionGuard guard : guards)\n        {\n            if (!guard.continueProcessing())\n            {\n                if (reasons == null)\n                {\n                    reasons = new ArrayList<Enum<?>>();\n                }\n                reasons.add(guard.getReason());\n            }\n        }\n        if (reasons == null)\n        {\n            reasons = Collections.emptyList();\n        }\n\n        return reasons;\n    }\n\n    private static final TransitionGuard GUARD_CONTINUE         = new TransitionGuard(Type.CONTINUE, null);\n    private static final TransitionGuard GUARD_STOP_IMMIDIATELY = new TransitionGuard(Type.STOP_IMMEDIATELY, null);\n    private static final TransitionGuard GUARD_STOP_EVENTUALLY  = new TransitionGuard(Type.STOP_AFTER_PROCESSING_REMAINING_LISTENERS, null);\n\n    /**\n     * @return true if the transition should stop\n     */\n    public boolean stop()\n    {\n        return this.type.stop();\n    }\n\n    /**\n     * @return true if the transition should continue\n     */\n    public boolean continueProcessing()\n    {\n        return this.type.continueProcessing();\n    }\n\n    /**\n     * @return a generic \'continue\' transition guard\n     */\n    public static TransitionGuard ok()\n    {\n        return GUARD_CONTINUE;\n    }\n\n    /**\n     * @return a generic stop immediately transition guard\n     */\n    public static TransitionGuard stopImmediately()\n    {\n        return GUARD_STOP_IMMIDIATELY;\n    }\n\n    /**\n     * @param reason\n     * @return a generic stop eventually transition guard\n     */\n    public static TransitionGuard stopImmediately(final Enum<?> stopReason)\n    {\n        return new TransitionGuard(Type.STOP_IMMEDIATELY, stopReason);\n    }\n\n    /**\n     * @return a generic stop eventually transition guard\n     */\n    public static TransitionGuard stopEventually()\n    {\n        return GUARD_STOP_EVENTUALLY;\n    }\n\n    /**\n     * @param reason\n     * @return a generic stop eventually transition guard\n     */\n    public static TransitionGuard stopEventually(final Enum<?> stopReason)\n    {\n        return new TransitionGuard(Type.STOP_AFTER_PROCESSING_REMAINING_LISTENERS, stopReason);\n    }\n    \n    /**\n     * @return the string representation\n     */\n    @Override\n    public String toString()\n    {\n        return String.format(""%s [%s]"", this.type, this.reason);\n    }\n}\n')",[281174]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'aaron.test.test.ClaimsReadyForPaymentTest')","[1130, 36539, 78755, 119298, 165178, 214720]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsPaymentComplete extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""Payment Complete"";\n\n    \n    /**\n     * @param fsm\n     */\n    ClaimsPaymentComplete(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        return allTransitions;    \n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[267636]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_generate(com.porpoise.fsm.generator.StateMachineGeneratorTest)')","[4463, 4494, 4525, 5083, 5114, 5145, 22245, 22269, 22293, 32769, 32799, 32829, 45500, 45535, 45570, 46200, 46235, 46270, 65618, 65646, 65674, 75241, 75269, 75297, 87138, 87171, 87204, 87798, 87831, 87864, 106088, 106114, 106140, 115272, 115304, 115336, 128837, 128874, 128911, 129577, 129614, 129651, 150123, 150153, 150183, 160768, 160803, 160838, 175584, 175624, 175664, 176384, 176424, 176464, 198622, 198655, 198688, 210054, 210091, 210128, 225704, 225746, 225788, 226544, 226586, 226628, 252008, 252048, 252088, 252340, 252382, 252424]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_moveToClaimsReadyForPayment(aaron.test.test.ClaimsPaymentRejectedTest)')","[20087, 20118, 20149, 28485, 28509, 28533, 42213, 42243, 42273, 63140, 63175, 63210, 72898, 72926, 72954, 84045, 84073, 84101, 103770, 103803, 103836, 112848, 112874, 112900, 125356, 125388, 125420, 147485, 147522, 147559, 157923, 157953, 157983, 171812, 171847, 171882, 195744, 195784, 195824, 207202, 207235, 207268, 221738, 221775, 221812, 246872, 246914, 246956, 309379, 309419, 309459, 310191, 310233, 310275]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_markPaymentAsComplete(aaron.test.test.ClaimsPaymentReceivedTest)')","[19591, 19622, 19653, 20955, 20986, 21017, 28197, 28221, 28245, 41716, 41746, 41776, 62580, 62615, 62650, 64120, 64155, 64190, 72562, 72590, 72618, 83582, 83610, 83638, 103242, 103275, 103308, 104694, 104727, 104760, 112536, 112562, 112588, 124825, 124857, 124889, 146893, 146930, 146967, 148521, 148558, 148595, 157563, 157593, 157623, 171230, 171265, 171300, 195104, 195144, 195184, 196864, 196904, 196944, 206806, 206839, 206872, 221122, 221159, 221196, 246200, 246242, 246284, 248048, 248090, 248132, 307965, 308005, 308045, 308793, 308835, 308877]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\binterface (\\w+).*', 'package p;\n\n/**\n * listener callback interface \n */\npublic interface TransitionListener\n{\n\n    /**\n     * fired when a transition is executed\n     * @return the transition guard\n     */\n    TransitionGuard onTransition(final Transition transition);\n}\n')",[280181]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * A PathEntry represents a link in the chain of a \'path\' from one state to another.\n * Each link in a path denotes a new target state and the transition used to get there. \n */\nfinal class PathEntry\n{\n    private final State      state;\n    private final Transition viaTransition;\n\n    PathEntry(final State stateValue, final Transition transitionValue)\n    {\n        this.state = stateValue;\n        this.viaTransition = transitionValue;\n    }\n\n    PathEntry(final State startState)\n    {\n        this(startState, null);\n    }\n\n    /**\n     * @return the state from this transition\n     */\n    public State getState()\n    {\n        return this.state;\n    }\n\n    /**\n     * @return the transition used to arrive at the next state\n     */\n    public Transition getTransition()\n    {\n        return this.viaTransition;\n    }\n\n    /**\n     * execute the given path. Return true if all transitions executed successfully\n     * \n     * @return a non-null collection of reasons should the transition fail\n     */\n    final Collection<Enum<?>> execute()\n    {\n        if (getTransition() != null)\n        {\n            return getTransition().execute();\n        }\n        return Collections.emptyList();\n    }\n\n    @Override\n    public int hashCode()\n    {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((this.state == null) ? 0 : this.state.hashCode());\n        result = prime * result + ((this.viaTransition == null) ? 0 : this.viaTransition.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(final Object obj)\n    {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        final PathEntry other = (PathEntry) obj;\n        if (this.state == null)\n        {\n            if (other.state != null)\n                return false;\n        }\n        else if (!this.state.equals(other.state))\n            return false;\n        if (this.viaTransition == null)\n        {\n            if (other.viaTransition != null)\n                return false;\n        }\n        else if (!this.viaTransition.equals(other.viaTransition))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString()\n    {\n        if (this.viaTransition == null)\n            return this.state.getName();\n        return String.format(""--[%s]-->%s"", this.viaTransition.getName(), this.state.getName());\n    }\n}')",[259264]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsNotReceived extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""Not Received"";\n\n    private TransitionClaimsSubmitToMonitoringOfficer submitToMonitoringOfficer; \n    private TransitionClaimsSubmitToDeliveryTeam submitToDeliveryTeam; \n    private TransitionClaimsSubmitToHeadOfDelivery submitToHeadOfDelivery; \n    \n    /**\n     * @param fsm\n     */\n    ClaimsNotReceived(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        // Transition submit to monitoring officer\n        this.submitToMonitoringOfficer = new TransitionClaimsSubmitToMonitoringOfficer(this, getStateMachine().receivedByMonitoringOfficer());\n        allTransitions.add(this.submitToMonitoringOfficer); \n\n        // Transition submit to delivery team\n        this.submitToDeliveryTeam = new TransitionClaimsSubmitToDeliveryTeam(this, getStateMachine().receivedByDeliveryTeam());\n        allTransitions.add(this.submitToDeliveryTeam); \n\n        // Transition submit to head of delivery\n        this.submitToHeadOfDelivery = new TransitionClaimsSubmitToHeadOfDelivery(this, getStateMachine().receivedByHeadOfDelivery());\n        allTransitions.add(this.submitToHeadOfDelivery); \n\n        return allTransitions;    \n    }\n    \n    /**\n     * execute the submit to monitoring officer transition\n     * @return true if the transition was successful\n     */\n    public boolean submitToMonitoringOfficer() {\n        this.submitToMonitoringOfficer.execute();\n        return this.submitToMonitoringOfficer.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerSubmitToMonitoringOfficerListener(final T listener)\n    {\n        return this.submitToMonitoringOfficer.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterSubmitToMonitoringOfficerListener(final TransitionListener listener)\n    {\n        return this.submitToMonitoringOfficer.unregisterListener(listener);\n    }\n    \n    /**\n     * execute the submit to delivery team transition\n     * @return true if the transition was successful\n     */\n    public boolean submitToDeliveryTeam() {\n        this.submitToDeliveryTeam.execute();\n        return this.submitToDeliveryTeam.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerSubmitToDeliveryTeamListener(final T listener)\n    {\n        return this.submitToDeliveryTeam.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterSubmitToDeliveryTeamListener(final TransitionListener listener)\n    {\n        return this.submitToDeliveryTeam.unregisterListener(listener);\n    }\n    \n    /**\n     * execute the submit to head of delivery transition\n     * @return true if the transition was successful\n     */\n    public boolean submitToHeadOfDelivery() {\n        this.submitToHeadOfDelivery.execute();\n        return this.submitToHeadOfDelivery.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerSubmitToHeadOfDeliveryListener(final T listener)\n    {\n        return this.submitToHeadOfDelivery.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterSubmitToHeadOfDeliveryListener(final TransitionListener listener)\n    {\n        return this.submitToHeadOfDelivery.unregisterListener(listener);\n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[265859]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_rejectToMo(aaron.test.test.ClaimsReceivedByDeliveryTeamTest)')","[15468, 18072, 27021, 30383, 39835, 57925, 60865, 71190, 81829, 98853, 101625, 111262, 122816, 141972, 145080, 156093, 169029, 189784, 193144, 205189, 218793, 240614, 244142, 303371, 304693]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test.test;\n\nimport aaron.test.*;\n\nimport org.junit.*;\n\n/**\n * tests for ClaimsStateMachine\n */\npublic class ClaimsStateMachineTest \n{\n    /**\n     *\n     */\n    @Test\n    public void test_generalListeners()\n    {\n        final ClaimsStateMachine fsm = ClaimsStateMachine.create(); \n        Assert.assertNotNull(fsm);\n    }\n\n}\n')",[269372]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\n/**\n * a listener callback used to respond to state changes.\n */\npublic interface StateListener\n{\n    /**\n     *\n     */\n    TransitionGuard onExit(final Transition transition);\n    \n    /**\n     *\n     */\n    TransitionGuard onEnter(final Transition transition);\n}\n')",[256671]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p.test;\n\nimport p.*;\n\nimport org.junit.*;\n\n/**\n * tests for TestStateMachine\n */\npublic class TestStateMachineTest \n{\n    /**\n     *\n     */\n    @Test\n    public void test_generalListeners()\n    {\n        final TestStateMachine fsm = TestStateMachine.create(); \n        Assert.assertNotNull(fsm);\n    }\n\n}\n')",[286943]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_moveToClaimsReadyForPayment(aaron.test.test.ClaimsReceivedByHeadOfDeliveryTest)')","[13391, 13422, 13453, 16739, 16770, 16801, 26469, 26493, 26517, 39008, 39038, 39068, 55580, 55615, 55650, 59360, 59395, 59430, 70546, 70574, 70602, 81058, 81086, 81114, 96642, 96675, 96708, 100206, 100239, 100272, 110664, 110690, 110716, 121933, 121965, 121997, 139493, 139530, 139567, 143489, 143526, 143563, 155403, 155433, 155463, 168062, 168097, 168132, 187104, 187144, 187184, 191424, 191464, 191504, 204430, 204463, 204496, 217770, 217807, 217844, 237800, 237842, 237884, 242336, 242378, 242420, 301013, 301053, 301093, 302353, 302395, 302437]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsReadyForPayment\n */\npublic class ClaimsReadyForPaymentTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the \'ClaimsReadyForPayment\' state\n     */\n    @Test\n    public void test_executeToClaimsReadyForPayment()\n    {\n        Assert.assertNotNull(moveToClaimsReadyForPayment());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for \'readyForPayment\' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.readyForPayment().getName();\n        Assert.assertEquals(fsm.readyForPayment(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the readyForPayment state\n     */\n    final ClaimsReadyForPayment moveToClaimsReadyForPayment()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsReadyForPayment readyForPayment = fsm.readyForPayment();\n\n        // call the method under test\n        fsm.executeToState(readyForPayment);\n\n        Assert.assertSame(readyForPayment, fsm.getCurrentState());\n        Assert.assertEquals(readyForPayment.getName(), fsm.getCurrentStateName());\n        \n        return readyForPayment;\n    }\n\n    \n    @Test\n    public void test_getPathBetweenClaimsReadyForPaymentAndClaimsPaymentRejected()\n    {\n\n        final ClaimsReadyForPayment readyForPayment = moveToClaimsReadyForPayment();\n        final ClaimsStateMachine fsm = readyForPayment.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'readyForPayment\'"", readyForPayment, fsm.getCurrentState());\n\n        final TransitionPaths paths = readyForPayment.getPaths(fsm.paymentRejected());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        readyForPayment.registerRejectPaymentListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'readyForPayment\'"", readyForPayment, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.paymentRejected(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'rejectPayment\' transition \n     */\n    @Test\n    public void test_rejectPayment()\n    {\n        final ClaimsReadyForPayment readyForPayment = moveToClaimsReadyForPayment();\n        final ClaimsStateMachine fsm = readyForPayment.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        readyForPayment.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        readyForPayment.rejectPayment();\n\n        //\n        // assert the current state is now ClaimsPaymentRejected\n        //\n        Assert.assertEquals(fsm.paymentRejected(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.paymentRejected().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsRejectPayment.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsRejectPayment.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(readyForPayment.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReadyForPayment\' can be moved into the ClaimsPaymentRejected state\n     */\n    @Test\n    public void test_moveToClaimsPaymentRejected()\n    {\n        final ClaimsReadyForPayment readyForPayment = moveToClaimsReadyForPayment();\n        final ClaimsStateMachine fsm = readyForPayment.getStateMachine();\n        readyForPayment.getPaths(fsm.paymentRejected());\n        \n    }\n    \n    @Test\n    public void test_getPathBetweenClaimsReadyForPaymentAndClaimsPaymentReceived()\n    {\n\n        final ClaimsReadyForPayment readyForPayment = moveToClaimsReadyForPayment();\n        final ClaimsStateMachine fsm = readyForPayment.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'readyForPayment\'"", readyForPayment, fsm.getCurrentState());\n\n        final TransitionPaths paths = readyForPayment.getPaths(fsm.paymentReceived());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        readyForPayment.registerMarkPaymentAsReceivedListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'readyForPayment\'"", readyForPayment, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.paymentReceived(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'markPaymentAsReceived\' transition \n     */\n    @Test\n    public void test_markPaymentAsReceived()\n    {\n        final ClaimsReadyForPayment readyForPayment = moveToClaimsReadyForPayment();\n        final ClaimsStateMachine fsm = readyForPayment.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        readyForPayment.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        readyForPayment.markPaymentAsReceived();\n\n        //\n        // assert the current state is now ClaimsPaymentReceived\n        //\n        Assert.assertEquals(fsm.paymentReceived(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.paymentReceived().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsMarkPaymentAsReceived.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsMarkPaymentAsReceived.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(readyForPayment.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReadyForPayment\' can be moved into the ClaimsPaymentReceived state\n     */\n    @Test\n    public void test_moveToClaimsPaymentReceived()\n    {\n        final ClaimsReadyForPayment readyForPayment = moveToClaimsReadyForPayment();\n        final ClaimsStateMachine fsm = readyForPayment.getStateMachine();\n        readyForPayment.getPaths(fsm.paymentReceived());\n        \n    }\n}\n')",[270649]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\n\n\n/**\n * Representation of the state machine. Through a TestStateMachine instance you can:\n * <ul>\n * <li>Create a new instance (see @{link createAndStart()} and @{link create()})</li>\n * <li>Access all states by their names</li>\n * <li>register and unregister listeners which will be notified of every state transition</li>\n * <li>navigate to (execute) states via transitions</li>\n * <li>retrieve state instances by their names</li>\n * </ul>\n *\n * States returned via this state machine may *only* be used in this state machine.\n * For example, this is not valid:\n * <pre>\n * TestStateMachine fsmOne = TestStateMachine.createAndStart();\n * TestStateMachine fsmTwo = TestStateMachine.createAndStart();\n * Object stateA = fsmOne.<some state>();\n * fsmTwo.executeToState(stateA); // invalid  -- cannot share state instances between state machines\n * </pre>\n */\npublic class TestStateMachine\n{\n    private StateNotifier notifier;\n    private State                     currentState;\n    private final Map<String, AbstractTestState>  stateByName;\n\n    private TestStartState teststartstate;\n\n    /**\n     *\n     */\n    private TestStateMachine()\n    {\n        super();\n        this.stateByName = new HashMap<String, AbstractTestState>();\n    }\n\n    /**\n     * @return a new notifier\n     */\n    final StateNotifier newNotifier()\n    {\n        return new StateNotifier();\n    }\n\n    /**\n     * state machines need to be explicitly started.\n     * This is a convenience method for returning a new state machine which is \n     * already in the start state\n     *\n     * @return the new state machine\n     */\n    public static TestStateMachine createAndStart()\n    {\n        TestStateMachine instance = create();\n        instance.start();\n        return instance;\n    }\n\n    /**\n     * factory method used to create state machines\n     *\n     * @return a new state machine instance\n     */\n    public static TestStateMachine create()\n    {\n        final TestStateMachine fsm = new TestStateMachine();\n\n        fsm.notifier = fsm.newNotifier();\n        \n        //\n        // Create states\n        //\n        fsm.teststartstate = new TestStartState(fsm);\n        final State oldTestStartStateEntry = fsm.stateByName.put(fsm.teststartstate.getName(), fsm.teststartstate);\n        assert oldTestStartStateEntry == null : ""duplicate state names: "" + fsm.teststartstate.getName();\n\n\n        //\n        // Initialise transitions\n        //\n        fsm.teststartstate.initialise();\n        return fsm;\n    }\n\n    /**\n     * @return the current state\n     */\n    public State getCurrentState()\n    {\n        return this.currentState;\n    }\n    \n    /**\n     * @param goal the target state\n     * @return a TransitionPaths object from the current state to the given goal state\n     */\n    public TransitionPaths getPaths(final State goal)\n    {\n        return getCurrentState().getPaths(goal);\n    }\n\n    /**\n     * @param goal\n     *            the target state\n     * @return a TransitionPaths object from the current state to the given goal state\n     */\n    public TransitionPaths getSuccessfulPaths(final State goal)\n    {\n        final TransitionPaths allPaths = getCurrentState().getPaths(goal);\n        final TransitionPaths successfulPaths = new TransitionPaths();\n        if (allPaths != null)\n        {\n            for (final TransitionPath path : allPaths)\n            {\n                final TransitionPathResult result = executePathDryRun(path);\n                if (result != null && result.isSuccess())\n                {\n                    successfulPaths.add(path);\n                }\n            }\n        }\n        return successfulPaths;\n    }\n\n    /**\n     * @param path\n     *            the path to execute w/o affecting the current state. All registered listeners however will be notified.\n     * @return the result\n     */\n    public final TransitionPathResult executePathDryRun(final TransitionPath path)\n    {\n        final State beforeState = getCurrentState();\n        TransitionPathResult result;\n        try\n        {\n            result = path.execute();\n        }\n        finally\n        {\n            setCurrentState(beforeState);\n        }\n        return result;\n    }\n\n    /**\n     * @param path\n     *            the path to execute\n     * @return the result\n     */\n    public final TransitionPathResult executePath(final TransitionPath path)\n    {\n        return path.execute();\n    }\n\n    /**\n     * @param the given state name\n     * @return the result\n     */\n    public TransitionPathResult executeToState(final String name)\n    {   \n        final State state = getStateForName(name);\n        if (state == null)\n        {\n            throw new IllegalArgumentException(String.format(""No state exists with the name \'%s\'"", name));\n        }\n        return executeToState(state);\n    }\n\n    /**\n     * @param the given state name\n     * @return the result\n     */\n    public TransitionPathResult executeToStateDryRun(final String name)\n    {   \n        final State state = getStateForName(name);\n        if (state == null)\n        {\n            throw new IllegalArgumentException(String.format(""No state exists with the name \'%s\'"", name));\n        }\n        return executeToStateDryRun(state);\n    }\n    \n    /**\n     * After calling, the state will be reset its current state see {@link #executeToState(State)}\n     * \n     * @param to\n     *            the goal state\n     * @return the result of executing to the given state via the shorted available path\n     */\n    public TransitionPathResult executeToStateDryRun(final State to)\n    {\n        final State beforeState = getCurrentState();\n        TransitionPathResult result;\n        try\n        {\n            result = executeToState(to);\n        }\n        finally\n        {\n            setCurrentState(beforeState);\n        }\n        return result;\n    }\n\n\n    /**\n     * jump to the given state via the shortest \'path\'.\n     * \n     * @param to\n     *            the goal state\n     * @return the result of trying to move to the given state via the shortest available path, or null if no path was found. If the state machine was already in the given state it returns false. If the state\n     *         machine has now moved into the given state it returns true.\n     */\n    public TransitionPathResult executeToState(final State to)\n    {\n        if (to == getCurrentState())\n        {\n            return TransitionPathResult.fail(TransitionGuard.Reasons.ALREADY_IN_TARGET_STATE);\n        }\n\n        final TransitionPath path = getShortestSuccessfulPath(to);\n        \n        if (path != null)\n        {\n            return path.execute();\n        }\n\n        return TransitionPathResult.fail(TransitionGuard.Reasons.TARGET_STATE_UNREACHABLE);\n    }\n\n    /**\n     * @param to\n     *            the target (goal) state\n     * @return the first path available which can transition to the given state\n     */\n    public TransitionPath getShortestSuccessfulPath(final State to)\n    {\n        final State beforeState = getCurrentState();\n        TransitionPath path;\n        try\n        {\n            path = getShortestSuccessfulPathInternal(to);\n        }\n        finally\n        {\n            setCurrentState(beforeState);\n        }\n\n        return path;\n    }\n\n    private TransitionPath getShortestSuccessfulPathInternal(final State to)\n    {\n        final TransitionPaths paths = getPaths(to);\n        boolean success = false;\n        final State beforeState = getCurrentState();\n        for (final TransitionPath path : paths)\n        {\n            StateLog.debug(""trying "" + path);\n            success = executeToStateInternal(path, to);\n            if (success)\n            {\n                return path;\n            }\n            setCurrentState(beforeState);\n        }\n        return null;\n    }\n\n    /**\n     * jump to the given state via the path of transitions\n     * \n     * @return true if this call had any effect\n     */\n    private boolean executeToStateInternal(final TransitionPath path, final State to)\n    {\n        if (to == getCurrentState())\n        {\n            return false;\n        }\n        if (path == null)\n        {\n            throw new IllegalStateException(String.format(""can\'t get to \'%s\' from \'%s\'"", getCurrentStateName(), to.getName()));\n        }\n        path.execute();\n        return to == getCurrentState();\n    }\n\n    /**\n     * @return the name of the current state\n     */\n    public String getCurrentStateName()\n    {\n        return getCurrentState() == null ? null : getCurrentState().getName();\n    }\n\n    /**\n     * @return the start state\n     * @throws IllegalStateException\n     *             if the state machine was already started\n     */\n    public TestStartState start()\n    {\n        if (getCurrentState() != null && getCurrentState().equals(this.teststartstate))\n        {\n            throw new IllegalStateException(""already started"");\n        }\n        setCurrentState(this.teststartstate);\n        return this.teststartstate;\n    }\n\n    /**\n     * @return the TestStartState state\n     */\n    public TestStartState startState()\n    {\n        return this.teststartstate;\n    }    \n\n\n    /**\n     * @return a collection of all the transitions across all states\n     */\n    public Collection<Transition> getTransitions()\n    {\n        final Collection<Transition> states = new LinkedList<Transition>();\n        for (final AbstractTestState state : this.stateByName.values())\n        {\n            states.addAll(state.getTransitions());\n        }\n        return states;\n    }\n\n    /**\n     * @return a collection of all the names for all the transitions across all states\n     */\n    public Collection<String> getTransitionNames()\n    {\n        final Collection<String> names = new LinkedList<String>();\n        for (final AbstractTestState state : this.stateByName.values())\n        {\n            names.addAll(state.getTransitionNames());\n        }\n        return names;\n    }\n\n    /**\n     * @return a collection of all states for this state machine\n     */\n    public Collection<State> getStates()\n    {\n        final Collection<State> states = new LinkedList<State>();\n        for (final AbstractTestState state : this.stateByName.values())\n        {\n            states.add(state);\n        }\n        return states;\n    }\n\n\n    /**\n     * @return a collection of all the names of all the states for this state machine\n     */\n    public Collection<String> getStateNames()\n    {\n        return this.stateByName.keySet();\n    }\n    \n    /**\n     * @param name the name of the state\n     * @return the state for the given name\n     */\n    public State getStateForName(final String name)\n    {\n        if (name == null)\n        {\n            throw new NullPointerException(""Invalid argument: null state name"");\n        }\n        return this.stateByName.get(name);\n    }\n\n    /**\n     * @param name\n     *            the name of the transition\n     * @return the transition for the given name\n     */\n    public Transition getTransitionForName(final String name)\n    {\n        for (final AbstractTestState state : this.stateByName.values())\n        {\n            final Transition transition = state.getTransitionForName(name);\n            if (transition != null)\n            {\n                return transition;\n            }\n        }\n        return null;\n    }\n    \n    final void setCurrentState(State newState)\n    {\n        this.currentState = newState;\n    }\n\n\n    /**\n     * @param listeners\n     */\n    public void registerListeners(final StateListener... listeners)\n    {\n        for (final StateListener listener : listeners)\n        {\n            registerListener(listener);\n        }\n    }\n\n    /**\n     * register and return the given listener\n     * @param listener the registered listener\n     * @return the registered listener (for chaining)\n     */\n    public <T extends StateListener> T registerListener(final T listener)\n    {\n        final boolean added = this.notifier.registerListener(listener);\n        assert added;\n        return listener;\n    }\n\n    /**\n     * unregister a listener\n     * @return true if the listener was successfully unregistered\n     */\n    public boolean unregisterListener(final StateListener listener)\n    {\n        return this.notifier.unregisterListener(listener);\n    }\n\n    final TransitionGuard onBeforeTransition(final Transition transition)\n    {\n        return this.notifier.onBeforeTransition(transition);\n    }\n\n    final TransitionGuard onAfterTransition(final Transition transition)\n    {\n        return this.notifier.onAfterTransition(transition);\n    }\n\n    /**\n     * drops your entire database.\n     * Either that or just represents the state machine as a string. \n     * Take your chances.\n     */\n    @Override\n    public String toString()\n    {\n        final String newLine = String.format(""%n"");\n        final StringBuilder builder = new StringBuilder(""TestStateMachine"").append(newLine);\n        builder.append(""\\t"").append(this.notifier).append(newLine);\n        builder.append(""Current State:"");\n        builder.append(this.currentState).append(newLine);\n        builder.append(this.teststartstate).append(newLine);\n        return builder.toString();\n    }\n}\n')",[276653]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'aaron.test.test.ClaimsNotReceivedTest')","[1013, 35442, 77732, 118127, 163896, 213364]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'aaron.test.test.ClaimsReceivedByMonitoringOfficerTest')","[1247, 37996, 80114, 120853, 166880, 216520]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\n/**\n * a listener which groups other listeners\n */\npublic class GroupStateListener implements StateListener \n{\n    private final StateNotifier notifier;\n\n    /**\n     */\n    public GroupStateListener(final StateListener ... listeners)\n    {\n        this.notifier = new StateNotifier();\n        for (final StateListener listener : listeners)\n        {\n            this.notifier.registerListener(listener);\n        }\n    }\n   \n    @Override\n    public TransitionGuard onExit(final Transition transition)\n    {\n        return this.notifier.onBeforeTransition(transition);\n    }\n\n    @Override\n    public TransitionGuard onEnter(final Transition transition)\n    {\n        return this.notifier.onAfterTransition(transition);\n    }\n\n    /**\n     * @return the string representation of this listener\n     */\n    @Override\n    public String toString()\n    {\n        return String.format(""group listener {%s}"", this.notifier);\n    }\n}\n')",[256494]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_moveToClaimsReceivedByHeadOfDelivery(aaron.test.test.ClaimsNotReceivedTest)')","[7439, 7470, 7501, 10043, 10074, 10105, 23877, 23901, 23925, 35357, 35387, 35417, 48860, 48895, 48930, 51800, 51835, 51870, 67522, 67550, 67578, 77653, 77681, 77709, 90306, 90339, 90372, 93078, 93111, 93144, 107856, 107882, 107908, 118036, 118068, 118100, 132389, 132426, 132463, 135497, 135534, 135571, 152163, 152193, 152223, 163796, 163831, 163866, 179424, 179464, 179504, 182784, 182824, 182864, 200866, 200899, 200932, 213258, 213295, 213332, 229736, 229778, 229820, 233264, 233306, 233348, 291371, 291411, 291451, 293215, 293257, 293299]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsApproveForDeliveryTeam extends AbstractTransition<ClaimsReceivedByMonitoringOfficer, ClaimsReceivedByDeliveryTeam>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""approve for delivery team"";\n\n    TransitionClaimsApproveForDeliveryTeam(final ClaimsReceivedByMonitoringOfficer from, final ClaimsReceivedByDeliveryTeam to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[268905]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\nimport com.google.common.base.Predicate;\n\n/**\n * a listener which can be turned on and off by the given predicate\n */\npublic class ConditionalStateListener extends AbstractConditionalStateListener \n{\n    private final StateListener wrappedListener;\n\n    /**\n     * @param predicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener will be executed.\n     * @param listener\n     */\n    public ConditionalStateListener(final Predicate<Transition> predicate, final StateListener listener)\n    {\n        this(predicate, predicate, listener);\n    }\n\n    /**\n     * @param enterPredicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener\'s onEnter will be executed.\n     * @param exitPredicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener\'s onExit method will be executed.\n     * @param predicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener will be executed.\n     * @param listener\n     */\n    public ConditionalStateListener(final Predicate<Transition> enterPredicate, final Predicate<Transition> exitPredicate, final StateListener listener)\n    {\n        this(enterPredicate, exitPredicate, listener, TransitionGuard.ok(), TransitionGuard.ok());\n    }\n\n    /**\n     * @param enterPredicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener\'s onEnter will be executed.\n     * @param exitPredicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener\'s onExit method will be executed.\n     * @param predicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener will be executed.\n     * @param listener\n     * @param enterDefault the transition to return should the enter predicate filter return false\n     * @param exitDefault the transition to return should the exit predicate filter return false\n     */\n    public ConditionalStateListener(final Predicate<Transition> enterPredicate, final Predicate<Transition> exitPredicate, final StateListener listener, final TransitionGuard enterDefault, final TransitionGuard exitDefault)\n    {\n        super(enterPredicate, exitPredicate, exitDefault, exitDefault);\n        if (listener == null)\n        {\n            throw new NullPointerException(""listener cannot be null"");\n        }\n        this.wrappedListener = listener;\n    }\n   \n    /**\n     * @param transition\n     * @return the transition return value.  \n     */\n    @Override\n    protected TransitionGuard onExitInternal(final Transition transition)\n    {\n        return this.wrappedListener.onExit(transition);\n    }\n\n    /**\n     * @param transition\n     * @return the transition return value.  \n     */\n    @Override\n    protected TransitionGuard onEnterInternal(final Transition transition)\n    {\n        return this.wrappedListener.onEnter(transition);\n    }\n}\n')",[279728]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\nimport com.google.common.base.Predicate;\n\n/** \n */\npublic final class ConditionalTransitionListener implements TransitionListener\n{\n    private final  TransitionGuard onFalseResult;\n    private final Predicate<Transition> filter;\n    private final TransitionListener delegate;    \n    /**\n     * @param predicate\n     */\n    public ConditionalTransitionListener(final Predicate<Transition> predicate, final TransitionListener wrappedListener)\n    {\n        this(predicate, wrappedListener, TransitionGuard.ok());\n    }\n    \n    /**\n     * @param predicate\n     */\n    public ConditionalTransitionListener(final Predicate<Transition> predicate, final TransitionListener wrappedListener, final TransitionGuard onFalseResultParam)\n    {\n        if (predicate == null)\n        {\n            throw new NullPointerException(""predicate cannot be null"");        \n        }\n        if (wrappedListener == null)\n        {\n            throw new NullPointerException(""wrappedListener cannot be null"");        \n        }\n        if (onFalseResultParam == null)\n        {\n            throw new NullPointerException(""onFalseResultParam cannot be null"");        \n        }\n        this.filter = predicate;\n        this.onFalseResult = onFalseResultParam;\n        this.delegate = wrappedListener; \n    }\n    \n    /**\n     * fired when a transition is executed\n     * \n     * @return the transition guard\n     */\n    @Override\n    public TransitionGuard onTransition(final Transition transition)\n    {\n        if (this.filter.apply(transition))\n        {\n            return this.delegate.onTransition(transition);\n        }\n        return this.onFalseResult;\n    }\n}\n')",[279361]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsSubmitToMonitoringOfficer extends AbstractTransition<ClaimsNotReceived, ClaimsReceivedByMonitoringOfficer>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""submit to monitoring officer"";\n\n    TransitionClaimsSubmitToMonitoringOfficer(final ClaimsNotReceived from, final ClaimsReceivedByMonitoringOfficer to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[266018]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\npublic interface NamedObject\n{\n    /**\n     * @return a name for the object\n     */\n    public String getName();\n}\n')",[254488]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsResubmitForPayment extends AbstractTransition<ClaimsPaymentRejected, ClaimsReadyForPayment>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""resubmit for payment"";\n\n    TransitionClaimsResubmitForPayment(final ClaimsPaymentRejected from, final ClaimsReadyForPayment to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[263816]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\n/**\n * a listener which groups other listeners\n */\npublic class GroupStateListener implements StateListener \n{\n    private final StateNotifier notifier;\n\n    /**\n     */\n    public GroupStateListener(final StateListener ... listeners)\n    {\n        this.notifier = new StateNotifier();\n        for (final StateListener listener : listeners)\n        {\n            this.notifier.registerListener(listener);\n        }\n    }\n   \n    @Override\n    public TransitionGuard onExit(final Transition transition)\n    {\n        return this.notifier.onBeforeTransition(transition);\n    }\n\n    @Override\n    public TransitionGuard onEnter(final Transition transition)\n    {\n        return this.notifier.onAfterTransition(transition);\n    }\n\n    /**\n     * @return the string representation of this listener\n     */\n    @Override\n    public String toString()\n    {\n        return String.format(""group listener {%s}"", this.notifier);\n    }\n}\n')",[256628]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport com.google.common.base.Predicate;\n\n/**\n * A collection of useful implementations of StateListener\n */\npublic enum StateListeners \n{\n    ;//uninstantiable\n    \n    static class BlockEntryListener extends ListenerAdapter\n    {\n        private final Enum<?> reason;\n        public BlockEntryListener(final Enum<?> reason)\n        {\n            super(TransitionGuard.stopEventually(reason), TransitionGuard.ok());\n            this.reason = reason;\n        }\n        public BlockEntryListener()\n        {\n            this(null);\n        }\n\n        @Override\n        public String toString()\n        {\n            return String.format(""block entry (reason=%s)"", this.reason);\n        }\n    }\n\n    static class BlockExitListener extends ListenerAdapter\n    {\n        private final Enum<?> reason;\n        public BlockExitListener(final Enum<?> reason)\n        {\n            super(TransitionGuard.ok(), TransitionGuard.stopEventually(reason));\n            this.reason = reason;\n        }\n        public BlockExitListener()\n        {\n            this(null);\n        }\n\n        @Override\n        public String toString()\n        {\n            return String.format(""block exit (reason=%s)"", this.reason);\n        }\n    }\n\n    /**\n     */\n    public static RecordingListener recordingListener()\n    {\n        return new RecordingListener();\n    }\n\n    /**\n     * a listener which records the transitions\n     */\n    public static class RecordingListener extends ListenerAdapter\n    {\n        private final List<Transition> enterTransitions = new ArrayList<Transition>();\n        private final List<Transition> exitTransitions  = new ArrayList<Transition>();\n\n        @Override\n        public TransitionGuard onExit(final Transition transition)\n        {\n            this.exitTransitions.add(transition);\n            return TransitionGuard.ok();\n        }\n\n        @Override\n        public TransitionGuard onEnter(final Transition transition)\n        {\n            this.enterTransitions.add(transition);\n            return TransitionGuard.ok();\n        }\n\n        /**\n         * @return the exit transitions\n         */\n        public List<Transition> getExitTransitions()\n        {\n            return Collections.unmodifiableList(this.exitTransitions);\n        }\n\n        /**\n         * @return the enter transitions\n         */\n        public List<Transition> getEnterTransitions()\n        {\n            return Collections.unmodifiableList(this.enterTransitions);\n        }\n\n        @Override\n        public String toString()\n        {\n            return ""recording listener"";\n        }\n    }\n\n    /**\n     */\n    public static class EchoListener extends ListenerAdapter\n    {\n        private final PrintStream out;\n\n        public EchoListener(final PrintStream outStream)\n        {\n            if (outStream == null)\n            {\n                throw new NullPointerException();\n            }\n            this.out = outStream;\n        }\n\n        @Override\n        public TransitionGuard onEnter(final Transition transition)\n        {\n            this.out.println(String.format(""enter \'%s\' via \'%s\'"", transition.getTarget().getName(), transition.getName()));\n            return TransitionGuard.ok();\n        }\n\n        @Override\n        public TransitionGuard onExit(final Transition transition)\n        {\n            this.out.println(String.format(""exit \'%s\' via \'%s\'"", transition.getSource().getName(), transition.getName()));\n            return TransitionGuard.ok();\n        }\n        @Override\n        public String toString()\n        {\n            return ""echo listener"";\n        }\n    }\n\n    public static EchoListener echoListener(final PrintStream out)\n    {\n        return new EchoListener(out);\n    }\n\n    /**\n     * @return the registered listener\n     */\n    public static StateListener blockEntryListener()\n    {\n        return blockEntryListener(null);\n    }\n\n    /**\n     * @return the registered listener\n     */\n    public static StateListener blockEntryListener(final Enum<?> reason)\n    {\n        return new BlockEntryListener(reason);\n    }\n\n    /**\n     * @return the listener\n     */\n    public static StateListener blockExitListener()\n    {\n        return blockExitListener(null);\n    }\n\n    /**\n     * @return the listener\n     */\n    public static StateListener blockExitListener(final Enum<?> reason)\n    {\n        return new BlockExitListener(reason);\n    }\n\n    /**\n     * @param state\n     *            the state to match\n     * @return a predicate which will return true for transitions whos target state matches the given state\n     */\n    public static Predicate<Transition> targetStateEquals(final State state)\n    {\n        if (state == null)\n        {\n            throw new NullPointerException(""state cannot be null"");\n        }\n        return new Predicate<Transition>() {\n\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return value.getTarget().equals(state);\n            }\n        };\n    }\n\n    /**\n     * @param state\n     *            the state to match\n     * @return a predicate which will return true for transitions whos source state matches the given state\n     */\n    public static Predicate<Transition> sourceStateEquals(final State state)\n    {\n        if (state == null)\n        {\n            throw new NullPointerException(""state cannot be null"");\n        }\n        return new Predicate<Transition>() {\n\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return value.getSource().equals(state);\n            }\n        };\n    }\n\n    /**\n     * @param the reason\n     * @return the registered listener\n     */\n    public static StateListener blockEntry(final State state, final Enum<?> reason)\n    {\n        final StateListener listener = filter(targetStateEquals(state), blockEntryListener(reason));\n        return listener;\n    }\n\n    /**\n     * @param the reason\n     * @return the registered listener\n     */\n    public static StateListener blockExit(final State state, final Enum<?> reason)\n    {\n        final StateListener listener = filter(sourceStateEquals(state), blockExitListener(reason));\n        return listener;\n    }\n\n    /**\n     * @param filter\n     *            the filter to apply to the given listener\n     * @param listener\n     *            the listener to wrap\n     * @return the wrapped listener\n     */\n    public static ConditionalStateListener filter(final Predicate<Transition> filter, final StateListener listener)\n    {\n        return new ConditionalStateListener(filter, listener);\n    }\n\n    /**\n     * @param listeners\n     *            the listeners to treat as a single group\n     * @return the grouped listener\n     */\n    public static GroupStateListener group(final StateListener... listeners)\n    {\n        return new GroupStateListener(listeners);\n    }\n\n    /**\n     * @param listeners\n     *            the listeners to treat as a single group\n     * @return the group listener which you can turn on and off\n     */\n    public static ConditionalStateListener group(final Predicate<Transition> predicate, final StateListener... listeners)\n    {\n        return filter(predicate, group(listeners));\n    }\n }')",[261435]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsReceivedByMonitoringOfficerAndClaimsReceivedByHeadOfDelivery(aaron.test.test.ClaimsReceivedByMonitoringOfficerTest)')","[10880, 14228, 25293, 29965, 37401, 52745, 56525, 69174, 79559, 93969, 97533, 109390, 120218, 136496, 140492, 153933, 166185, 183864, 188184, 202813, 215785, 234398, 238934, 297111, 298921]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;')",[288145]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test.test;\nimport aaron.test.*;\nimport org.junit.*;\n\n/**\n * tests for ClaimsStateMachine\n */\n@Ignore(""base class"")\nabstract class AbstractClaimsTest \n{\n    /**\n     *\n     */\n    protected ClaimsStateMachine newStateMachine()\n    {\n        final ClaimsStateMachine fsm = ClaimsStateMachine.createAndStart(); \n        Assert.assertNotNull(fsm);\n        return fsm;\n    }\n}\n')",[269558]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsReceivedByMonitoringOfficer\n */\npublic class ClaimsReceivedByMonitoringOfficerTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the \'ClaimsReceivedByMonitoringOfficer\' state\n     */\n    @Test\n    public void test_executeToClaimsReceivedByMonitoringOfficer()\n    {\n        Assert.assertNotNull(moveToClaimsReceivedByMonitoringOfficer());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for \'receivedByMonitoringOfficer\' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.receivedByMonitoringOfficer().getName();\n        Assert.assertEquals(fsm.receivedByMonitoringOfficer(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the receivedByMonitoringOfficer state\n     */\n    final ClaimsReceivedByMonitoringOfficer moveToClaimsReceivedByMonitoringOfficer()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = fsm.receivedByMonitoringOfficer();\n\n        // call the method under test\n        fsm.executeToState(receivedByMonitoringOfficer);\n\n        Assert.assertSame(receivedByMonitoringOfficer, fsm.getCurrentState());\n        Assert.assertEquals(receivedByMonitoringOfficer.getName(), fsm.getCurrentStateName());\n        \n        return receivedByMonitoringOfficer;\n    }\n\n    \n    @Test\n    public void test_getPathBetweenClaimsReceivedByMonitoringOfficerAndClaimsReceivedByDeliveryTeam()\n    {\n\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'receivedByMonitoringOfficer\'"", receivedByMonitoringOfficer, fsm.getCurrentState());\n\n        final TransitionPaths paths = receivedByMonitoringOfficer.getPaths(fsm.receivedByDeliveryTeam());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        receivedByMonitoringOfficer.registerApproveForDeliveryTeamListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'receivedByMonitoringOfficer\'"", receivedByMonitoringOfficer, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.receivedByDeliveryTeam(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'approveForDeliveryTeam\' transition \n     */\n    @Test\n    public void test_approveForDeliveryTeam()\n    {\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        receivedByMonitoringOfficer.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        receivedByMonitoringOfficer.approveForDeliveryTeam();\n\n        //\n        // assert the current state is now ClaimsReceivedByDeliveryTeam\n        //\n        Assert.assertEquals(fsm.receivedByDeliveryTeam(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.receivedByDeliveryTeam().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsApproveForDeliveryTeam.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsApproveForDeliveryTeam.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(receivedByMonitoringOfficer.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReceivedByMonitoringOfficer\' can be moved into the ClaimsReceivedByDeliveryTeam state\n     */\n    @Test\n    public void test_moveToClaimsReceivedByDeliveryTeam()\n    {\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n        receivedByMonitoringOfficer.getPaths(fsm.receivedByDeliveryTeam());\n        \n    }\n    \n    @Test\n    public void test_getPathBetweenClaimsReceivedByMonitoringOfficerAndClaimsReceivedByHeadOfDelivery()\n    {\n\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'receivedByMonitoringOfficer\'"", receivedByMonitoringOfficer, fsm.getCurrentState());\n\n        final TransitionPaths paths = receivedByMonitoringOfficer.getPaths(fsm.receivedByHeadOfDelivery());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        receivedByMonitoringOfficer.registerApproveForHeadOfDeliveryListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'receivedByMonitoringOfficer\'"", receivedByMonitoringOfficer, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'approveForHeadOfDelivery\' transition \n     */\n    @Test\n    public void test_approveForHeadOfDelivery()\n    {\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        receivedByMonitoringOfficer.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        receivedByMonitoringOfficer.approveForHeadOfDelivery();\n\n        //\n        // assert the current state is now ClaimsReceivedByHeadOfDelivery\n        //\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsApproveForHeadOfDelivery.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsApproveForHeadOfDelivery.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(receivedByMonitoringOfficer.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReceivedByMonitoringOfficer\' can be moved into the ClaimsReceivedByHeadOfDelivery state\n     */\n    @Test\n    public void test_moveToClaimsReceivedByHeadOfDelivery()\n    {\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n        receivedByMonitoringOfficer.getPaths(fsm.receivedByHeadOfDelivery());\n        \n    }\n    \n    @Test\n    public void test_getPathBetweenClaimsReceivedByMonitoringOfficerAndClaimsNotReceived()\n    {\n\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'receivedByMonitoringOfficer\'"", receivedByMonitoringOfficer, fsm.getCurrentState());\n\n        final TransitionPaths paths = receivedByMonitoringOfficer.getPaths(fsm.notReceived());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        receivedByMonitoringOfficer.registerRejectToParticipantListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'receivedByMonitoringOfficer\'"", receivedByMonitoringOfficer, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.notReceived(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'rejectToParticipant\' transition \n     */\n    @Test\n    public void test_rejectToParticipant()\n    {\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        receivedByMonitoringOfficer.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        receivedByMonitoringOfficer.rejectToParticipant();\n\n        //\n        // assert the current state is now ClaimsNotReceived\n        //\n        Assert.assertEquals(fsm.notReceived(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.notReceived().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsRejectToParticipant.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsRejectToParticipant.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(receivedByMonitoringOfficer.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReceivedByMonitoringOfficer\' can be moved into the ClaimsNotReceived state\n     */\n    @Test\n    public void test_moveToClaimsNotReceived()\n    {\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n        receivedByMonitoringOfficer.getPaths(fsm.notReceived());\n        \n    }\n}\n')",[275780]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_multipleOccurrences(com.porpoise.fsm.generator.FilenameHelperTest)')","[4804, 5548, 22413, 29235, 33116, 45885, 46725, 65814, 75564, 87501, 88293, 106270, 115643, 129244, 130132, 150333, 161175, 176024, 176984, 198853, 210485, 226166, 227174, 287572, 287902]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getPackageName(com.porpoise.fsm.generator.FilenameHelperTest)')","[686, 4680, 5424, 22317, 29194, 32996, 33259, 45745, 46585, 65702, 75452, 75697, 87369, 88161, 106166, 115515, 115796, 129096, 129984, 150213, 161035, 161343, 175864, 176824, 198721, 210337, 210663, 225998, 227006, 287412, 287734]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\n/**\n * a listener callback used to respond to state changes.\n */\npublic interface StateListener\n{\n    /**\n     *\n     */\n    TransitionGuard onExit(final Transition transition);\n    \n    /**\n     *\n     */\n    TransitionGuard onEnter(final Transition transition);\n}\n')",[280101]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsReceivedByDeliveryTeam extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""Received By Delivery Team"";\n\n    private TransitionClaimsRejectToMo rejectToMo; \n    private TransitionClaimsApproveForHod approveForHod; \n    \n    /**\n     * @param fsm\n     */\n    ClaimsReceivedByDeliveryTeam(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        // Transition reject to mo\n        this.rejectToMo = new TransitionClaimsRejectToMo(this, getStateMachine().receivedByMonitoringOfficer());\n        allTransitions.add(this.rejectToMo); \n\n        // Transition approve for hod\n        this.approveForHod = new TransitionClaimsApproveForHod(this, getStateMachine().receivedByHeadOfDelivery());\n        allTransitions.add(this.approveForHod); \n\n        return allTransitions;    \n    }\n    \n    /**\n     * execute the reject to mo transition\n     * @return true if the transition was successful\n     */\n    public boolean rejectToMo() {\n        this.rejectToMo.execute();\n        return this.rejectToMo.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerRejectToMoListener(final T listener)\n    {\n        return this.rejectToMo.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterRejectToMoListener(final TransitionListener listener)\n    {\n        return this.rejectToMo.unregisterListener(listener);\n    }\n    \n    /**\n     * execute the approve for hod transition\n     * @return true if the transition was successful\n     */\n    public boolean approveForHod() {\n        this.approveForHod.execute();\n        return this.approveForHod.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerApproveForHodListener(final T listener)\n    {\n        return this.approveForHod.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterApproveForHodListener(final TransitionListener listener)\n    {\n        return this.approveForHod.unregisterListener(listener);\n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[267104]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n *\n */\nabstract class AbstractTransition<SOURCE extends AbstractTestState, TARGET extends AbstractTestState> implements Transition\n{\n    private final SOURCE sourceState;\n    private final TARGET targetState;\n    \n    private Collection<TransitionListener> listeners;\n\n    AbstractTransition(final SOURCE from, final TARGET to)\n    {\n        if (from == null) \n        {\n            throw new NullPointerException(""source state cannot be null"");\n        }\n        if (to == null) \n        {\n            throw new NullPointerException(""target state cannot be null"");\n        }\n        if (from.getStateMachine() != to.getStateMachine())\n        {\n            throw new NullPointerException(""source and target states are for different state machines"");\n        }\n        this.sourceState = from;\n        this.targetState = to;\n        this.listeners = new CopyOnWriteArrayList<TransitionListener>();\n    }\n\n    public SOURCE getSource()\n    {\n        return this.sourceState;\n    }\n    \n    public TARGET getTarget()\n    {\n        return this.targetState;\n    }\n\n    /**\n     *  hook for subclasses\n     */\n    protected void executeInternal()\n    {\n    // no-op\n    }\n\n    /**\n     * Execute the transition, returning a collection of reasons why the transition could not execute should the transition fail.\n     * Should the transition succeed, an empty collection is returned.\n     * @return a collection of reasons why the transition could not execute should the transition fail\n     */\n    public final Collection<Enum<?>> execute()\n    {\n        if (getSource() != getStateMachine().getCurrentState())\n        {\n            StateLog.error(""Illegal transition \'%s\' called. Current state was expected to be \'%s\' but was \'%s\'"", getName(), getSource().getName(),\n                    getStateMachine().getCurrentStateName());\n            return Arrays.asList(new Enum<?>[] { Reasons.INVALID_SOURCE_STATE });\n        }\n\n        //\n        // process general listeners\n        //\n        final TransitionGuard generalBeforeResult = getStateMachine().onBeforeTransition(this);\n        if (generalBeforeResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop before transition. Reason=%s"", getName(), generalBeforeResult.getReason());\n            return generalBeforeResult.getReasons();\n        }\n\n        //\n        // process source handlers\n        //\n        final TransitionGuard specificBeforeResult = getSource().onExit(this);\n        if (specificBeforeResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop exiting the state. Reason=%s"", getName(), specificBeforeResult.getReason());\n            return specificBeforeResult.getReasons();\n        }\n\n        //\n        // perform any subclass processing\n        //\n        executeInternal();\n\n        //\n        // process specific target entrance handlers\n        //\n        final TransitionGuard specificAfterResult = getSource().onEnter(this);\n        if (specificAfterResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop entering state. Reason=%s"", getName(), specificAfterResult.getReason());\n            return specificAfterResult.getReasons();\n        }\n\n        //\n        // notify the direct transition listeners that the transition is taking place\n        //\n        final TransitionGuard transGuardResult = notifyListeners();\n        if (transGuardResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop by a transaction listener. Reason=%s"", getName(), transGuardResult.getReason());\n            return transGuardResult.getReasons();\n        }\n\n        //\n        // process general target entrance handlers\n        //\n        final TransitionGuard generalAfterResult = getStateMachine().onAfterTransition(this);\n        if (generalAfterResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop by a transaction listener. Reason=%s"", getName(), generalAfterResult.getReason());\n            return generalAfterResult.getReasons();\n        }\n\n        //\n        // success! Or is it? Anybody think we should stop?\n        //\n        final Collection<Enum<?>> reasons = TransitionGuard.filterReasons(generalBeforeResult,//\n                specificBeforeResult,//\n                specificAfterResult,//\n                transGuardResult,//\n                generalAfterResult);\n\n        if (reasons.isEmpty())\n        {\n            StateLog.debug(""transition \'%s\' proceeding to state \'%s\'"", getName(), getTarget().getName());\n            getStateMachine().setCurrentState(getTarget());\n        }\n        else\n        {\n            StateLog.debug(""transition \'%s\' returning without proceeding to \'%s\', staying in \'%s\' due to: %s"", getName(), getTarget()\n                    .getName(), getStateMachine().getCurrentState().getName(), reasons);\n        }\n\n        return reasons;\n    }\n\n    TestStateMachine getStateMachine()\n    {\n        return getSource().getStateMachine();\n    }\n    \n    private TransitionGuard notifyListeners()\n    {\n        TransitionGuard result = TransitionGuard.ok(); \n        for (final TransitionListener listener : this.listeners)\n        {\n            final TransitionGuard listenerResult = listener.onTransition(this);\n            if (listenerResult.stop())\n            {\n                return listenerResult;\n            }\n            else if (!listenerResult.continueProcessing())\n            {\n                result = listenerResult; \n            }\n        }\n        return result;\n    }\n    \n    /**\n     * @param listener the listener to add\n     * @return true if the listener was added successfully\n     */\n    @Override\n    public <T extends TransitionListener> T registerListener(final T listener)\n    {\n        if (listener == null)\n        {\n            return null;\n        }\n        final boolean success =  this.listeners.add(listener);\n        assert success;\n        return listener;\n    }\n\n    /**\n     * @param listener the listener to remove\n     * @reutrn true if the listener was removed successfully\n     */\n    @Override\n    public boolean unregisterListener(final TransitionListener listener)\n    {\n        if (listener == null)\n        {\n            return false;\n        }\n        return this.listeners.remove(listener);\n    }\n    \n    /**\n     * @return the string value for this transition\n     */\n    @Override\n    public String toString()\n    {\n        return String.format(""%s [%d]: %s --> %s"", getName(), Integer.valueOf(this.listeners.size()), getSource().getName(), getTarget()\n                .getName());\n    }\n}\n')",[286148]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n *\n */\nclass StateNotifier\n{\n    private final List<StateListener> listeners;\n    \n    private enum TransitionType {\n        ENTER {\n            @Override\n            public TransitionGuard fire(final StateListener listener, final Transition transition)\n            {\n                return listener.onEnter(transition);\n            }\n        },\n        EXIT {\n            @Override\n            public TransitionGuard fire(final StateListener listener, final Transition transition)\n            {\n                return listener.onExit(transition);\n            }\n        };\n        \n        public abstract TransitionGuard fire(StateListener listener, Transition trans);\n    }\n\n    /**\n     */\n    StateNotifier()\n    {\n        super();\n        this.listeners = new CopyOnWriteArrayList<StateListener>();\n    }\n\n    /**\n     * @param listener the listener\n     * @return true if the listener was registered\n     */\n    public boolean registerListener(final StateListener listener)\n    {\n        if (listener == null)\n            return false;\n        return this.listeners.add(listener);\n    }\n\n    /**\n     * @param listener the listener\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterListener(final StateListener listener)\n    {\n        if (listener == null)\n            return false;\n        return this.listeners.remove(listener);\n    }\n\n\n    final TransitionGuard onBeforeTransition(final Transition transition)\n    {\n        return fireTransition(transition, TransitionType.EXIT);\n    }\n\n    final TransitionGuard onAfterTransition(final Transition transition)\n    {\n        return fireTransition(transition, TransitionType.ENTER);\n    }\n\n    final TransitionGuard fireTransition(final Transition transition, final TransitionType type)\n    {\n        TransitionGuard result = TransitionGuard.ok();\n\n        //\n        // fire general-purpose listeners\n        //\n        for (final StateListener listener : this.listeners)\n        {\n            final TransitionGuard condition = type.fire(listener, transition);\n            if (condition.stop())\n            {\n                StateLog.debug(""asked to stop immediately by listener \'%s\' for transition \'%s\'. Reason=%s"", listener, transition, condition.getReason());\n                return condition;\n            }\n            else if (!condition.continueProcessing())\n            {\n                StateLog.debug(""asked to stop eventually by listener \'%s\' for transition \'%s\'. Reason=%s"", listener, transition, condition.getReason());\n                // if *any* listener asks to stop, then set the result to stop\n                result = condition;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @return the string representation\n     */\n    @Override\n    public String toString()\n    {\n        final String newLine = String.format(""%n"");\n        final StringBuilder b = new StringBuilder();\n        for (final StateListener listener : this.listeners)\n        {\n            b.append(listener).append(newLine);\n        }\n        return String.format(""Listeners: %s"", b);\n    }\n}\n')",[285012]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsReceivedByHeadOfDelivery\n */\npublic class ClaimsReceivedByHeadOfDeliveryTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the \'ClaimsReceivedByHeadOfDelivery\' state\n     */\n    @Test\n    public void test_executeToClaimsReceivedByHeadOfDelivery()\n    {\n        Assert.assertNotNull(moveToClaimsReceivedByHeadOfDelivery());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for \'receivedByHeadOfDelivery\' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.receivedByHeadOfDelivery().getName();\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the receivedByHeadOfDelivery state\n     */\n    final ClaimsReceivedByHeadOfDelivery moveToClaimsReceivedByHeadOfDelivery()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsReceivedByHeadOfDelivery receivedByHeadOfDelivery = fsm.receivedByHeadOfDelivery();\n\n        // call the method under test\n        fsm.executeToState(receivedByHeadOfDelivery);\n\n        Assert.assertSame(receivedByHeadOfDelivery, fsm.getCurrentState());\n        Assert.assertEquals(receivedByHeadOfDelivery.getName(), fsm.getCurrentStateName());\n        \n        return receivedByHeadOfDelivery;\n    }\n\n    \n    @Test\n    public void test_getPathBetweenClaimsReceivedByHeadOfDeliveryAndClaimsReceivedByDeliveryTeam()\n    {\n\n        final ClaimsReceivedByHeadOfDelivery receivedByHeadOfDelivery = moveToClaimsReceivedByHeadOfDelivery();\n        final ClaimsStateMachine fsm = receivedByHeadOfDelivery.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'receivedByHeadOfDelivery\'"", receivedByHeadOfDelivery, fsm.getCurrentState());\n\n        final TransitionPaths paths = receivedByHeadOfDelivery.getPaths(fsm.receivedByDeliveryTeam());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        receivedByHeadOfDelivery.registerRejectToDeliveryTeamListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'receivedByHeadOfDelivery\'"", receivedByHeadOfDelivery, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.receivedByDeliveryTeam(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'rejectToDeliveryTeam\' transition \n     */\n    @Test\n    public void test_rejectToDeliveryTeam()\n    {\n        final ClaimsReceivedByHeadOfDelivery receivedByHeadOfDelivery = moveToClaimsReceivedByHeadOfDelivery();\n        final ClaimsStateMachine fsm = receivedByHeadOfDelivery.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        receivedByHeadOfDelivery.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        receivedByHeadOfDelivery.rejectToDeliveryTeam();\n\n        //\n        // assert the current state is now ClaimsReceivedByDeliveryTeam\n        //\n        Assert.assertEquals(fsm.receivedByDeliveryTeam(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.receivedByDeliveryTeam().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsRejectToDeliveryTeam.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsRejectToDeliveryTeam.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(receivedByHeadOfDelivery.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReceivedByHeadOfDelivery\' can be moved into the ClaimsReceivedByDeliveryTeam state\n     */\n    @Test\n    public void test_moveToClaimsReceivedByDeliveryTeam()\n    {\n        final ClaimsReceivedByHeadOfDelivery receivedByHeadOfDelivery = moveToClaimsReceivedByHeadOfDelivery();\n        final ClaimsStateMachine fsm = receivedByHeadOfDelivery.getStateMachine();\n        receivedByHeadOfDelivery.getPaths(fsm.receivedByDeliveryTeam());\n        \n    }\n    \n    @Test\n    public void test_getPathBetweenClaimsReceivedByHeadOfDeliveryAndClaimsReadyForPayment()\n    {\n\n        final ClaimsReceivedByHeadOfDelivery receivedByHeadOfDelivery = moveToClaimsReceivedByHeadOfDelivery();\n        final ClaimsStateMachine fsm = receivedByHeadOfDelivery.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'receivedByHeadOfDelivery\'"", receivedByHeadOfDelivery, fsm.getCurrentState());\n\n        final TransitionPaths paths = receivedByHeadOfDelivery.getPaths(fsm.readyForPayment());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        receivedByHeadOfDelivery.registerMarkAsReadyForPaymentListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'receivedByHeadOfDelivery\'"", receivedByHeadOfDelivery, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.readyForPayment(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'markAsReadyForPayment\' transition \n     */\n    @Test\n    public void test_markAsReadyForPayment()\n    {\n        final ClaimsReceivedByHeadOfDelivery receivedByHeadOfDelivery = moveToClaimsReceivedByHeadOfDelivery();\n        final ClaimsStateMachine fsm = receivedByHeadOfDelivery.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        receivedByHeadOfDelivery.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        receivedByHeadOfDelivery.markAsReadyForPayment();\n\n        //\n        // assert the current state is now ClaimsReadyForPayment\n        //\n        Assert.assertEquals(fsm.readyForPayment(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.readyForPayment().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsMarkAsReadyForPayment.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsMarkAsReadyForPayment.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(receivedByHeadOfDelivery.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReceivedByHeadOfDelivery\' can be moved into the ClaimsReadyForPayment state\n     */\n    @Test\n    public void test_moveToClaimsReadyForPayment()\n    {\n        final ClaimsReceivedByHeadOfDelivery receivedByHeadOfDelivery = moveToClaimsReceivedByHeadOfDelivery();\n        final ClaimsStateMachine fsm = receivedByHeadOfDelivery.getStateMachine();\n        receivedByHeadOfDelivery.getPaths(fsm.readyForPayment());\n        \n    }\n}\n')",[271480]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'com.porpoise.fsm.model.TransitionTest')","[428, 32477, 74969, 114960, 160426, 209692]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n *\n */\nabstract class AbstractTransition<SOURCE extends AbstractClaimsState, TARGET extends AbstractClaimsState> implements Transition\n{\n    private final SOURCE sourceState;\n    private final TARGET targetState;\n    \n    private Collection<TransitionListener> listeners;\n\n    AbstractTransition(final SOURCE from, final TARGET to)\n    {\n        if (from == null) \n        {\n            throw new NullPointerException(""source state cannot be null"");\n        }\n        if (to == null) \n        {\n            throw new NullPointerException(""target state cannot be null"");\n        }\n        if (from.getStateMachine() != to.getStateMachine())\n        {\n            throw new NullPointerException(""source and target states are for different state machines"");\n        }\n        this.sourceState = from;\n        this.targetState = to;\n        this.listeners = new CopyOnWriteArrayList<TransitionListener>();\n    }\n\n    public SOURCE getSource()\n    {\n        return this.sourceState;\n    }\n    \n    public TARGET getTarget()\n    {\n        return this.targetState;\n    }\n\n    /**\n     *  hook for subclasses\n     */\n    protected void executeInternal()\n    {\n    // no-op\n    }\n\n    /**\n     * Execute the transition, returning a collection of reasons why the transition could not execute should the transition fail.\n     * Should the transition succeed, an empty collection is returned.\n     * @return a collection of reasons why the transition could not execute should the transition fail\n     */\n    public final Collection<Enum<?>> execute()\n    {\n        if (getSource() != getStateMachine().getCurrentState())\n        {\n            StateLog.error(""Illegal transition \'%s\' called. Current state was expected to be \'%s\' but was \'%s\'"", getName(), getSource().getName(),\n                    getStateMachine().getCurrentStateName());\n            return Arrays.asList(new Enum<?>[] { Reasons.INVALID_SOURCE_STATE });\n        }\n\n        //\n        // process general listeners\n        //\n        final TransitionGuard generalBeforeResult = getStateMachine().onBeforeTransition(this);\n        if (generalBeforeResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop before transition. Reason=%s"", getName(), generalBeforeResult.getReason());\n            return generalBeforeResult.getReasons();\n        }\n\n        //\n        // process source handlers\n        //\n        final TransitionGuard specificBeforeResult = getSource().onExit(this);\n        if (specificBeforeResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop exiting the state. Reason=%s"", getName(), specificBeforeResult.getReason());\n            return specificBeforeResult.getReasons();\n        }\n\n        //\n        // perform any subclass processing\n        //\n        executeInternal();\n\n        //\n        // process specific target entrance handlers\n        //\n        final TransitionGuard specificAfterResult = getSource().onEnter(this);\n        if (specificAfterResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop entering state. Reason=%s"", getName(), specificAfterResult.getReason());\n            return specificAfterResult.getReasons();\n        }\n\n        //\n        // notify the direct transition listeners that the transition is taking place\n        //\n        final TransitionGuard transGuardResult = notifyListeners();\n        if (transGuardResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop by a transaction listener. Reason=%s"", getName(), transGuardResult.getReason());\n            return transGuardResult.getReasons();\n        }\n\n        //\n        // process general target entrance handlers\n        //\n        final TransitionGuard generalAfterResult = getStateMachine().onAfterTransition(this);\n        if (generalAfterResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop by a transaction listener. Reason=%s"", getName(), generalAfterResult.getReason());\n            return generalAfterResult.getReasons();\n        }\n\n        //\n        // success! Or is it? Anybody think we should stop?\n        //\n        final Collection<Enum<?>> reasons = TransitionGuard.filterReasons(generalBeforeResult,//\n                specificBeforeResult,//\n                specificAfterResult,//\n                transGuardResult,//\n                generalAfterResult);\n\n        if (reasons.isEmpty())\n        {\n            StateLog.debug(""transition \'%s\' proceeding to state \'%s\'"", getName(), getTarget().getName());\n            getStateMachine().setCurrentState(getTarget());\n        }\n        else\n        {\n            StateLog.debug(""transition \'%s\' returning without proceeding to \'%s\', staying in \'%s\' due to: %s"", getName(), getTarget()\n                    .getName(), getStateMachine().getCurrentState().getName(), reasons);\n        }\n\n        return reasons;\n    }\n\n    ClaimsStateMachine getStateMachine()\n    {\n        return getSource().getStateMachine();\n    }\n    \n    private TransitionGuard notifyListeners()\n    {\n        TransitionGuard result = TransitionGuard.ok(); \n        for (final TransitionListener listener : this.listeners)\n        {\n            final TransitionGuard listenerResult = listener.onTransition(this);\n            if (listenerResult.stop())\n            {\n                return listenerResult;\n            }\n            else if (!listenerResult.continueProcessing())\n            {\n                result = listenerResult; \n            }\n        }\n        return result;\n    }\n    \n    /**\n     * @param listener the listener to add\n     * @return true if the listener was added successfully\n     */\n    @Override\n    public <T extends TransitionListener> T registerListener(final T listener)\n    {\n        if (listener == null)\n        {\n            return null;\n        }\n        final boolean success =  this.listeners.add(listener);\n        assert success;\n        return listener;\n    }\n\n    /**\n     * @param listener the listener to remove\n     * @reutrn true if the listener was removed successfully\n     */\n    @Override\n    public boolean unregisterListener(final TransitionListener listener)\n    {\n        if (listener == null)\n        {\n            return false;\n        }\n        return this.listeners.remove(listener);\n    }\n    \n    /**\n     * @return the string value for this transition\n     */\n    @Override\n    public String toString()\n    {\n        return String.format(""%s [%d]: %s --> %s"", getName(), Integer.valueOf(this.listeners.size()), getSource().getName(), getTarget()\n                .getName());\n    }\n}\n')",[262613]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_cannotCreateTransitionsBetweenMachines(com.porpoise.fsm.model.TransitionTest)')","[476, 500, 524, 3967, 3998, 4029, 4587, 4618, 4649, 22053, 22077, 22101, 29111, 32392, 32422, 32452, 32533, 32561, 32589, 44940, 44975, 45010, 45640, 45675, 45710, 65394, 65422, 65450, 74890, 74918, 74946, 75021, 75047, 75073, 86610, 86643, 86676, 87270, 87303, 87336, 105880, 105906, 105932, 114869, 114901, 114933, 115020, 115050, 115080, 128245, 128282, 128319, 128985, 129022, 129059, 149883, 149913, 149943, 160326, 160361, 160396, 160492, 160525, 160558, 174944, 174984, 175024, 175744, 175784, 175824, 198358, 198391, 198424, 209586, 209623, 209660, 209762, 209797, 209832, 225032, 225074, 225116, 225872, 225914, 225956, 251426, 251466, 251506, 251590, 251632, 251674]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsRejectToParticipant extends AbstractTransition<ClaimsReceivedByMonitoringOfficer, ClaimsNotReceived>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""reject to participant"";\n\n    TransitionClaimsRejectToParticipant(final ClaimsReceivedByMonitoringOfficer from, final ClaimsNotReceived to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[269170]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\binterface (\\w+).*', 'package aaron.test;\n\npublic interface NamedObject\n{\n    /**\n     * @return a name for the object\n     */\n    public String getName();\n}\n')",[254418]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_fromFile(com.porpoise.fsm.model.StateMachineTest)')","[242, 266, 290, 2107, 2138, 2169, 3223, 3254, 3285, 21285, 21309, 21333, 28903, 31158, 31188, 31218, 31899, 31927, 31955, 42840, 42875, 42910, 44100, 44135, 44170, 64498, 64526, 64554, 73740, 73768, 73796, 74431, 74457, 74483, 84630, 84663, 84696, 85818, 85851, 85884, 105048, 105074, 105100, 113551, 113583, 113615, 114342, 114372, 114402, 126025, 126062, 126099, 127357, 127394, 127431, 148923, 148953, 148983, 158882, 158917, 158952, 159748, 159781, 159814, 172544, 172584, 172624, 173984, 174024, 174064, 197302, 197335, 197368, 208058, 208095, 208132, 208974, 209009, 209044, 222512, 222554, 222596, 224024, 224066, 224108, 248708, 248748, 248788, 249672, 249714, 249756]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_moveToClaimsPaymentReceived(aaron.test.test.ClaimsReadyForPaymentTest)')","[8524, 12244, 24525, 29777, 36304, 50085, 54285, 68278, 78536, 91461, 95421, 108558, 119047, 133684, 138124, 152973, 164903, 180824, 185624, 201757, 214429, 231206, 236246, 294393, 295723]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\n/**\n * tests for ClaimsStateMachine\n */\npublic class ListenerAdapter implements StateListener \n{\n    private TransitionGuard entranceGuard;\n    private TransitionGuard exitGuard;\n\n    /**\n     * Default Constructor\n     */\n    public ListenerAdapter()\n    {\n        this(TransitionGuard.ok(), TransitionGuard.ok());\n    }\n\n    /**\n     * @param entrance the entrance guard\n     * @param exit the exit guard\n     */\n    public ListenerAdapter(final TransitionGuard entrance, final TransitionGuard exit)\n    {\n        if (entrance == null)\n        {\n            throw new NullPointerException(""entrance guard type cannot be null"");\n        }\n        if (exit == null)\n        {\n            throw new NullPointerException(""exit guard type cannot be null"");\n        }\n        this.entranceGuard = entrance;\n        this.exitGuard = exit;\n    }\n\n    /**\n     * @param transition\n     * @return \'continue\'\n     */\n    public TransitionGuard onExit(final Transition transition)\n    {\n        return this.exitGuard;\n    }\n\n    /**\n     * @param transition\n     * @return \'continue\'\n     */\n    public TransitionGuard onEnter(final Transition transition)\n    {\n        return this.entranceGuard;\n    }\n}\n')",[260538]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n *\n */\nclass StateNotifier\n{\n    private final List<StateListener> listeners;\n    \n    private enum TransitionType {\n        ENTER {\n            @Override\n            public TransitionGuard fire(final StateListener listener, final Transition transition)\n            {\n                return listener.onEnter(transition);\n            }\n        },\n        EXIT {\n            @Override\n            public TransitionGuard fire(final StateListener listener, final Transition transition)\n            {\n                return listener.onExit(transition);\n            }\n        };\n        \n        public abstract TransitionGuard fire(StateListener listener, Transition trans);\n    }\n\n    /**\n     */\n    StateNotifier()\n    {\n        super();\n        this.listeners = new CopyOnWriteArrayList<StateListener>();\n    }\n\n    /**\n     * @param listener the listener\n     * @return true if the listener was registered\n     */\n    public boolean registerListener(final StateListener listener)\n    {\n        if (listener == null)\n            return false;\n        return this.listeners.add(listener);\n    }\n\n    /**\n     * @param listener the listener\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterListener(final StateListener listener)\n    {\n        if (listener == null)\n            return false;\n        return this.listeners.remove(listener);\n    }\n\n\n    final TransitionGuard onBeforeTransition(final Transition transition)\n    {\n        return fireTransition(transition, TransitionType.EXIT);\n    }\n\n    final TransitionGuard onAfterTransition(final Transition transition)\n    {\n        return fireTransition(transition, TransitionType.ENTER);\n    }\n\n    final TransitionGuard fireTransition(final Transition transition, final TransitionType type)\n    {\n        TransitionGuard result = TransitionGuard.ok();\n\n        //\n        // fire general-purpose listeners\n        //\n        for (final StateListener listener : this.listeners)\n        {\n            final TransitionGuard condition = type.fire(listener, transition);\n            if (condition.stop())\n            {\n                StateLog.debug(""asked to stop immediately by listener \'%s\' for transition \'%s\'. Reason=%s"", listener, transition, condition.getReason());\n                return condition;\n            }\n            else if (!condition.continueProcessing())\n            {\n                StateLog.debug(""asked to stop eventually by listener \'%s\' for transition \'%s\'. Reason=%s"", listener, transition, condition.getReason());\n                // if *any* listener asks to stop, then set the result to stop\n                result = condition;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @return the string representation\n     */\n    @Override\n    public String toString()\n    {\n        final String newLine = String.format(""%n"");\n        final StringBuilder b = new StringBuilder();\n        for (final StateListener listener : this.listeners)\n        {\n            b.append(listener).append(newLine);\n        }\n        return String.format(""Listeners: %s"", b);\n    }\n}\n')",[261711]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport com.google.common.base.Predicate;\n\n/**\n * a listener which can be turned on and off by the given predicate\n */\npublic class ConditionalStateListener extends AbstractConditionalStateListener \n{\n    private final StateListener wrappedListener;\n\n    /**\n     * @param predicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener will be executed.\n     * @param listener\n     */\n    public ConditionalStateListener(final Predicate<Transition> predicate, final StateListener listener)\n    {\n        this(predicate, predicate, listener);\n    }\n\n    /**\n     * @param enterPredicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener\'s onEnter will be executed.\n     * @param exitPredicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener\'s onExit method will be executed.\n     * @param predicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener will be executed.\n     * @param listener\n     */\n    public ConditionalStateListener(final Predicate<Transition> enterPredicate, final Predicate<Transition> exitPredicate, final StateListener listener)\n    {\n        this(enterPredicate, exitPredicate, listener, TransitionGuard.ok(), TransitionGuard.ok());\n    }\n\n    /**\n     * @param enterPredicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener\'s onEnter will be executed.\n     * @param exitPredicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener\'s onExit method will be executed.\n     * @param predicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener will be executed.\n     * @param listener\n     * @param enterDefault the transition to return should the enter predicate filter return false\n     * @param exitDefault the transition to return should the exit predicate filter return false\n     */\n    public ConditionalStateListener(final Predicate<Transition> enterPredicate, final Predicate<Transition> exitPredicate, final StateListener listener, final TransitionGuard enterDefault, final TransitionGuard exitDefault)\n    {\n        super(enterPredicate, exitPredicate, exitDefault, exitDefault);\n        if (listener == null)\n        {\n            throw new NullPointerException(""listener cannot be null"");\n        }\n        this.wrappedListener = listener;\n    }\n   \n    /**\n     * @param transition\n     * @return the transition return value.  \n     */\n    @Override\n    protected TransitionGuard onExitInternal(final Transition transition)\n    {\n        return this.wrappedListener.onExit(transition);\n    }\n\n    /**\n     * @param transition\n     * @return the transition return value.  \n     */\n    @Override\n    protected TransitionGuard onEnterInternal(final Transition transition)\n    {\n        return this.wrappedListener.onEnter(transition);\n    }\n}\n')",[256332]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\n\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Set;\nimport java.util.HashSet;\n\n/**\n * A TransitionPath represents a chain of transitions from one state to another\n */\nenum PathFilters\n{\n    ; // uninstantiable\n\n    /**\n     * @return a TransitionPath filter which returns \'true\' when a path contains a transition\n     * with the given name\n     */\n    public static final Predicate<TransitionPath> byName(final String name)\n    {\n        return new Predicate<TransitionPath>() {\n            public boolean apply(final TransitionPath path) {\n                return path.containsTransition(name);\n            }\n        };\n    }\n\n    /**\n     * @return a TransitionPath filter which returns \'true\' when a path contains a transition with one of the given names\n     */\n     @SuppressWarnings(""unchecked"")\n    public static final Predicate<TransitionPath> byNames(final String ... names)\n    {\n        final Set<String> uniqueNames = new HashSet<String>(Arrays.asList(names));\n        final Collection<Predicate<TransitionPath>> filters = new ArrayList<Predicate<TransitionPath>>(uniqueNames.size());\n        for (final String name : uniqueNames)\n        {\n            if (name != null)\n            {\n                filters.add(byName(name));\n            }\n        }\n        Predicate<TransitionPath>[] filtersArray = new Predicate[filters.size()];\n        filtersArray = filters.toArray(filtersArray);\n        return Predicates.or(filtersArray);\n    }\n}\n')",[259014]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\n/**\n * tests for TestStateMachine\n */\npublic class ListenerAdapter implements StateListener \n{\n    private TransitionGuard entranceGuard;\n    private TransitionGuard exitGuard;\n\n    /**\n     * Default Constructor\n     */\n    public ListenerAdapter()\n    {\n        this(TransitionGuard.ok(), TransitionGuard.ok());\n    }\n\n    /**\n     * @param entrance the entrance guard\n     * @param exit the exit guard\n     */\n    public ListenerAdapter(final TransitionGuard entrance, final TransitionGuard exit)\n    {\n        if (entrance == null)\n        {\n            throw new NullPointerException(""entrance guard type cannot be null"");\n        }\n        if (exit == null)\n        {\n            throw new NullPointerException(""exit guard type cannot be null"");\n        }\n        this.entranceGuard = entrance;\n        this.exitGuard = exit;\n    }\n\n    /**\n     * @param transition\n     * @return \'continue\'\n     */\n    public TransitionGuard onExit(final Transition transition)\n    {\n        return this.exitGuard;\n    }\n\n    /**\n     * @param transition\n     * @return \'continue\'\n     */\n    public TransitionGuard onEnter(final Transition transition)\n    {\n        return this.entranceGuard;\n    }\n}\n')",[283839]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_executeToClaimsNotReceived(aaron.test.test.ClaimsNotReceivedTest)')","[6323, 6354, 6385, 8927, 8958, 8989, 23013, 23037, 23061, 34277, 34307, 34337, 47600, 47635, 47670, 50540, 50575, 50610, 66514, 66542, 66570, 76645, 76673, 76701, 89118, 89151, 89184, 91890, 91923, 91956, 106920, 106946, 106972, 116884, 116916, 116948, 131057, 131094, 131131, 134165, 134202, 134239, 151083, 151113, 151143, 162536, 162571, 162606, 177984, 178024, 178064, 181344, 181384, 181424, 199678, 199711, 199744, 211926, 211963, 212000, 228224, 228266, 228308, 231752, 231794, 231836, 289931, 289971, 290011, 291703, 291745, 291787]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * <p>\n * state transitions are checked using guard conditions. There may be state exit conditions, transition conditions, and state enter\n * conditions. Each of these conditions will return a {@link TransitionGuard}, signaling if the state transition should be allowed to continue.\n * If all guards allow the transition to continue, then a state transition will take place. However, a guard condition may signal that the\n * state transition should not continue, either stopping immediately or stop once the remaining transition listeners are notified.\n * </p>\n * <p>\n * In addition to controlling the state transitions, a transition guard may also specify a \'reason\' should the guard not allow processing.\n * The reason can be a generic {@link Enum} type. If no reason is given then {@link #getReason()} will return\n * {@link Reasons#NO_REASON_GIVEN}.\n * </p>\n */\npublic class TransitionGuard\n{\n    /**\n     * Default \'stop\' Reasons\n     */\n    public enum Reasons\n    {\n        NO_REASON_GIVEN,//\n        ALREADY_IN_TARGET_STATE, // \n        TARGET_STATE_UNREACHABLE;\n    }\n\n    /**\n     * This enumeration allows listeners to notify the state machine whether or not it should continue processing. Using this mechanism we\n     * avoid listeners having to throw exceptions for process flow.\n     */\n    public enum Type\n    {\n        /**\n        *\n        */\n        CONTINUE\n        {\n            @Override\n            boolean continueProcessingInternal()\n            {\n                return true;\n            }\n\n            @Override\n            boolean stopInternal()\n            {\n                return false;\n            }\n        }, //\n        /**\n        *\n        */\n        STOP_IMMEDIATELY\n        {\n            @Override\n            boolean continueProcessingInternal()\n            {\n                return false;\n            }\n\n            @Override\n            boolean stopInternal()\n            {\n                return true;\n            }\n        }, //\n        /**\n        *\n        */\n        STOP_AFTER_PROCESSING_REMAINING_LISTENERS\n        {\n            @Override\n            boolean continueProcessingInternal()\n            {\n                return false;\n            }\n\n            @Override\n            boolean stopInternal()\n            {\n                return false;\n            }\n        }\n\n        ;//\n\n        abstract boolean continueProcessingInternal();\n\n        boolean continueProcessing()\n        {\n            final boolean result = continueProcessingInternal();\n            if (!result)\n            {\n                StateLog.trace(""asked to stop eventually"");\n            }\n            return result;\n        }\n\n        abstract boolean stopInternal();\n\n        boolean stop()\n        {\n            final boolean result = stopInternal();\n            if (result)\n            {\n                StateLog.trace(""asked to stop immediately"");\n            }\n            return result;\n        }\n    }\n\n    private final Type    type;\n    private final Enum<?> reason;\n\n    /**\n     * @return the type\n     */\n    public Type getType()\n    {\n        return this.type;\n    }\n\n    /**\n     * @return the reason, or {@link Reasons#NO_REASON_GIVEN} if no reason was specified\n     */\n    public Enum<?> getReason()\n    {\n        return this.reason == null ? Reasons.NO_REASON_GIVEN : this.reason;\n    }\n    \n    /**\n     * @return the reason as a collection\n     */\n    final  Collection<Enum<?>> getReasons()\n    {\n        if (this.reason == null)\n        {\n            return Collections.emptyList();\n        }\n        final Collection<Enum<?>> reasons = new ArrayList<Enum<?>>();\n        reasons.add(getReason());\n        return reasons;\n    }\n    public TransitionGuard(final Type t, final Enum<?> reasonValue)\n    {\n        this.type = t;\n        this.reason = reasonValue;\n    }\n\n    /**\n     * return a collection of reasons given for any stopping guards given.\n     * If all guards are of type \'continue\' then an empty collection is returned. \n     * @return a collection of reason enumerations for the given guards\n     */\n    static Collection<Enum<?>> filterReasons(final TransitionGuard... guards)\n    {\n        Collection<Enum<?>> reasons = null;\n        for (final TransitionGuard guard : guards)\n        {\n            if (!guard.continueProcessing())\n            {\n                if (reasons == null)\n                {\n                    reasons = new ArrayList<Enum<?>>();\n                }\n                reasons.add(guard.getReason());\n            }\n        }\n        if (reasons == null)\n        {\n            reasons = Collections.emptyList();\n        }\n\n        return reasons;\n    }\n\n    private static final TransitionGuard GUARD_CONTINUE         = new TransitionGuard(Type.CONTINUE, null);\n    private static final TransitionGuard GUARD_STOP_IMMIDIATELY = new TransitionGuard(Type.STOP_IMMEDIATELY, null);\n    private static final TransitionGuard GUARD_STOP_EVENTUALLY  = new TransitionGuard(Type.STOP_AFTER_PROCESSING_REMAINING_LISTENERS, null);\n\n    /**\n     * @return true if the transition should stop\n     */\n    public boolean stop()\n    {\n        return this.type.stop();\n    }\n\n    /**\n     * @return true if the transition should continue\n     */\n    public boolean continueProcessing()\n    {\n        return this.type.continueProcessing();\n    }\n\n    /**\n     * @return a generic \'continue\' transition guard\n     */\n    public static TransitionGuard ok()\n    {\n        return GUARD_CONTINUE;\n    }\n\n    /**\n     * @return a generic stop immediately transition guard\n     */\n    public static TransitionGuard stopImmediately()\n    {\n        return GUARD_STOP_IMMIDIATELY;\n    }\n\n    /**\n     * @param reason\n     * @return a generic stop eventually transition guard\n     */\n    public static TransitionGuard stopImmediately(final Enum<?> stopReason)\n    {\n        return new TransitionGuard(Type.STOP_IMMEDIATELY, stopReason);\n    }\n\n    /**\n     * @return a generic stop eventually transition guard\n     */\n    public static TransitionGuard stopEventually()\n    {\n        return GUARD_STOP_EVENTUALLY;\n    }\n\n    /**\n     * @param reason\n     * @return a generic stop eventually transition guard\n     */\n    public static TransitionGuard stopEventually(final Enum<?> stopReason)\n    {\n        return new TransitionGuard(Type.STOP_AFTER_PROCESSING_REMAINING_LISTENERS, stopReason);\n    }\n    \n    /**\n     * @return the string representation\n     */\n    @Override\n    public String toString()\n    {\n        return String.format(""%s [%s]"", this.type, this.reason);\n    }\n}\n')",[257873]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\n/**\n * listener callback interface \n */\npublic interface TransitionListener\n{\n\n    /**\n     * fired when a transition is executed\n     * @return the transition guard\n     */\n    TransitionGuard onTransition(final Transition transition);\n}\n')",[280141]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_asPropertyName(com.porpoise.fsm.generator.context.ContextTest)')","[5331, 5362, 5393, 6075, 6106, 6137, 22629, 22653, 22677, 33523, 33553, 33583, 46480, 46515, 46550, 47320, 47355, 47390, 66066, 66094, 66122, 75943, 75971, 75999, 88062, 88095, 88128, 88854, 88887, 88920, 106504, 106530, 106556, 116078, 116110, 116142, 129873, 129910, 129947, 130761, 130798, 130835, 150603, 150633, 150663, 161652, 161687, 161722, 176704, 176744, 176784, 177664, 177704, 177744, 199150, 199183, 199216, 210990, 211027, 211064, 226880, 226922, 226964, 227888, 227930, 227972, 288431, 288471, 288511, 288763, 288805, 288847]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsPaymentReceived\n */\npublic class ClaimsPaymentReceivedTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the \'ClaimsPaymentReceived\' state\n     */\n    @Test\n    public void test_executeToClaimsPaymentReceived()\n    {\n        Assert.assertNotNull(moveToClaimsPaymentReceived());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for \'paymentReceived\' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.paymentReceived().getName();\n        Assert.assertEquals(fsm.paymentReceived(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the paymentReceived state\n     */\n    final ClaimsPaymentReceived moveToClaimsPaymentReceived()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsPaymentReceived paymentReceived = fsm.paymentReceived();\n\n        // call the method under test\n        fsm.executeToState(paymentReceived);\n\n        Assert.assertSame(paymentReceived, fsm.getCurrentState());\n        Assert.assertEquals(paymentReceived.getName(), fsm.getCurrentStateName());\n        \n        return paymentReceived;\n    }\n\n    \n    @Test\n    public void test_getPathBetweenClaimsPaymentReceivedAndClaimsPaymentComplete()\n    {\n\n        final ClaimsPaymentReceived paymentReceived = moveToClaimsPaymentReceived();\n        final ClaimsStateMachine fsm = paymentReceived.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'paymentReceived\'"", paymentReceived, fsm.getCurrentState());\n\n        final TransitionPaths paths = paymentReceived.getPaths(fsm.paymentComplete());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        paymentReceived.registerMarkPaymentAsCompleteListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'paymentReceived\'"", paymentReceived, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.paymentComplete(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'markPaymentAsComplete\' transition \n     */\n    @Test\n    public void test_markPaymentAsComplete()\n    {\n        final ClaimsPaymentReceived paymentReceived = moveToClaimsPaymentReceived();\n        final ClaimsStateMachine fsm = paymentReceived.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        paymentReceived.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        paymentReceived.markPaymentAsComplete();\n\n        //\n        // assert the current state is now ClaimsPaymentComplete\n        //\n        Assert.assertEquals(fsm.paymentComplete(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.paymentComplete().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsMarkPaymentAsComplete.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsMarkPaymentAsComplete.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(paymentReceived.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsPaymentReceived\' can be moved into the ClaimsPaymentComplete state\n     */\n    @Test\n    public void test_moveToClaimsPaymentComplete()\n    {\n        final ClaimsPaymentReceived paymentReceived = moveToClaimsPaymentReceived();\n        final ClaimsStateMachine fsm = paymentReceived.getStateMachine();\n        paymentReceived.getPaths(fsm.paymentComplete());\n        \n    }\n}\n')",[273061]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\nimport com.google.common.base.Predicate;\n\n/**\n * a listener which can be turned on and off by the given predicate\n */\npublic abstract class AbstractConditionalStateListener implements StateListener\n{\n    private final Predicate<Transition> enterFilter;\n    private final Predicate<Transition> exitFilter;\n    private final TransitionGuard        enterReturnValueOnPredicateFalse;\n    private final TransitionGuard        exitReturnValueOnPredicateFalse;\n\n    /**\n     * @param predicate\n     *            the predicate logic used to filter the given listener.\n     */\n    public AbstractConditionalStateListener(final Predicate<Transition> predicate)\n    {\n        this(predicate, predicate);\n    }\n\n    /**\n     * @param enterPredicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener\'s onEnter will be executed.\n     * @param exitPredicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener\'s onExit method will be executed.\n     */\n    public AbstractConditionalStateListener(final Predicate<Transition> enterPredicate, final Predicate<Transition> exitPredicate)\n    {\n        this(enterPredicate, exitPredicate, TransitionGuard.ok(), TransitionGuard.ok());\n    }\n\n    /**\n     * @param enterPredicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener\'s onEnter will be executed.\n     * @param exitPredicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener\'s onExit method will be executed.\n     * @param predicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener will be executed.\n     * @param listener\n     * @param enterDefault\n     *            the transition to return should the enter predicate filter return false\n     * @param exitDefault\n     *            the transition to return should the exit predicate filter return false\n     */\n    public AbstractConditionalStateListener(final Predicate<Transition> enterPredicate, final Predicate<Transition> exitPredicate,\n            final TransitionGuard enterDefault, final TransitionGuard exitDefault)\n    {\n        if (enterPredicate == null)\n        {\n            throw new NullPointerException(""enterPredicate cannot be null"");\n        }\n        if (enterDefault == null)\n        {\n            throw new NullPointerException(""enterDefault cannot be null"");\n        }\n        if (exitPredicate == null)\n        {\n            throw new NullPointerException(""exitPredicate cannot be null"");\n        }\n        if (exitDefault == null)\n        {\n            throw new NullPointerException(""exitDefault cannot be null"");\n        }\n        this.enterFilter = enterPredicate;\n        this.exitFilter = exitPredicate;\n\n        this.enterReturnValueOnPredicateFalse = enterDefault;\n        this.exitReturnValueOnPredicateFalse = exitDefault;\n    }\n\n    /**\n     * the exit condition predicate was successful. Return the result from the exit listener logic.\n     * \n     * @param transition\n     *            the transition\n     * @return the transition return value.\n     */\n    protected abstract TransitionGuard onExitInternal(final Transition transition);\n\n    /**\n     * the enter condition predicate was successful. Return the result from the exit listener logic.\n     * \n     * @param transition\n     *            the transition\n     * @return the transition return value.\n     */\n    protected abstract TransitionGuard onEnterInternal(final Transition transition);\n\n    /**\n     * @param transition\n     * @return the transition return value.\n     */\n    public final TransitionGuard onExit(final Transition transition)\n    {\n        if (!this.exitFilter.apply(transition))\n        {\n            return this.exitReturnValueOnPredicateFalse;\n        }\n        return onExitInternal(transition);\n    }\n\n    /**\n     * @param transition\n     * @return the transition return value.\n     */\n    @Override\n    public final TransitionGuard onEnter(final Transition transition)\n    {\n        if (!this.enterFilter.apply(transition))\n        {\n            return this.enterReturnValueOnPredicateFalse;\n        }\n        return onEnterInternal(transition);\n    }\n\n    /**\n     * @return the return value to use when the predicate logic evaluates to \'false\'\n     */\n    protected TransitionGuard getDefaultEnterReturnValueOnFalse()\n    {\n        return this.enterReturnValueOnPredicateFalse;\n    }\n\n    /**\n     * @return the return value to use when the predicate logic evaluates to \'false\'\n     */\n    protected TransitionGuard getDefaultExitReturnValueOnFalse()\n    {\n        return this.exitReturnValueOnPredicateFalse;\n    }\n\n    @Override\n    public String toString()\n    {\n        return String.format(""conditional listener[enter=%s, exit=%s]"", this.enterFilter, this.exitFilter);\n    }\n}')",[279027]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsRejectPayment extends AbstractTransition<ClaimsReadyForPayment, ClaimsPaymentRejected>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""reject payment"";\n\n    TransitionClaimsRejectPayment(final ClaimsReadyForPayment from, final ClaimsPaymentRejected to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[264407]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_toAndFromXml(com.porpoise.fsm.model.StateMachineTest)')","[2355, 2386, 2417, 3471, 3502, 3533, 21477, 21501, 21525, 31398, 31428, 31458, 43120, 43155, 43190, 44380, 44415, 44450, 64722, 64750, 64778, 73964, 73992, 74020, 84894, 84927, 84960, 86082, 86115, 86148, 105256, 105282, 105308, 113807, 113839, 113871, 126321, 126358, 126395, 127653, 127690, 127727, 149163, 149193, 149223, 159162, 159197, 159232, 172864, 172904, 172944, 174304, 174344, 174384, 197566, 197599, 197632, 208354, 208391, 208428, 222848, 222890, 222932, 224360, 224402, 224444, 249028, 249068, 249108, 250008, 250050, 250092]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\n\n/**\n * A collection of useful implementations of TransitionListener\n */\npublic enum TransitionListeners \n{\n    ;//uninstantiable\n\n    /**\n     * a listener which records the transitions\n     */\n    public static class RecordingTransitionListener implements TransitionListener\n    {\n        private final List<Transition> transitions = new ArrayList<Transition>();\n\n        @Override\n        public TransitionGuard onTransition(final Transition transition)\n        {\n            this.transitions.add(transition);\n            return TransitionGuard.ok();\n        }\n\n        /**\n         * @return the enter transitions\n         */\n        public List<Transition> getTransitions()\n        {\n            return Collections.unmodifiableList(this.transitions);\n        }\n    }\n    \n    private static class BlockingListener implements TransitionListener\n    {\n        private final Enum<?> reason;\n        public BlockingListener(final Enum<?> reasonValue)\n        {\n            this.reason = reasonValue;\n        }\n    \n        @Override\n        public TransitionGuard onTransition(final Transition transition)\n        {\n            return TransitionGuard.stopEventually(this.reason);\n        }\n    }\n    \n    private static TransitionListener BLOCKING_INSTANCE = new BlockingListener(null); \n\n    /**\n     * @return a new recording transition listener\n     */\n    public static RecordingTransitionListener recordingListener()\n    {\n        return new RecordingTransitionListener();\n    }\n    /**\n     * @return a listener which returns @{code TransitionGuard.stopEventually()}\n     */\n    public static TransitionListener blockingListener()\n    {\n        return BLOCKING_INSTANCE;\n    }\n    /**\n     * @return a listener which returns @{code TransitionGuard.stopEventually()}\n     */\n    public static TransitionListener blockingListener(final Enum<?> reason)\n    {\n        return new BlockingListener(reason);\n    }\n    \n    /**\n     * @return a listener which disallows transitions when the given condition returns false\n     */\n    public static TransitionListener blockOnFalse(final Predicate<Transition> condition, final Enum<?> reason)\n    {\n        final TransitionListener delegate = TransitionListeners.blockingListener(reason);\n        final TransitionListener listener = filter(condition, delegate);\n        return listener;\n    }\n\n    /**\n     * @param condition\n     *            the condition (predicate) used to evaluate whether or not the given listener should be invoked\n     * @param delegate\n     *            the listener to invoke when the condition returns true\n     * @return the conditional listener which wraps the given listener\n     */\n    public static ConditionalTransitionListener filter(final Predicate<Transition> condition, final TransitionListener delegate)\n    {\n        final ConditionalTransitionListener listener = new ConditionalTransitionListener(condition, delegate);\n        return listener;\n    }    \n    /**\n     * @return a listener which disallows transitions when the given condition returns true\n     */\n    public static TransitionListener blockOnTrue(final Predicate<Transition> condition, final Enum<?> reason)\n    {\n        return blockOnFalse(Predicates.not(condition), reason);\n    }\n\n }')",[278419]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_approveForHeadOfDelivery(aaron.test.test.ClaimsReceivedByMonitoringOfficerTest)')","[11004, 14352, 25389, 29986, 37521, 52885, 56665, 69286, 79671, 94101, 97665, 109494, 120346, 136644, 140640, 154053, 166325, 184024, 188344, 202945, 215933, 234566, 239102, 297271, 299089]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\n/**\n * listener callback interface \n */\npublic interface TransitionListener\n{\n\n    /**\n     * fired when a transition is executed\n     * @return the transition guard\n     */\n    TransitionGuard onTransition(final Transition transition);\n}\n')",[280261]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getStateForName(aaron.test.test.ClaimsReceivedByMonitoringOfficerTest)')","[1271, 10136, 13484, 24717, 29819, 36681, 38024, 51905, 55685, 68502, 78887, 80140, 93177, 96741, 108766, 119450, 120883, 135608, 139604, 153213, 165345, 166913, 182904, 187224, 202021, 214897, 216555, 233390, 237926, 296151, 297913]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsMarkAsReadyForPayment extends AbstractTransition<ClaimsReceivedByHeadOfDelivery, ClaimsReadyForPayment>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""mark as ready for payment"";\n\n    TransitionClaimsMarkAsReadyForPayment(final ClaimsReceivedByHeadOfDelivery from, final ClaimsReadyForPayment to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[265263]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * <p>\n * state transitions are checked using guard conditions. There may be state exit conditions, transition conditions, and state enter\n * conditions. Each of these conditions will return a {@link TransitionGuard}, signaling if the state transition should be allowed to continue.\n * If all guards allow the transition to continue, then a state transition will take place. However, a guard condition may signal that the\n * state transition should not continue, either stopping immediately or stop once the remaining transition listeners are notified.\n * </p>\n * <p>\n * In addition to controlling the state transitions, a transition guard may also specify a \'reason\' should the guard not allow processing.\n * The reason can be a generic {@link Enum} type. If no reason is given then {@link #getReason()} will return\n * {@link Reasons#NO_REASON_GIVEN}.\n * </p>\n */\npublic class TransitionGuard\n{\n    /**\n     * Default \'stop\' Reasons\n     */\n    public enum Reasons\n    {\n        NO_REASON_GIVEN,//\n        ALREADY_IN_TARGET_STATE, // \n        TARGET_STATE_UNREACHABLE;\n    }\n\n    /**\n     * This enumeration allows listeners to notify the state machine whether or not it should continue processing. Using this mechanism we\n     * avoid listeners having to throw exceptions for process flow.\n     */\n    public enum Type\n    {\n        /**\n        *\n        */\n        CONTINUE\n        {\n            @Override\n            boolean continueProcessingInternal()\n            {\n                return true;\n            }\n\n            @Override\n            boolean stopInternal()\n            {\n                return false;\n            }\n        }, //\n        /**\n        *\n        */\n        STOP_IMMEDIATELY\n        {\n            @Override\n            boolean continueProcessingInternal()\n            {\n                return false;\n            }\n\n            @Override\n            boolean stopInternal()\n            {\n                return true;\n            }\n        }, //\n        /**\n        *\n        */\n        STOP_AFTER_PROCESSING_REMAINING_LISTENERS\n        {\n            @Override\n            boolean continueProcessingInternal()\n            {\n                return false;\n            }\n\n            @Override\n            boolean stopInternal()\n            {\n                return false;\n            }\n        }\n\n        ;//\n\n        abstract boolean continueProcessingInternal();\n\n        boolean continueProcessing()\n        {\n            final boolean result = continueProcessingInternal();\n            if (!result)\n            {\n                StateLog.trace(""asked to stop eventually"");\n            }\n            return result;\n        }\n\n        abstract boolean stopInternal();\n\n        boolean stop()\n        {\n            final boolean result = stopInternal();\n            if (result)\n            {\n                StateLog.trace(""asked to stop immediately"");\n            }\n            return result;\n        }\n    }\n\n    private final Type    type;\n    private final Enum<?> reason;\n\n    /**\n     * @return the type\n     */\n    public Type getType()\n    {\n        return this.type;\n    }\n\n    /**\n     * @return the reason, or {@link Reasons#NO_REASON_GIVEN} if no reason was specified\n     */\n    public Enum<?> getReason()\n    {\n        return this.reason == null ? Reasons.NO_REASON_GIVEN : this.reason;\n    }\n    \n    /**\n     * @return the reason as a collection\n     */\n    final  Collection<Enum<?>> getReasons()\n    {\n        if (this.reason == null)\n        {\n            return Collections.emptyList();\n        }\n        final Collection<Enum<?>> reasons = new ArrayList<Enum<?>>();\n        reasons.add(getReason());\n        return reasons;\n    }\n    public TransitionGuard(final Type t, final Enum<?> reasonValue)\n    {\n        this.type = t;\n        this.reason = reasonValue;\n    }\n\n    /**\n     * return a collection of reasons given for any stopping guards given.\n     * If all guards are of type \'continue\' then an empty collection is returned. \n     * @return a collection of reason enumerations for the given guards\n     */\n    static Collection<Enum<?>> filterReasons(final TransitionGuard... guards)\n    {\n        Collection<Enum<?>> reasons = null;\n        for (final TransitionGuard guard : guards)\n        {\n            if (!guard.continueProcessing())\n            {\n                if (reasons == null)\n                {\n                    reasons = new ArrayList<Enum<?>>();\n                }\n                reasons.add(guard.getReason());\n            }\n        }\n        if (reasons == null)\n        {\n            reasons = Collections.emptyList();\n        }\n\n        return reasons;\n    }\n\n    private static final TransitionGuard GUARD_CONTINUE         = new TransitionGuard(Type.CONTINUE, null);\n    private static final TransitionGuard GUARD_STOP_IMMIDIATELY = new TransitionGuard(Type.STOP_IMMEDIATELY, null);\n    private static final TransitionGuard GUARD_STOP_EVENTUALLY  = new TransitionGuard(Type.STOP_AFTER_PROCESSING_REMAINING_LISTENERS, null);\n\n    /**\n     * @return true if the transition should stop\n     */\n    public boolean stop()\n    {\n        return this.type.stop();\n    }\n\n    /**\n     * @return true if the transition should continue\n     */\n    public boolean continueProcessing()\n    {\n        return this.type.continueProcessing();\n    }\n\n    /**\n     * @return a generic \'continue\' transition guard\n     */\n    public static TransitionGuard ok()\n    {\n        return GUARD_CONTINUE;\n    }\n\n    /**\n     * @return a generic stop immediately transition guard\n     */\n    public static TransitionGuard stopImmediately()\n    {\n        return GUARD_STOP_IMMIDIATELY;\n    }\n\n    /**\n     * @param reason\n     * @return a generic stop eventually transition guard\n     */\n    public static TransitionGuard stopImmediately(final Enum<?> stopReason)\n    {\n        return new TransitionGuard(Type.STOP_IMMEDIATELY, stopReason);\n    }\n\n    /**\n     * @return a generic stop eventually transition guard\n     */\n    public static TransitionGuard stopEventually()\n    {\n        return GUARD_STOP_EVENTUALLY;\n    }\n\n    /**\n     * @param reason\n     * @return a generic stop eventually transition guard\n     */\n    public static TransitionGuard stopEventually(final Enum<?> stopReason)\n    {\n        return new TransitionGuard(Type.STOP_AFTER_PROCESSING_REMAINING_LISTENERS, stopReason);\n    }\n    \n    /**\n     * @return the string representation\n     */\n    @Override\n    public String toString()\n    {\n        return String.format(""%s [%s]"", this.type, this.reason);\n    }\n}\n')",[280896]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsApproveForDeliveryTeam extends AbstractTransition<ClaimsReceivedByMonitoringOfficer, ClaimsReceivedByDeliveryTeam>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""approve for delivery team"";\n\n    TransitionClaimsApproveForDeliveryTeam(final ClaimsReceivedByMonitoringOfficer from, final ClaimsReceivedByDeliveryTeam to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[268852]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsReceivedByMonitoringOfficerAndClaimsReceivedByHeadOfDelivery(aaron.test.test.ClaimsReceivedByMonitoringOfficerTest)')","[10911, 10942, 10973, 14259, 14290, 14321, 25317, 25341, 25365, 37431, 37461, 37491, 52780, 52815, 52850, 56560, 56595, 56630, 69202, 69230, 69258, 79587, 79615, 79643, 94002, 94035, 94068, 97566, 97599, 97632, 109416, 109442, 109468, 120250, 120282, 120314, 136533, 136570, 136607, 140529, 140566, 140603, 153963, 153993, 154023, 166220, 166255, 166290, 183904, 183944, 183984, 188224, 188264, 188304, 202846, 202879, 202912, 215822, 215859, 215896, 234440, 234482, 234524, 238976, 239018, 239060, 297151, 297191, 297231, 298963, 299005, 299047]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', ""package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsPaymentComplete\n */\npublic class ClaimsPaymentCompleteTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the 'ClaimsPaymentComplete' state\n     */\n    @Test\n    public void test_executeToClaimsPaymentComplete()\n    {\n        Assert.assertNotNull(moveToClaimsPaymentComplete());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for 'paymentComplete' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.paymentComplete().getName();\n        Assert.assertEquals(fsm.paymentComplete(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the paymentComplete state\n     */\n    final ClaimsPaymentComplete moveToClaimsPaymentComplete()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsPaymentComplete paymentComplete = fsm.paymentComplete();\n\n        // call the method under test\n        fsm.executeToState(paymentComplete);\n\n        Assert.assertSame(paymentComplete, fsm.getCurrentState());\n        Assert.assertEquals(paymentComplete.getName(), fsm.getCurrentStateName());\n        \n        return paymentComplete;\n    }\n\n}\n"")",[274412]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsReceivedByDeliveryTeam\n */\npublic class ClaimsReceivedByDeliveryTeamTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the \'ClaimsReceivedByDeliveryTeam\' state\n     */\n    @Test\n    public void test_executeToClaimsReceivedByDeliveryTeam()\n    {\n        Assert.assertNotNull(moveToClaimsReceivedByDeliveryTeam());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for \'receivedByDeliveryTeam\' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.receivedByDeliveryTeam().getName();\n        Assert.assertEquals(fsm.receivedByDeliveryTeam(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the receivedByDeliveryTeam state\n     */\n    final ClaimsReceivedByDeliveryTeam moveToClaimsReceivedByDeliveryTeam()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsReceivedByDeliveryTeam receivedByDeliveryTeam = fsm.receivedByDeliveryTeam();\n\n        // call the method under test\n        fsm.executeToState(receivedByDeliveryTeam);\n\n        Assert.assertSame(receivedByDeliveryTeam, fsm.getCurrentState());\n        Assert.assertEquals(receivedByDeliveryTeam.getName(), fsm.getCurrentStateName());\n        \n        return receivedByDeliveryTeam;\n    }\n\n    \n    @Test\n    public void test_getPathBetweenClaimsReceivedByDeliveryTeamAndClaimsReceivedByMonitoringOfficer()\n    {\n\n        final ClaimsReceivedByDeliveryTeam receivedByDeliveryTeam = moveToClaimsReceivedByDeliveryTeam();\n        final ClaimsStateMachine fsm = receivedByDeliveryTeam.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'receivedByDeliveryTeam\'"", receivedByDeliveryTeam, fsm.getCurrentState());\n\n        final TransitionPaths paths = receivedByDeliveryTeam.getPaths(fsm.receivedByMonitoringOfficer());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        receivedByDeliveryTeam.registerRejectToMoListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'receivedByDeliveryTeam\'"", receivedByDeliveryTeam, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.receivedByMonitoringOfficer(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'rejectToMo\' transition \n     */\n    @Test\n    public void test_rejectToMo()\n    {\n        final ClaimsReceivedByDeliveryTeam receivedByDeliveryTeam = moveToClaimsReceivedByDeliveryTeam();\n        final ClaimsStateMachine fsm = receivedByDeliveryTeam.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        receivedByDeliveryTeam.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        receivedByDeliveryTeam.rejectToMo();\n\n        //\n        // assert the current state is now ClaimsReceivedByMonitoringOfficer\n        //\n        Assert.assertEquals(fsm.receivedByMonitoringOfficer(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.receivedByMonitoringOfficer().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsRejectToMo.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsRejectToMo.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(receivedByDeliveryTeam.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReceivedByDeliveryTeam\' can be moved into the ClaimsReceivedByMonitoringOfficer state\n     */\n    @Test\n    public void test_moveToClaimsReceivedByMonitoringOfficer()\n    {\n        final ClaimsReceivedByDeliveryTeam receivedByDeliveryTeam = moveToClaimsReceivedByDeliveryTeam();\n        final ClaimsStateMachine fsm = receivedByDeliveryTeam.getStateMachine();\n        receivedByDeliveryTeam.getPaths(fsm.receivedByMonitoringOfficer());\n        \n    }\n    \n    @Test\n    public void test_getPathBetweenClaimsReceivedByDeliveryTeamAndClaimsReceivedByHeadOfDelivery()\n    {\n\n        final ClaimsReceivedByDeliveryTeam receivedByDeliveryTeam = moveToClaimsReceivedByDeliveryTeam();\n        final ClaimsStateMachine fsm = receivedByDeliveryTeam.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'receivedByDeliveryTeam\'"", receivedByDeliveryTeam, fsm.getCurrentState());\n\n        final TransitionPaths paths = receivedByDeliveryTeam.getPaths(fsm.receivedByHeadOfDelivery());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        receivedByDeliveryTeam.registerApproveForHodListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'receivedByDeliveryTeam\'"", receivedByDeliveryTeam, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'approveForHod\' transition \n     */\n    @Test\n    public void test_approveForHod()\n    {\n        final ClaimsReceivedByDeliveryTeam receivedByDeliveryTeam = moveToClaimsReceivedByDeliveryTeam();\n        final ClaimsStateMachine fsm = receivedByDeliveryTeam.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        receivedByDeliveryTeam.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        receivedByDeliveryTeam.approveForHod();\n\n        //\n        // assert the current state is now ClaimsReceivedByHeadOfDelivery\n        //\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsApproveForHod.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsApproveForHod.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(receivedByDeliveryTeam.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReceivedByDeliveryTeam\' can be moved into the ClaimsReceivedByHeadOfDelivery state\n     */\n    @Test\n    public void test_moveToClaimsReceivedByHeadOfDelivery()\n    {\n        final ClaimsReceivedByDeliveryTeam receivedByDeliveryTeam = moveToClaimsReceivedByDeliveryTeam();\n        final ClaimsStateMachine fsm = receivedByDeliveryTeam.getStateMachine();\n        receivedByDeliveryTeam.getPaths(fsm.receivedByHeadOfDelivery());\n        \n    }\n}\n')",[273696]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsMarkPaymentAsComplete extends AbstractTransition<ClaimsPaymentReceived, ClaimsPaymentComplete>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""mark payment as complete"";\n\n    TransitionClaimsMarkPaymentAsComplete(final ClaimsPaymentReceived from, final ClaimsPaymentComplete to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[266816]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\n\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Set;\nimport java.util.HashSet;\n\n/**\n * A TransitionPath represents a chain of transitions from one state to another\n */\nenum PathFilters\n{\n    ; // uninstantiable\n\n    /**\n     * @return a TransitionPath filter which returns \'true\' when a path contains a transition\n     * with the given name\n     */\n    public static final Predicate<TransitionPath> byName(final String name)\n    {\n        return new Predicate<TransitionPath>() {\n            public boolean apply(final TransitionPath path) {\n                return path.containsTransition(name);\n            }\n        };\n    }\n\n    /**\n     * @return a TransitionPath filter which returns \'true\' when a path contains a transition with one of the given names\n     */\n     @SuppressWarnings(""unchecked"")\n    public static final Predicate<TransitionPath> byNames(final String ... names)\n    {\n        final Set<String> uniqueNames = new HashSet<String>(Arrays.asList(names));\n        final Collection<Predicate<TransitionPath>> filters = new ArrayList<Predicate<TransitionPath>>(uniqueNames.size());\n        for (final String name : uniqueNames)\n        {\n            if (name != null)\n            {\n                filters.add(byName(name));\n            }\n        }\n        Predicate<TransitionPath>[] filtersArray = new Predicate[filters.size()];\n        filtersArray = filters.toArray(filtersArray);\n        return Predicates.or(filtersArray);\n    }\n}\n')",[282315]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsReceivedByHeadOfDelivery extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""Received By Head of Delivery"";\n\n    private TransitionClaimsRejectToDeliveryTeam rejectToDeliveryTeam; \n    private TransitionClaimsMarkAsReadyForPayment markAsReadyForPayment; \n    \n    /**\n     * @param fsm\n     */\n    ClaimsReceivedByHeadOfDelivery(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        // Transition reject to delivery team\n        this.rejectToDeliveryTeam = new TransitionClaimsRejectToDeliveryTeam(this, getStateMachine().receivedByDeliveryTeam());\n        allTransitions.add(this.rejectToDeliveryTeam); \n\n        // Transition mark as ready for payment\n        this.markAsReadyForPayment = new TransitionClaimsMarkAsReadyForPayment(this, getStateMachine().readyForPayment());\n        allTransitions.add(this.markAsReadyForPayment); \n\n        return allTransitions;    \n    }\n    \n    /**\n     * execute the reject to delivery team transition\n     * @return true if the transition was successful\n     */\n    public boolean rejectToDeliveryTeam() {\n        this.rejectToDeliveryTeam.execute();\n        return this.rejectToDeliveryTeam.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerRejectToDeliveryTeamListener(final T listener)\n    {\n        return this.rejectToDeliveryTeam.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterRejectToDeliveryTeamListener(final TransitionListener listener)\n    {\n        return this.rejectToDeliveryTeam.unregisterListener(listener);\n    }\n    \n    /**\n     * execute the mark as ready for payment transition\n     * @return true if the transition was successful\n     */\n    public boolean markAsReadyForPayment() {\n        this.markAsReadyForPayment.execute();\n        return this.markAsReadyForPayment.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerMarkAsReadyForPaymentListener(final T listener)\n    {\n        return this.markAsReadyForPayment.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterMarkAsReadyForPaymentListener(final TransitionListener listener)\n    {\n        return this.markAsReadyForPayment.unregisterListener(listener);\n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[264710]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * <p>\n * state transitions are checked using guard conditions. There may be state exit conditions, transition conditions, and state enter\n * conditions. Each of these conditions will return a {@link TransitionGuard}, signaling if the state transition should be allowed to continue.\n * If all guards allow the transition to continue, then a state transition will take place. However, a guard condition may signal that the\n * state transition should not continue, either stopping immediately or stop once the remaining transition listeners are notified.\n * </p>\n * <p>\n * In addition to controlling the state transitions, a transition guard may also specify a \'reason\' should the guard not allow processing.\n * The reason can be a generic {@link Enum} type. If no reason is given then {@link #getReason()} will return\n * {@link Reasons#NO_REASON_GIVEN}.\n * </p>\n */\npublic class TransitionGuard\n{\n    /**\n     * Default \'stop\' Reasons\n     */\n    public enum Reasons\n    {\n        NO_REASON_GIVEN,//\n        ALREADY_IN_TARGET_STATE, // \n        TARGET_STATE_UNREACHABLE;\n    }\n\n    /**\n     * This enumeration allows listeners to notify the state machine whether or not it should continue processing. Using this mechanism we\n     * avoid listeners having to throw exceptions for process flow.\n     */\n    public enum Type\n    {\n        /**\n        *\n        */\n        CONTINUE\n        {\n            @Override\n            boolean continueProcessingInternal()\n            {\n                return true;\n            }\n\n            @Override\n            boolean stopInternal()\n            {\n                return false;\n            }\n        }, //\n        /**\n        *\n        */\n        STOP_IMMEDIATELY\n        {\n            @Override\n            boolean continueProcessingInternal()\n            {\n                return false;\n            }\n\n            @Override\n            boolean stopInternal()\n            {\n                return true;\n            }\n        }, //\n        /**\n        *\n        */\n        STOP_AFTER_PROCESSING_REMAINING_LISTENERS\n        {\n            @Override\n            boolean continueProcessingInternal()\n            {\n                return false;\n            }\n\n            @Override\n            boolean stopInternal()\n            {\n                return false;\n            }\n        }\n\n        ;//\n\n        abstract boolean continueProcessingInternal();\n\n        boolean continueProcessing()\n        {\n            final boolean result = continueProcessingInternal();\n            if (!result)\n            {\n                StateLog.trace(""asked to stop eventually"");\n            }\n            return result;\n        }\n\n        abstract boolean stopInternal();\n\n        boolean stop()\n        {\n            final boolean result = stopInternal();\n            if (result)\n            {\n                StateLog.trace(""asked to stop immediately"");\n            }\n            return result;\n        }\n    }\n\n    private final Type    type;\n    private final Enum<?> reason;\n\n    /**\n     * @return the type\n     */\n    public Type getType()\n    {\n        return this.type;\n    }\n\n    /**\n     * @return the reason, or {@link Reasons#NO_REASON_GIVEN} if no reason was specified\n     */\n    public Enum<?> getReason()\n    {\n        return this.reason == null ? Reasons.NO_REASON_GIVEN : this.reason;\n    }\n    \n    /**\n     * @return the reason as a collection\n     */\n    final  Collection<Enum<?>> getReasons()\n    {\n        if (this.reason == null)\n        {\n            return Collections.emptyList();\n        }\n        final Collection<Enum<?>> reasons = new ArrayList<Enum<?>>();\n        reasons.add(getReason());\n        return reasons;\n    }\n    public TransitionGuard(final Type t, final Enum<?> reasonValue)\n    {\n        this.type = t;\n        this.reason = reasonValue;\n    }\n\n    /**\n     * return a collection of reasons given for any stopping guards given.\n     * If all guards are of type \'continue\' then an empty collection is returned. \n     * @return a collection of reason enumerations for the given guards\n     */\n    static Collection<Enum<?>> filterReasons(final TransitionGuard... guards)\n    {\n        Collection<Enum<?>> reasons = null;\n        for (final TransitionGuard guard : guards)\n        {\n            if (!guard.continueProcessing())\n            {\n                if (reasons == null)\n                {\n                    reasons = new ArrayList<Enum<?>>();\n                }\n                reasons.add(guard.getReason());\n            }\n        }\n        if (reasons == null)\n        {\n            reasons = Collections.emptyList();\n        }\n\n        return reasons;\n    }\n\n    private static final TransitionGuard GUARD_CONTINUE         = new TransitionGuard(Type.CONTINUE, null);\n    private static final TransitionGuard GUARD_STOP_IMMIDIATELY = new TransitionGuard(Type.STOP_IMMEDIATELY, null);\n    private static final TransitionGuard GUARD_STOP_EVENTUALLY  = new TransitionGuard(Type.STOP_AFTER_PROCESSING_REMAINING_LISTENERS, null);\n\n    /**\n     * @return true if the transition should stop\n     */\n    public boolean stop()\n    {\n        return this.type.stop();\n    }\n\n    /**\n     * @return true if the transition should continue\n     */\n    public boolean continueProcessing()\n    {\n        return this.type.continueProcessing();\n    }\n\n    /**\n     * @return a generic \'continue\' transition guard\n     */\n    public static TransitionGuard ok()\n    {\n        return GUARD_CONTINUE;\n    }\n\n    /**\n     * @return a generic stop immediately transition guard\n     */\n    public static TransitionGuard stopImmediately()\n    {\n        return GUARD_STOP_IMMIDIATELY;\n    }\n\n    /**\n     * @param reason\n     * @return a generic stop eventually transition guard\n     */\n    public static TransitionGuard stopImmediately(final Enum<?> stopReason)\n    {\n        return new TransitionGuard(Type.STOP_IMMEDIATELY, stopReason);\n    }\n\n    /**\n     * @return a generic stop eventually transition guard\n     */\n    public static TransitionGuard stopEventually()\n    {\n        return GUARD_STOP_EVENTUALLY;\n    }\n\n    /**\n     * @param reason\n     * @return a generic stop eventually transition guard\n     */\n    public static TransitionGuard stopEventually(final Enum<?> stopReason)\n    {\n        return new TransitionGuard(Type.STOP_AFTER_PROCESSING_REMAINING_LISTENERS, stopReason);\n    }\n    \n    /**\n     * @return the string representation\n     */\n    @Override\n    public String toString()\n    {\n        return String.format(""%s [%s]"", this.type, this.reason);\n    }\n}\n')",[258151]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_moveToClaimsPaymentComplete(aaron.test.test.ClaimsPaymentReceivedTest)')","[19684, 21048, 28269, 30716, 41806, 62685, 64225, 72646, 83666, 103341, 104793, 112614, 124921, 147004, 148632, 157653, 171335, 195224, 196984, 206905, 221233, 246326, 248174, 308085, 308919]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_addTransition(com.porpoise.fsm.model.StateMachineTest)')","[2603, 2634, 2665, 3719, 3750, 3781, 21669, 21693, 21717, 31638, 31668, 31698, 43400, 43435, 43470, 44660, 44695, 44730, 64946, 64974, 65002, 74188, 74216, 74244, 85158, 85191, 85224, 86346, 86379, 86412, 105464, 105490, 105516, 114063, 114095, 114127, 126617, 126654, 126691, 127949, 127986, 128023, 149403, 149433, 149463, 159442, 159477, 159512, 173184, 173224, 173264, 174624, 174664, 174704, 197830, 197863, 197896, 208650, 208687, 208724, 223184, 223226, 223268, 224696, 224738, 224780, 249348, 249388, 249428, 250344, 250386, 250428]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\n/**\n * listener callback interface \n */\npublic interface TransitionListener\n{\n\n    /**\n     * fired when a transition is executed\n     * @return the transition guard\n     */\n    TransitionGuard onTransition(final Transition transition);\n}\n')",[256920]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_generateFile(com.porpoise.fsm.generator.StateMachineGeneratorTest)')","[593, 617, 641, 4339, 4370, 4401, 4959, 4990, 5021, 22149, 22173, 22197, 29152, 32649, 32679, 32709, 32910, 32938, 32966, 45360, 45395, 45430, 46060, 46095, 46130, 65506, 65534, 65562, 75129, 75157, 75185, 75372, 75398, 75424, 87006, 87039, 87072, 87666, 87699, 87732, 105984, 106010, 106036, 115144, 115176, 115208, 115423, 115453, 115483, 128689, 128726, 128763, 129429, 129466, 129503, 150003, 150033, 150063, 160628, 160663, 160698, 160934, 160967, 161000, 175424, 175464, 175504, 176224, 176264, 176304, 198490, 198523, 198556, 209906, 209943, 209980, 210230, 210265, 210300, 225536, 225578, 225620, 226376, 226418, 226460, 251848, 251888, 251928, 252172, 252214, 252256]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_submitToDeliveryTeam(aaron.test.test.ClaimsNotReceivedTest)')","[6943, 6974, 7005, 9547, 9578, 9609, 23493, 23517, 23541, 34877, 34907, 34937, 48300, 48335, 48370, 51240, 51275, 51310, 67074, 67102, 67130, 77205, 77233, 77261, 89778, 89811, 89844, 92550, 92583, 92616, 107440, 107466, 107492, 117524, 117556, 117588, 131797, 131834, 131871, 134905, 134942, 134979, 151683, 151713, 151743, 163236, 163271, 163306, 178784, 178824, 178864, 182144, 182184, 182224, 200338, 200371, 200404, 212666, 212703, 212740, 229064, 229106, 229148, 232592, 232634, 232676, 290731, 290771, 290811, 292543, 292585, 292627]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsSubmitToMonitoringOfficer extends AbstractTransition<ClaimsNotReceived, ClaimsReceivedByMonitoringOfficer>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""submit to monitoring officer"";\n\n    TransitionClaimsSubmitToMonitoringOfficer(final ClaimsNotReceived from, final ClaimsReceivedByMonitoringOfficer to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[265965]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\npublic interface NamedObject\n{\n    /**\n     * @return a name for the object\n     */\n    public String getName();\n}\n')",[254453]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_moveToClaimsPaymentComplete(aaron.test.test.ClaimsPaymentReceivedTest)')","[19715, 19746, 19777, 21079, 21110, 21141, 28293, 28317, 28341, 41836, 41866, 41896, 62720, 62755, 62790, 64260, 64295, 64330, 72674, 72702, 72730, 83694, 83722, 83750, 103374, 103407, 103440, 104826, 104859, 104892, 112640, 112666, 112692, 124953, 124985, 125017, 147041, 147078, 147115, 148669, 148706, 148743, 157683, 157713, 157743, 171370, 171405, 171440, 195264, 195304, 195344, 197024, 197064, 197104, 206938, 206971, 207004, 221270, 221307, 221344, 246368, 246410, 246452, 248216, 248258, 248300, 308125, 308165, 308205, 308961, 309003, 309045]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_addTransition(com.porpoise.fsm.model.StateMachineTest)')","[2572, 3688, 21645, 28987, 31608, 43365, 44625, 64918, 74160, 85125, 86313, 105438, 114031, 126580, 127912, 149373, 159407, 173144, 174584, 197797, 208613, 223142, 224654, 249308, 250302]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'com.porpoise.fsm.generator.FilenameHelperTest')","[288871, 288894, 288918, 288941]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport com.google.common.base.Predicate;\n\n/**\n * a listener which can be turned on and off by the given predicate\n */\npublic abstract class AbstractConditionalStateListener implements StateListener\n{\n    private final Predicate<Transition> enterFilter;\n    private final Predicate<Transition> exitFilter;\n    private final TransitionGuard        enterReturnValueOnPredicateFalse;\n    private final TransitionGuard        exitReturnValueOnPredicateFalse;\n\n    /**\n     * @param predicate\n     *            the predicate logic used to filter the given listener.\n     */\n    public AbstractConditionalStateListener(final Predicate<Transition> predicate)\n    {\n        this(predicate, predicate);\n    }\n\n    /**\n     * @param enterPredicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener\'s onEnter will be executed.\n     * @param exitPredicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener\'s onExit method will be executed.\n     */\n    public AbstractConditionalStateListener(final Predicate<Transition> enterPredicate, final Predicate<Transition> exitPredicate)\n    {\n        this(enterPredicate, exitPredicate, TransitionGuard.ok(), TransitionGuard.ok());\n    }\n\n    /**\n     * @param enterPredicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener\'s onEnter will be executed.\n     * @param exitPredicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener\'s onExit method will be executed.\n     * @param predicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener will be executed.\n     * @param listener\n     * @param enterDefault\n     *            the transition to return should the enter predicate filter return false\n     * @param exitDefault\n     *            the transition to return should the exit predicate filter return false\n     */\n    public AbstractConditionalStateListener(final Predicate<Transition> enterPredicate, final Predicate<Transition> exitPredicate,\n            final TransitionGuard enterDefault, final TransitionGuard exitDefault)\n    {\n        if (enterPredicate == null)\n        {\n            throw new NullPointerException(""enterPredicate cannot be null"");\n        }\n        if (enterDefault == null)\n        {\n            throw new NullPointerException(""enterDefault cannot be null"");\n        }\n        if (exitPredicate == null)\n        {\n            throw new NullPointerException(""exitPredicate cannot be null"");\n        }\n        if (exitDefault == null)\n        {\n            throw new NullPointerException(""exitDefault cannot be null"");\n        }\n        this.enterFilter = enterPredicate;\n        this.exitFilter = exitPredicate;\n\n        this.enterReturnValueOnPredicateFalse = enterDefault;\n        this.exitReturnValueOnPredicateFalse = exitDefault;\n    }\n\n    /**\n     * the exit condition predicate was successful. Return the result from the exit listener logic.\n     * \n     * @param transition\n     *            the transition\n     * @return the transition return value.\n     */\n    protected abstract TransitionGuard onExitInternal(final Transition transition);\n\n    /**\n     * the enter condition predicate was successful. Return the result from the exit listener logic.\n     * \n     * @param transition\n     *            the transition\n     * @return the transition return value.\n     */\n    protected abstract TransitionGuard onEnterInternal(final Transition transition);\n\n    /**\n     * @param transition\n     * @return the transition return value.\n     */\n    public final TransitionGuard onExit(final Transition transition)\n    {\n        if (!this.exitFilter.apply(transition))\n        {\n            return this.exitReturnValueOnPredicateFalse;\n        }\n        return onExitInternal(transition);\n    }\n\n    /**\n     * @param transition\n     * @return the transition return value.\n     */\n    @Override\n    public final TransitionGuard onEnter(final Transition transition)\n    {\n        if (!this.enterFilter.apply(transition))\n        {\n            return this.enterReturnValueOnPredicateFalse;\n        }\n        return onEnterInternal(transition);\n    }\n\n    /**\n     * @return the return value to use when the predicate logic evaluates to \'false\'\n     */\n    protected TransitionGuard getDefaultEnterReturnValueOnFalse()\n    {\n        return this.enterReturnValueOnPredicateFalse;\n    }\n\n    /**\n     * @return the return value to use when the predicate logic evaluates to \'false\'\n     */\n    protected TransitionGuard getDefaultExitReturnValueOnFalse()\n    {\n        return this.exitReturnValueOnPredicateFalse;\n    }\n\n    @Override\n    public String toString()\n    {\n        return String.format(""conditional listener[enter=%s, exit=%s]"", this.enterFilter, this.exitFilter);\n    }\n}')",[255726]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'null')","[17, 35, 73310, 158365]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_toAndFromXml(com.porpoise.fsm.model.StateMachineTest)')","[2324, 3440, 21453, 28945, 31368, 43085, 44345, 64694, 73936, 84861, 86049, 105230, 113775, 126284, 127616, 149133, 159127, 172824, 174264, 197533, 208317, 222806, 224318, 248988, 249966]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test.test;\nimport aaron.test.*;\nimport org.junit.*;\n\n/**\n * tests for ClaimsStateMachine\n */\n@Ignore(""base class"")\nabstract class AbstractClaimsTest \n{\n    /**\n     *\n     */\n    protected ClaimsStateMachine newStateMachine()\n    {\n        final ClaimsStateMachine fsm = ClaimsStateMachine.createAndStart(); \n        Assert.assertNotNull(fsm);\n        return fsm;\n    }\n}\n')",[269466]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\nimport com.google.common.base.Predicate;\n\n/**\n * a listener which can be turned on and off by the given predicate\n */\npublic abstract class AbstractConditionalStateListener implements StateListener\n{\n    private final Predicate<Transition> enterFilter;\n    private final Predicate<Transition> exitFilter;\n    private final TransitionGuard        enterReturnValueOnPredicateFalse;\n    private final TransitionGuard        exitReturnValueOnPredicateFalse;\n\n    /**\n     * @param predicate\n     *            the predicate logic used to filter the given listener.\n     */\n    public AbstractConditionalStateListener(final Predicate<Transition> predicate)\n    {\n        this(predicate, predicate);\n    }\n\n    /**\n     * @param enterPredicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener\'s onEnter will be executed.\n     * @param exitPredicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener\'s onExit method will be executed.\n     */\n    public AbstractConditionalStateListener(final Predicate<Transition> enterPredicate, final Predicate<Transition> exitPredicate)\n    {\n        this(enterPredicate, exitPredicate, TransitionGuard.ok(), TransitionGuard.ok());\n    }\n\n    /**\n     * @param enterPredicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener\'s onEnter will be executed.\n     * @param exitPredicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener\'s onExit method will be executed.\n     * @param predicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener will be executed.\n     * @param listener\n     * @param enterDefault\n     *            the transition to return should the enter predicate filter return false\n     * @param exitDefault\n     *            the transition to return should the exit predicate filter return false\n     */\n    public AbstractConditionalStateListener(final Predicate<Transition> enterPredicate, final Predicate<Transition> exitPredicate,\n            final TransitionGuard enterDefault, final TransitionGuard exitDefault)\n    {\n        if (enterPredicate == null)\n        {\n            throw new NullPointerException(""enterPredicate cannot be null"");\n        }\n        if (enterDefault == null)\n        {\n            throw new NullPointerException(""enterDefault cannot be null"");\n        }\n        if (exitPredicate == null)\n        {\n            throw new NullPointerException(""exitPredicate cannot be null"");\n        }\n        if (exitDefault == null)\n        {\n            throw new NullPointerException(""exitDefault cannot be null"");\n        }\n        this.enterFilter = enterPredicate;\n        this.exitFilter = exitPredicate;\n\n        this.enterReturnValueOnPredicateFalse = enterDefault;\n        this.exitReturnValueOnPredicateFalse = exitDefault;\n    }\n\n    /**\n     * the exit condition predicate was successful. Return the result from the exit listener logic.\n     * \n     * @param transition\n     *            the transition\n     * @return the transition return value.\n     */\n    protected abstract TransitionGuard onExitInternal(final Transition transition);\n\n    /**\n     * the enter condition predicate was successful. Return the result from the exit listener logic.\n     * \n     * @param transition\n     *            the transition\n     * @return the transition return value.\n     */\n    protected abstract TransitionGuard onEnterInternal(final Transition transition);\n\n    /**\n     * @param transition\n     * @return the transition return value.\n     */\n    public final TransitionGuard onExit(final Transition transition)\n    {\n        if (!this.exitFilter.apply(transition))\n        {\n            return this.exitReturnValueOnPredicateFalse;\n        }\n        return onExitInternal(transition);\n    }\n\n    /**\n     * @param transition\n     * @return the transition return value.\n     */\n    @Override\n    public final TransitionGuard onEnter(final Transition transition)\n    {\n        if (!this.enterFilter.apply(transition))\n        {\n            return this.enterReturnValueOnPredicateFalse;\n        }\n        return onEnterInternal(transition);\n    }\n\n    /**\n     * @return the return value to use when the predicate logic evaluates to \'false\'\n     */\n    protected TransitionGuard getDefaultEnterReturnValueOnFalse()\n    {\n        return this.enterReturnValueOnPredicateFalse;\n    }\n\n    /**\n     * @return the return value to use when the predicate logic evaluates to \'false\'\n     */\n    protected TransitionGuard getDefaultExitReturnValueOnFalse()\n    {\n        return this.exitReturnValueOnPredicateFalse;\n    }\n\n    @Override\n    public String toString()\n    {\n        return String.format(""conditional listener[enter=%s, exit=%s]"", this.enterFilter, this.exitFilter);\n    }\n}')",[279197]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsStartState\n */\npublic class ClaimsStartStateTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the \'ClaimsStartState\' state\n     */\n    @Test\n    public void test_executeToClaimsStartState()\n    {\n        Assert.assertNotNull(moveToClaimsStartState());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for \'startState\' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.startState().getName();\n        Assert.assertEquals(fsm.startState(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the startState state\n     */\n    final ClaimsStartState moveToClaimsStartState()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsStartState startState = fsm.startState();\n\n        // call the method under test\n        fsm.executeToState(startState);\n\n        Assert.assertSame(startState, fsm.getCurrentState());\n        Assert.assertEquals(startState.getName(), fsm.getCurrentStateName());\n        \n        return startState;\n    }\n\n    \n    @Test\n    public void test_getPathBetweenClaimsStartStateAndClaimsNotReceived()\n    {\n\n        final ClaimsStartState startState = moveToClaimsStartState();\n        final ClaimsStateMachine fsm = startState.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'startState\'"", startState, fsm.getCurrentState());\n\n        final TransitionPaths paths = startState.getPaths(fsm.notReceived());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        startState.registerInitListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'startState\'"", startState, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.notReceived(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'init\' transition \n     */\n    @Test\n    public void test_init()\n    {\n        final ClaimsStartState startState = moveToClaimsStartState();\n        final ClaimsStateMachine fsm = startState.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        startState.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        startState.init();\n\n        //\n        // assert the current state is now ClaimsNotReceived\n        //\n        Assert.assertEquals(fsm.notReceived(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.notReceived().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsInit.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsInit.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(startState.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsStartState\' can be moved into the ClaimsNotReceived state\n     */\n    @Test\n    public void test_moveToClaimsNotReceived()\n    {\n        final ClaimsStartState startState = moveToClaimsStartState();\n        final ClaimsStateMachine fsm = startState.getStateMachine();\n        startState.getPaths(fsm.notReceived());\n        \n    }\n}\n')",[274851]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n *\n */\nabstract class AbstractTransition<SOURCE extends AbstractTestState, TARGET extends AbstractTestState> implements Transition\n{\n    private final SOURCE sourceState;\n    private final TARGET targetState;\n    \n    private Collection<TransitionListener> listeners;\n\n    AbstractTransition(final SOURCE from, final TARGET to)\n    {\n        if (from == null) \n        {\n            throw new NullPointerException(""source state cannot be null"");\n        }\n        if (to == null) \n        {\n            throw new NullPointerException(""target state cannot be null"");\n        }\n        if (from.getStateMachine() != to.getStateMachine())\n        {\n            throw new NullPointerException(""source and target states are for different state machines"");\n        }\n        this.sourceState = from;\n        this.targetState = to;\n        this.listeners = new CopyOnWriteArrayList<TransitionListener>();\n    }\n\n    public SOURCE getSource()\n    {\n        return this.sourceState;\n    }\n    \n    public TARGET getTarget()\n    {\n        return this.targetState;\n    }\n\n    /**\n     *  hook for subclasses\n     */\n    protected void executeInternal()\n    {\n    // no-op\n    }\n\n    /**\n     * Execute the transition, returning a collection of reasons why the transition could not execute should the transition fail.\n     * Should the transition succeed, an empty collection is returned.\n     * @return a collection of reasons why the transition could not execute should the transition fail\n     */\n    public final Collection<Enum<?>> execute()\n    {\n        if (getSource() != getStateMachine().getCurrentState())\n        {\n            StateLog.error(""Illegal transition \'%s\' called. Current state was expected to be \'%s\' but was \'%s\'"", getName(), getSource().getName(),\n                    getStateMachine().getCurrentStateName());\n            return Arrays.asList(new Enum<?>[] { Reasons.INVALID_SOURCE_STATE });\n        }\n\n        //\n        // process general listeners\n        //\n        final TransitionGuard generalBeforeResult = getStateMachine().onBeforeTransition(this);\n        if (generalBeforeResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop before transition. Reason=%s"", getName(), generalBeforeResult.getReason());\n            return generalBeforeResult.getReasons();\n        }\n\n        //\n        // process source handlers\n        //\n        final TransitionGuard specificBeforeResult = getSource().onExit(this);\n        if (specificBeforeResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop exiting the state. Reason=%s"", getName(), specificBeforeResult.getReason());\n            return specificBeforeResult.getReasons();\n        }\n\n        //\n        // perform any subclass processing\n        //\n        executeInternal();\n\n        //\n        // process specific target entrance handlers\n        //\n        final TransitionGuard specificAfterResult = getSource().onEnter(this);\n        if (specificAfterResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop entering state. Reason=%s"", getName(), specificAfterResult.getReason());\n            return specificAfterResult.getReasons();\n        }\n\n        //\n        // notify the direct transition listeners that the transition is taking place\n        //\n        final TransitionGuard transGuardResult = notifyListeners();\n        if (transGuardResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop by a transaction listener. Reason=%s"", getName(), transGuardResult.getReason());\n            return transGuardResult.getReasons();\n        }\n\n        //\n        // process general target entrance handlers\n        //\n        final TransitionGuard generalAfterResult = getStateMachine().onAfterTransition(this);\n        if (generalAfterResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop by a transaction listener. Reason=%s"", getName(), generalAfterResult.getReason());\n            return generalAfterResult.getReasons();\n        }\n\n        //\n        // success! Or is it? Anybody think we should stop?\n        //\n        final Collection<Enum<?>> reasons = TransitionGuard.filterReasons(generalBeforeResult,//\n                specificBeforeResult,//\n                specificAfterResult,//\n                transGuardResult,//\n                generalAfterResult);\n\n        if (reasons.isEmpty())\n        {\n            StateLog.debug(""transition \'%s\' proceeding to state \'%s\'"", getName(), getTarget().getName());\n            getStateMachine().setCurrentState(getTarget());\n        }\n        else\n        {\n            StateLog.debug(""transition \'%s\' returning without proceeding to \'%s\', staying in \'%s\' due to: %s"", getName(), getTarget()\n                    .getName(), getStateMachine().getCurrentState().getName(), reasons);\n        }\n\n        return reasons;\n    }\n\n    TestStateMachine getStateMachine()\n    {\n        return getSource().getStateMachine();\n    }\n    \n    private TransitionGuard notifyListeners()\n    {\n        TransitionGuard result = TransitionGuard.ok(); \n        for (final TransitionListener listener : this.listeners)\n        {\n            final TransitionGuard listenerResult = listener.onTransition(this);\n            if (listenerResult.stop())\n            {\n                return listenerResult;\n            }\n            else if (!listenerResult.continueProcessing())\n            {\n                result = listenerResult; \n            }\n        }\n        return result;\n    }\n    \n    /**\n     * @param listener the listener to add\n     * @return true if the listener was added successfully\n     */\n    @Override\n    public <T extends TransitionListener> T registerListener(final T listener)\n    {\n        if (listener == null)\n        {\n            return null;\n        }\n        final boolean success =  this.listeners.add(listener);\n        assert success;\n        return listener;\n    }\n\n    /**\n     * @param listener the listener to remove\n     * @reutrn true if the listener was removed successfully\n     */\n    @Override\n    public boolean unregisterListener(final TransitionListener listener)\n    {\n        if (listener == null)\n        {\n            return false;\n        }\n        return this.listeners.remove(listener);\n    }\n    \n    /**\n     * @return the string value for this transition\n     */\n    @Override\n    public String toString()\n    {\n        return String.format(""%s [%d]: %s --> %s"", getName(), Integer.valueOf(this.listeners.size()), getSource().getName(), getTarget()\n                .getName());\n    }\n}\n')",[285914]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'com.porpoise.fsm.generator.FilenameHelperTest')","[662, 33231, 75671, 115766, 161310, 210628]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsReceivedByDeliveryTeam extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""Received By Delivery Team"";\n\n    private TransitionClaimsRejectToMo rejectToMo; \n    private TransitionClaimsApproveForHod approveForHod; \n    \n    /**\n     * @param fsm\n     */\n    ClaimsReceivedByDeliveryTeam(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        // Transition reject to mo\n        this.rejectToMo = new TransitionClaimsRejectToMo(this, getStateMachine().receivedByMonitoringOfficer());\n        allTransitions.add(this.rejectToMo); \n\n        // Transition approve for hod\n        this.approveForHod = new TransitionClaimsApproveForHod(this, getStateMachine().receivedByHeadOfDelivery());\n        allTransitions.add(this.approveForHod); \n\n        return allTransitions;    \n    }\n    \n    /**\n     * execute the reject to mo transition\n     * @return true if the transition was successful\n     */\n    public boolean rejectToMo() {\n        this.rejectToMo.execute();\n        return this.rejectToMo.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerRejectToMoListener(final T listener)\n    {\n        return this.rejectToMo.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterRejectToMoListener(final TransitionListener listener)\n    {\n        return this.rejectToMo.unregisterListener(listener);\n    }\n    \n    /**\n     * execute the approve for hod transition\n     * @return true if the transition was successful\n     */\n    public boolean approveForHod() {\n        this.approveForHod.execute();\n        return this.approveForHod.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerApproveForHodListener(final T listener)\n    {\n        return this.approveForHod.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterApproveForHodListener(final TransitionListener listener)\n    {\n        return this.approveForHod.unregisterListener(listener);\n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[266960]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_moveToClaimsReceivedByMonitoringOfficer(aaron.test.test.ClaimsNotReceivedTest)')","[6695, 6726, 6757, 9299, 9330, 9361, 23301, 23325, 23349, 34637, 34667, 34697, 48020, 48055, 48090, 50960, 50995, 51030, 66850, 66878, 66906, 76981, 77009, 77037, 89514, 89547, 89580, 92286, 92319, 92352, 107232, 107258, 107284, 117268, 117300, 117332, 131501, 131538, 131575, 134609, 134646, 134683, 151443, 151473, 151503, 162956, 162991, 163026, 178464, 178504, 178544, 181824, 181864, 181904, 200074, 200107, 200140, 212370, 212407, 212444, 228728, 228770, 228812, 232256, 232298, 232340, 290411, 290451, 290491, 292207, 292249, 292291]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_moveToClaimsReceivedByMonitoringOfficer(aaron.test.test.ClaimsReceivedByDeliveryTeamTest)')","[15003, 15034, 15065, 17607, 17638, 17669, 26661, 26685, 26709, 39385, 39415, 39445, 57400, 57435, 57470, 60340, 60375, 60410, 70770, 70798, 70826, 81409, 81437, 81465, 98358, 98391, 98424, 101130, 101163, 101196, 110872, 110898, 110924, 122336, 122368, 122400, 141417, 141454, 141491, 144525, 144562, 144599, 155643, 155673, 155703, 168504, 168539, 168574, 189184, 189224, 189264, 192544, 192584, 192624, 204694, 204727, 204760, 218238, 218275, 218312, 239984, 240026, 240068, 243512, 243554, 243596, 302771, 302811, 302851, 304063, 304105, 304147]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'aaron.test.test.ClaimsReceivedByDeliveryTeamTest')","[1481, 40190, 82160, 123195, 169444, 219232]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_submitToHeadOfDelivery(aaron.test.test.ClaimsNotReceivedTest)')","[7315, 7346, 7377, 9919, 9950, 9981, 23781, 23805, 23829, 35237, 35267, 35297, 48720, 48755, 48790, 51660, 51695, 51730, 67410, 67438, 67466, 77541, 77569, 77597, 90174, 90207, 90240, 92946, 92979, 93012, 107752, 107778, 107804, 117908, 117940, 117972, 132241, 132278, 132315, 135349, 135386, 135423, 152043, 152073, 152103, 163656, 163691, 163726, 179264, 179304, 179344, 182624, 182664, 182704, 200734, 200767, 200800, 213110, 213147, 213184, 229568, 229610, 229652, 233096, 233138, 233180, 291211, 291251, 291291, 293047, 293089, 293131]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.HashSet;\n\n/**\n * A TransitionPath represents a chain of transitions from one state to another\n */\npublic final class TransitionPath implements Comparable<TransitionPath>\n{\n    private final List<PathEntry> path;\n    private final Set<String>     uniqueTransitionNames;\n\n    TransitionPath(final State startState)\n    {\n        this(Arrays.asList(new PathEntry[] { new PathEntry(startState) }));\n    }\n\n    private TransitionPath(final List<PathEntry> states)\n    {\n        this.path = new ArrayList<PathEntry>(states);\n        this.uniqueTransitionNames = new HashSet<String>();\n        for (final PathEntry pe : states)\n        {\n            if (pe.getTransition() != null)\n            {\n                this.uniqueTransitionNames.add(pe.getTransition().getName());\n            }\n        }\n    }\n\n    /**\n     * add a unique transition to the given target\n     * @param target\n     * @param trans\n     * @return true if this method invocation has altered the TransitionPath, false otherwise\n     */\n    boolean add(final State target, final Transition trans)\n    {\n        final PathEntry entry = new PathEntry(target, trans);\n        if (this.path.contains(entry))\n        {\n            return false;\n        }\n        this.uniqueTransitionNames.add(trans.getName());\n        return this.path.add(entry);\n    }\n\n    public TransitionPath clonePath()\n    {\n        return new TransitionPath(this.path);\n    }\n\n    @Override\n    public String toString()\n    {\n        final StringBuilder b = new StringBuilder(""path: "");\n        for (final PathEntry s : this.path)\n        {\n            b.append(s);\n        }\n        return b.toString();\n    }\n\n    @Override\n    public int hashCode()\n    {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((this.path == null) ? 0 : this.path.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(final Object obj)\n    {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        final TransitionPath other = (TransitionPath) obj;\n        if (this.path == null)\n        {\n            if (other.path != null)\n                return false;\n        }\n        else if (!this.path.equals(other.path))\n            return false;\n        return true;\n    }\n\n    /**\n     * execute this path on\'t state machine\n     * \n     * @return true if the path executed all transition successfully\n     */\n    final public TransitionPathResult execute()\n    {\n        for (final PathEntry entry : this.path)\n        {\n            final Collection<Enum<?>> reasons = entry.execute();\n            if (!reasons.isEmpty())\n            {\n                return TransitionPathResult.fail(entry, reasons);\n            }\n        }\n        return TransitionPathResult.success();\n    }\n\n    /**\n     * @return the length of this path\n     */\n    public int size()\n    {\n        return this.path.size();\n    }\n\n    /**\n     * @return the result of the comparison\n     */\n    @Override\n    public int compareTo(final TransitionPath o)\n    {\n        return Integer.valueOf(size()).compareTo(Integer.valueOf(o.size()));\n    }\n\n\n    /**\n     * @return true if the path contains the transition with the given name\n     */\n    public boolean containsTransition(final String name)\n    {\n        return this.uniqueTransitionNames.contains(name);\n    }\n}\n')",[259556]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsNotReceivedAndClaimsReceivedByHeadOfDelivery(aaron.test.test.ClaimsNotReceivedTest)')","[7160, 9764, 23661, 29568, 35087, 48545, 51485, 67270, 77401, 90009, 92781, 107622, 117748, 132056, 135164, 151893, 163481, 179064, 182424, 200569, 212925, 229358, 232886, 291011, 292837]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\binterface (\\w+).*', 'package p;\n\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\n\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Set;\nimport java.util.HashSet;\n\n/**\n * A TransitionPath represents a chain of transitions from one state to another\n */\nenum PathFilters\n{\n    ; // uninstantiable\n\n    /**\n     * @return a TransitionPath filter which returns \'true\' when a path contains a transition\n     * with the given name\n     */\n    public static final Predicate<TransitionPath> byName(final String name)\n    {\n        return new Predicate<TransitionPath>() {\n            public boolean apply(final TransitionPath path) {\n                return path.containsTransition(name);\n            }\n        };\n    }\n\n    /**\n     * @return a TransitionPath filter which returns \'true\' when a path contains a transition with one of the given names\n     */\n     @SuppressWarnings(""unchecked"")\n    public static final Predicate<TransitionPath> byNames(final String ... names)\n    {\n        final Set<String> uniqueNames = new HashSet<String>(Arrays.asList(names));\n        final Collection<Predicate<TransitionPath>> filters = new ArrayList<Predicate<TransitionPath>>(uniqueNames.size());\n        for (final String name : uniqueNames)\n        {\n            if (name != null)\n            {\n                filters.add(byName(name));\n            }\n        }\n        Predicate<TransitionPath>[] filtersArray = new Predicate[filters.size()];\n        filtersArray = filters.toArray(filtersArray);\n        return Predicates.or(filtersArray);\n    }\n}\n')",[282161]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_markAsReadyForPayment(aaron.test.test.ClaimsReceivedByHeadOfDeliveryTest)')","[13267, 13298, 13329, 16615, 16646, 16677, 26373, 26397, 26421, 38888, 38918, 38948, 55440, 55475, 55510, 59220, 59255, 59290, 70434, 70462, 70490, 80946, 80974, 81002, 96510, 96543, 96576, 100074, 100107, 100140, 110560, 110586, 110612, 121805, 121837, 121869, 139345, 139382, 139419, 143341, 143378, 143415, 155283, 155313, 155343, 167922, 167957, 167992, 186944, 186984, 187024, 191264, 191304, 191344, 204298, 204331, 204364, 217622, 217659, 217696, 237632, 237674, 237716, 242168, 242210, 242252, 300853, 300893, 300933, 302185, 302227, 302269]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsApproveForDeliveryTeam extends AbstractTransition<ClaimsReceivedByMonitoringOfficer, ClaimsReceivedByDeliveryTeam>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""approve for delivery team"";\n\n    TransitionClaimsApproveForDeliveryTeam(final ClaimsReceivedByMonitoringOfficer from, final ClaimsReceivedByDeliveryTeam to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[268958]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsSubmitToHeadOfDelivery extends AbstractTransition<ClaimsNotReceived, ClaimsReceivedByHeadOfDelivery>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""submit to head of delivery"";\n\n    TransitionClaimsSubmitToHeadOfDelivery(final ClaimsNotReceived from, final ClaimsReceivedByHeadOfDelivery to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[266230]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\binterface (\\w+).*', 'package aaron.test;\n\nimport java.util.Collection;\n\n/**\n * Transition represents a transition between two states \n */\npublic interface Transition extends NamedObject\n{\n    /**\n     * General failure reasons for transitions\n     */\n    enum Reasons\n    {\n        /** \n         * The current state of the state machine does not match the source state of the transition\n         */\n        INVALID_SOURCE_STATE;\n    }\n\n    /** \n     * execute the transition\n     * @return the new state\n     */\n    Collection<Enum<?>> execute();\n     \n    /**\n     * @return the source state\n     */\n    State getSource();\n     \n    /**\n     * @return the target state\n     */\n    State getTarget();\n\n    /**\n     * @param listener\n     * @return the registered listener\n     */\n    <T extends TransitionListener> T registerListener(final T listener);\n\n    /**\n     * @param listener\n     * @return true if the listener was removed successfully\n     */\n    boolean unregisterListener(final TransitionListener listener);\n}\n')",[261997]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport com.google.common.base.Predicate;\n\n/**\n * A PredicateToggle provides a means for toggling a {@link Predicate}\n */\npublic final class PredicateToggle\n{\n    private final AtomicBoolean     enabled;\n    private final Predicate<Object> predicate;\n\n    private PredicateToggle(final boolean firstValue)\n    {\n        this.enabled = new AtomicBoolean(firstValue);\n        this.predicate = new Predicate<Object>() {\n            @Override\n            public boolean apply(final Object value)\n            {\n                return isEnabled();\n            }\n\n            @Override\n            public String toString()\n            {\n                return String.format(""Toggle %b"", Boolean.valueOf(isEnabled()));\n            }\n        };\n    }\n\n    /**\n     * @return a new enabled toggle\n     */\n    public static PredicateToggle on()\n    {\n        return new PredicateToggle(true);\n    }\n\n    /**\n     * @return a new disabled toggle\n     */\n    public static PredicateToggle off()\n    {\n        return new PredicateToggle(false);\n    }\n\n    /**\n     * enable the toggle\n     * \n     * @return true if this method call changed the toggle value\n     */\n    public boolean enable()\n    {\n        return this.enabled.compareAndSet(false, true);\n    }\n\n    /**\n     * disable the toggle\n     * \n     * @return true if this method call changed the toggle value\n     */\n    public boolean disable()\n    {\n        return this.enabled.compareAndSet(true, false);\n    }\n\n    /**\n     * switch the toggle value - going from off to on or from on to off.\n     */\n    public void toggle()\n    {\n        this.enabled.set(!isEnabled());\n    }\n\n    /**\n     * @return true if the toggle is currently enabled\n     */\n    public boolean isEnabled()\n    {\n        return this.enabled.get();\n    }\n\n    /**\n     * @return a transition filter representing the current state of the toggle\n     */\n    @SuppressWarnings(""unchecked"")\n    public <T> Predicate<T> predicate()\n    {\n        return (Predicate<T>) this.predicate;\n    }\n}\n')",[257317]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsPaymentRejected extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""Payment Rejected"";\n\n    private TransitionClaimsResubmitForPayment resubmitForPayment; \n    \n    /**\n     * @param fsm\n     */\n    ClaimsPaymentRejected(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        // Transition resubmit for payment\n        this.resubmitForPayment = new TransitionClaimsResubmitForPayment(this, getStateMachine().readyForPayment());\n        allTransitions.add(this.resubmitForPayment); \n\n        return allTransitions;    \n    }\n    \n    /**\n     * execute the resubmit for payment transition\n     * @return true if the transition was successful\n     */\n    public boolean resubmitForPayment() {\n        this.resubmitForPayment.execute();\n        return this.resubmitForPayment.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerResubmitForPaymentListener(final T listener)\n    {\n        return this.resubmitForPayment.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterResubmitForPaymentListener(final TransitionListener listener)\n    {\n        return this.resubmitForPayment.unregisterListener(listener);\n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[263443]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * <p>\n * A TransitionPathResult represents the result of trying to execute a {@link TransitionPath}.\n * You can query the result, asking if it was successful or not. In the case where it was not\n * successful, you can retrieve a collection of \'reason\' enumerations, which indicate why the\n * path was not successful. The reasons given will be those from the exit/enter state guards or \n * transition guards. \n * </p>\n * See {@link TransitionPath#execute()}.\n */\npublic final class TransitionPathResult\n{\n    private Collection<Enum<?>> reasons;\n    private PathEntry failedEntry;\n    \n    private TransitionPathResult(final PathEntry failedEntryValue, final Collection<Enum<?>> reasonValues)\n    {\n        this.reasons = reasonValues;\n        this.failedEntry = failedEntryValue;\n    }\n    \n    /**\n     * @return the failure reasons\n     */\n    public Collection<Enum<?>> getFailureReasons()\n    {\n        return Collections.unmodifiableCollection(this.reasons);\n    }\n    \n    /**\n     * @return the failed path entry\n     */\n    public PathEntry getFailedEntry()\n    {\n        return this.failedEntry;\n    }\n    \n    /**\n     * @return true if the transition was successful\n     */\n    public boolean isSuccess()\n    {\n        return this.reasons.isEmpty();\n    }\n    \n    /**\n     * @return true if the transition failed\n     */\n    public boolean isFail()\n    {\n        return !isSuccess();\n    }\n    \n    /**\n     * factory method for success results\n     * @return a new success result\n     */\n    static TransitionPathResult success()\n    {\n        final Collection<Enum<?>> r = Collections.emptyList();\n        return new TransitionPathResult(null, r);\n    }\n\n    /**\n     * factory method for failure results\n     * @return a new failure result\n     */\n    static TransitionPathResult fail(final PathEntry failedEntryValue, final Collection<Enum<?>> reasonValues)\n    {\n        return new TransitionPathResult(failedEntryValue, reasonValues);\n    }\n\n    /**\n     * factory method for failure results\n     * @return a new failure result\n     */\n    static TransitionPathResult fail(final Enum<?> ... reasonValues)\n    {\n        final Collection<Enum<?>> r = new ArrayList<Enum<?>>();\n        if (reasonValues == null || reasonValues.length == 0)\n        {\n            r.add(TransitionGuard.Reasons.NO_REASON_GIVEN);\n        }\n        else\n        {\n            r.addAll(Arrays.asList(reasonValues));\n        }\n        return new TransitionPathResult(null, r);\n    }\n    \n    /** \n     * @return the string representation\n     */\n    @Override\n    public String toString()\n    {\n        if(isSuccess())\n        {\n            return ""SUCCESS"";\n        }\n        return String.format(""FAIL: entry=%s reasons=%s"", this.failedEntry, this.reasons);\n    }\n}\n')",[260026]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_addState(com.porpoise.fsm.model.StateMachineTest)')","[2727, 2758, 2789, 3843, 3874, 3905, 21765, 21789, 21813, 31758, 31788, 31818, 43540, 43575, 43610, 44800, 44835, 44870, 65058, 65086, 65114, 74300, 74328, 74356, 85290, 85323, 85356, 86478, 86511, 86544, 105568, 105594, 105620, 114191, 114223, 114255, 126765, 126802, 126839, 128097, 128134, 128171, 149523, 149553, 149583, 159582, 159617, 159652, 173344, 173384, 173424, 174784, 174824, 174864, 197962, 197995, 198028, 208798, 208835, 208872, 223352, 223394, 223436, 224864, 224906, 224948, 249508, 249548, 249588, 250512, 250554, 250596]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * <p>\n * state transitions are checked using guard conditions. There may be state exit conditions, transition conditions, and state enter\n * conditions. Each of these conditions will return a {@link TransitionGuard}, signaling if the state transition should be allowed to continue.\n * If all guards allow the transition to continue, then a state transition will take place. However, a guard condition may signal that the\n * state transition should not continue, either stopping immediately or stop once the remaining transition listeners are notified.\n * </p>\n * <p>\n * In addition to controlling the state transitions, a transition guard may also specify a \'reason\' should the guard not allow processing.\n * The reason can be a generic {@link Enum} type. If no reason is given then {@link #getReason()} will return\n * {@link Reasons#NO_REASON_GIVEN}.\n * </p>\n */\npublic class TransitionGuard\n{\n    /**\n     * Default \'stop\' Reasons\n     */\n    public enum Reasons\n    {\n        NO_REASON_GIVEN,//\n        ALREADY_IN_TARGET_STATE, // \n        TARGET_STATE_UNREACHABLE;\n    }\n\n    /**\n     * This enumeration allows listeners to notify the state machine whether or not it should continue processing. Using this mechanism we\n     * avoid listeners having to throw exceptions for process flow.\n     */\n    public enum Type\n    {\n        /**\n        *\n        */\n        CONTINUE\n        {\n            @Override\n            boolean continueProcessingInternal()\n            {\n                return true;\n            }\n\n            @Override\n            boolean stopInternal()\n            {\n                return false;\n            }\n        }, //\n        /**\n        *\n        */\n        STOP_IMMEDIATELY\n        {\n            @Override\n            boolean continueProcessingInternal()\n            {\n                return false;\n            }\n\n            @Override\n            boolean stopInternal()\n            {\n                return true;\n            }\n        }, //\n        /**\n        *\n        */\n        STOP_AFTER_PROCESSING_REMAINING_LISTENERS\n        {\n            @Override\n            boolean continueProcessingInternal()\n            {\n                return false;\n            }\n\n            @Override\n            boolean stopInternal()\n            {\n                return false;\n            }\n        }\n\n        ;//\n\n        abstract boolean continueProcessingInternal();\n\n        boolean continueProcessing()\n        {\n            final boolean result = continueProcessingInternal();\n            if (!result)\n            {\n                StateLog.trace(""asked to stop eventually"");\n            }\n            return result;\n        }\n\n        abstract boolean stopInternal();\n\n        boolean stop()\n        {\n            final boolean result = stopInternal();\n            if (result)\n            {\n                StateLog.trace(""asked to stop immediately"");\n            }\n            return result;\n        }\n    }\n\n    private final Type    type;\n    private final Enum<?> reason;\n\n    /**\n     * @return the type\n     */\n    public Type getType()\n    {\n        return this.type;\n    }\n\n    /**\n     * @return the reason, or {@link Reasons#NO_REASON_GIVEN} if no reason was specified\n     */\n    public Enum<?> getReason()\n    {\n        return this.reason == null ? Reasons.NO_REASON_GIVEN : this.reason;\n    }\n    \n    /**\n     * @return the reason as a collection\n     */\n    final  Collection<Enum<?>> getReasons()\n    {\n        if (this.reason == null)\n        {\n            return Collections.emptyList();\n        }\n        final Collection<Enum<?>> reasons = new ArrayList<Enum<?>>();\n        reasons.add(getReason());\n        return reasons;\n    }\n    public TransitionGuard(final Type t, final Enum<?> reasonValue)\n    {\n        this.type = t;\n        this.reason = reasonValue;\n    }\n\n    /**\n     * return a collection of reasons given for any stopping guards given.\n     * If all guards are of type \'continue\' then an empty collection is returned. \n     * @return a collection of reason enumerations for the given guards\n     */\n    static Collection<Enum<?>> filterReasons(final TransitionGuard... guards)\n    {\n        Collection<Enum<?>> reasons = null;\n        for (final TransitionGuard guard : guards)\n        {\n            if (!guard.continueProcessing())\n            {\n                if (reasons == null)\n                {\n                    reasons = new ArrayList<Enum<?>>();\n                }\n                reasons.add(guard.getReason());\n            }\n        }\n        if (reasons == null)\n        {\n            reasons = Collections.emptyList();\n        }\n\n        return reasons;\n    }\n\n    private static final TransitionGuard GUARD_CONTINUE         = new TransitionGuard(Type.CONTINUE, null);\n    private static final TransitionGuard GUARD_STOP_IMMIDIATELY = new TransitionGuard(Type.STOP_IMMEDIATELY, null);\n    private static final TransitionGuard GUARD_STOP_EVENTUALLY  = new TransitionGuard(Type.STOP_AFTER_PROCESSING_REMAINING_LISTENERS, null);\n\n    /**\n     * @return true if the transition should stop\n     */\n    public boolean stop()\n    {\n        return this.type.stop();\n    }\n\n    /**\n     * @return true if the transition should continue\n     */\n    public boolean continueProcessing()\n    {\n        return this.type.continueProcessing();\n    }\n\n    /**\n     * @return a generic \'continue\' transition guard\n     */\n    public static TransitionGuard ok()\n    {\n        return GUARD_CONTINUE;\n    }\n\n    /**\n     * @return a generic stop immediately transition guard\n     */\n    public static TransitionGuard stopImmediately()\n    {\n        return GUARD_STOP_IMMIDIATELY;\n    }\n\n    /**\n     * @param reason\n     * @return a generic stop eventually transition guard\n     */\n    public static TransitionGuard stopImmediately(final Enum<?> stopReason)\n    {\n        return new TransitionGuard(Type.STOP_IMMEDIATELY, stopReason);\n    }\n\n    /**\n     * @return a generic stop eventually transition guard\n     */\n    public static TransitionGuard stopEventually()\n    {\n        return GUARD_STOP_EVENTUALLY;\n    }\n\n    /**\n     * @param reason\n     * @return a generic stop eventually transition guard\n     */\n    public static TransitionGuard stopEventually(final Enum<?> stopReason)\n    {\n        return new TransitionGuard(Type.STOP_AFTER_PROCESSING_REMAINING_LISTENERS, stopReason);\n    }\n    \n    /**\n     * @return the string representation\n     */\n    @Override\n    public String toString()\n    {\n        return String.format(""%s [%s]"", this.type, this.reason);\n    }\n}\n')",[257595]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getStateForName(aaron.test.test.ClaimsNotReceivedTest)')","[1061, 1085, 1109, 6199, 6230, 6261, 8803, 8834, 8865, 22917, 22941, 22965, 29400, 34157, 34187, 34217, 35498, 35526, 35554, 47460, 47495, 47530, 50400, 50435, 50470, 66402, 66430, 66458, 76533, 76561, 76589, 77784, 77810, 77836, 88986, 89019, 89052, 91758, 91791, 91824, 106816, 106842, 106868, 116756, 116788, 116820, 118187, 118217, 118247, 130909, 130946, 130983, 134017, 134054, 134091, 150963, 150993, 151023, 162396, 162431, 162466, 163962, 163995, 164028, 177824, 177864, 177904, 181184, 181224, 181264, 199546, 199579, 199612, 211778, 211815, 211852, 213434, 213469, 213504, 228056, 228098, 228140, 231584, 231626, 231668, 289771, 289811, 289851, 291535, 291577, 291619]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsReceivedByHeadOfDeliveryAndClaimsReceivedByDeliveryTeam(aaron.test.test.ClaimsReceivedByHeadOfDeliveryTest)')","[12895, 12926, 12957, 16243, 16274, 16305, 26085, 26109, 26133, 38528, 38558, 38588, 55020, 55055, 55090, 58800, 58835, 58870, 70098, 70126, 70154, 80610, 80638, 80666, 96114, 96147, 96180, 99678, 99711, 99744, 110248, 110274, 110300, 121421, 121453, 121485, 138901, 138938, 138975, 142897, 142934, 142971, 154923, 154953, 154983, 167502, 167537, 167572, 186464, 186504, 186544, 190784, 190824, 190864, 203902, 203935, 203968, 217178, 217215, 217252, 237128, 237170, 237212, 241664, 241706, 241748, 300373, 300413, 300453, 301681, 301723, 301765]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport com.google.common.base.Predicate;\n\n/**\n * A PredicateToggle provides a means for toggling a {@link Predicate}\n */\npublic final class PredicateToggle\n{\n    private final AtomicBoolean     enabled;\n    private final Predicate<Object> predicate;\n\n    private PredicateToggle(final boolean firstValue)\n    {\n        this.enabled = new AtomicBoolean(firstValue);\n        this.predicate = new Predicate<Object>() {\n            @Override\n            public boolean apply(final Object value)\n            {\n                return isEnabled();\n            }\n\n            @Override\n            public String toString()\n            {\n                return String.format(""Toggle %b"", Boolean.valueOf(isEnabled()));\n            }\n        };\n    }\n\n    /**\n     * @return a new enabled toggle\n     */\n    public static PredicateToggle on()\n    {\n        return new PredicateToggle(true);\n    }\n\n    /**\n     * @return a new disabled toggle\n     */\n    public static PredicateToggle off()\n    {\n        return new PredicateToggle(false);\n    }\n\n    /**\n     * enable the toggle\n     * \n     * @return true if this method call changed the toggle value\n     */\n    public boolean enable()\n    {\n        return this.enabled.compareAndSet(false, true);\n    }\n\n    /**\n     * disable the toggle\n     * \n     * @return true if this method call changed the toggle value\n     */\n    public boolean disable()\n    {\n        return this.enabled.compareAndSet(true, false);\n    }\n\n    /**\n     * switch the toggle value - going from off to on or from on to off.\n     */\n    public void toggle()\n    {\n        this.enabled.set(!isEnabled());\n    }\n\n    /**\n     * @return true if the toggle is currently enabled\n     */\n    public boolean isEnabled()\n    {\n        return this.enabled.get();\n    }\n\n    /**\n     * @return a transition filter representing the current state of the toggle\n     */\n    @SuppressWarnings(""unchecked"")\n    public <T> Predicate<T> predicate()\n    {\n        return (Predicate<T>) this.predicate;\n    }\n}\n')",[280380]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\binterface (\\w+).*', 'package p;\n\npublic interface NamedObject\n{\n    /**\n     * @return a name for the object\n     */\n    public String getName();\n}\n')",[277719]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\nimport com.google.common.base.Predicate;\n\n/**\n * a listener which can be turned on and off by the given predicate\n */\npublic abstract class AbstractConditionalStateListener implements StateListener\n{\n    private final Predicate<Transition> enterFilter;\n    private final Predicate<Transition> exitFilter;\n    private final TransitionGuard        enterReturnValueOnPredicateFalse;\n    private final TransitionGuard        exitReturnValueOnPredicateFalse;\n\n    /**\n     * @param predicate\n     *            the predicate logic used to filter the given listener.\n     */\n    public AbstractConditionalStateListener(final Predicate<Transition> predicate)\n    {\n        this(predicate, predicate);\n    }\n\n    /**\n     * @param enterPredicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener\'s onEnter will be executed.\n     * @param exitPredicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener\'s onExit method will be executed.\n     */\n    public AbstractConditionalStateListener(final Predicate<Transition> enterPredicate, final Predicate<Transition> exitPredicate)\n    {\n        this(enterPredicate, exitPredicate, TransitionGuard.ok(), TransitionGuard.ok());\n    }\n\n    /**\n     * @param enterPredicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener\'s onEnter will be executed.\n     * @param exitPredicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener\'s onExit method will be executed.\n     * @param predicate\n     *            the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped\n     *            listener will be executed.\n     * @param listener\n     * @param enterDefault\n     *            the transition to return should the enter predicate filter return false\n     * @param exitDefault\n     *            the transition to return should the exit predicate filter return false\n     */\n    public AbstractConditionalStateListener(final Predicate<Transition> enterPredicate, final Predicate<Transition> exitPredicate,\n            final TransitionGuard enterDefault, final TransitionGuard exitDefault)\n    {\n        if (enterPredicate == null)\n        {\n            throw new NullPointerException(""enterPredicate cannot be null"");\n        }\n        if (enterDefault == null)\n        {\n            throw new NullPointerException(""enterDefault cannot be null"");\n        }\n        if (exitPredicate == null)\n        {\n            throw new NullPointerException(""exitPredicate cannot be null"");\n        }\n        if (exitDefault == null)\n        {\n            throw new NullPointerException(""exitDefault cannot be null"");\n        }\n        this.enterFilter = enterPredicate;\n        this.exitFilter = exitPredicate;\n\n        this.enterReturnValueOnPredicateFalse = enterDefault;\n        this.exitReturnValueOnPredicateFalse = exitDefault;\n    }\n\n    /**\n     * the exit condition predicate was successful. Return the result from the exit listener logic.\n     * \n     * @param transition\n     *            the transition\n     * @return the transition return value.\n     */\n    protected abstract TransitionGuard onExitInternal(final Transition transition);\n\n    /**\n     * the enter condition predicate was successful. Return the result from the exit listener logic.\n     * \n     * @param transition\n     *            the transition\n     * @return the transition return value.\n     */\n    protected abstract TransitionGuard onEnterInternal(final Transition transition);\n\n    /**\n     * @param transition\n     * @return the transition return value.\n     */\n    public final TransitionGuard onExit(final Transition transition)\n    {\n        if (!this.exitFilter.apply(transition))\n        {\n            return this.exitReturnValueOnPredicateFalse;\n        }\n        return onExitInternal(transition);\n    }\n\n    /**\n     * @param transition\n     * @return the transition return value.\n     */\n    @Override\n    public final TransitionGuard onEnter(final Transition transition)\n    {\n        if (!this.enterFilter.apply(transition))\n        {\n            return this.enterReturnValueOnPredicateFalse;\n        }\n        return onEnterInternal(transition);\n    }\n\n    /**\n     * @return the return value to use when the predicate logic evaluates to \'false\'\n     */\n    protected TransitionGuard getDefaultEnterReturnValueOnFalse()\n    {\n        return this.enterReturnValueOnPredicateFalse;\n    }\n\n    /**\n     * @return the return value to use when the predicate logic evaluates to \'false\'\n     */\n    protected TransitionGuard getDefaultExitReturnValueOnFalse()\n    {\n        return this.exitReturnValueOnPredicateFalse;\n    }\n\n    @Override\n    public String toString()\n    {\n        return String.format(""conditional listener[enter=%s, exit=%s]"", this.enterFilter, this.exitFilter);\n    }\n}')",[278857]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\binterface (\\w+).*', 'package aaron.test;\n\n/**\n * listener callback interface \n */\npublic interface TransitionListener\n{\n\n    /**\n     * fired when a transition is executed\n     * @return the transition guard\n     */\n    TransitionGuard onTransition(final Transition transition);\n}\n')",[256880]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\n/**\n * listener callback interface \n */\npublic interface TransitionListener\n{\n\n    /**\n     * fired when a transition is executed\n     * @return the transition guard\n     */\n    TransitionGuard onTransition(final Transition transition);\n}\n')",[280221]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'aaron.test.test.ClaimsPaymentReceivedTest')","[310803, 310826, 310850, 310873]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\binterface (\\w+).*', 'package p;\n\n/**\n * a listener callback used to respond to state changes.\n */\npublic interface StateListener\n{\n    /**\n     *\n     */\n    TransitionGuard onExit(final Transition transition);\n    \n    /**\n     *\n     */\n    TransitionGuard onEnter(final Transition transition);\n}\n')",[280015]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsRejectToMo extends AbstractTransition<ClaimsReceivedByDeliveryTeam, ClaimsReceivedByMonitoringOfficer>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""reject to mo"";\n\n    TransitionClaimsRejectToMo(final ClaimsReceivedByDeliveryTeam from, final ClaimsReceivedByMonitoringOfficer to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[267407]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n *\n */\nclass StateNotifier\n{\n    private final List<StateListener> listeners;\n    \n    private enum TransitionType {\n        ENTER {\n            @Override\n            public TransitionGuard fire(final StateListener listener, final Transition transition)\n            {\n                return listener.onEnter(transition);\n            }\n        },\n        EXIT {\n            @Override\n            public TransitionGuard fire(final StateListener listener, final Transition transition)\n            {\n                return listener.onExit(transition);\n            }\n        };\n        \n        public abstract TransitionGuard fire(StateListener listener, Transition trans);\n    }\n\n    /**\n     */\n    StateNotifier()\n    {\n        super();\n        this.listeners = new CopyOnWriteArrayList<StateListener>();\n    }\n\n    /**\n     * @param listener the listener\n     * @return true if the listener was registered\n     */\n    public boolean registerListener(final StateListener listener)\n    {\n        if (listener == null)\n            return false;\n        return this.listeners.add(listener);\n    }\n\n    /**\n     * @param listener the listener\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterListener(final StateListener listener)\n    {\n        if (listener == null)\n            return false;\n        return this.listeners.remove(listener);\n    }\n\n\n    final TransitionGuard onBeforeTransition(final Transition transition)\n    {\n        return fireTransition(transition, TransitionType.EXIT);\n    }\n\n    final TransitionGuard onAfterTransition(final Transition transition)\n    {\n        return fireTransition(transition, TransitionType.ENTER);\n    }\n\n    final TransitionGuard fireTransition(final Transition transition, final TransitionType type)\n    {\n        TransitionGuard result = TransitionGuard.ok();\n\n        //\n        // fire general-purpose listeners\n        //\n        for (final StateListener listener : this.listeners)\n        {\n            final TransitionGuard condition = type.fire(listener, transition);\n            if (condition.stop())\n            {\n                StateLog.debug(""asked to stop immediately by listener \'%s\' for transition \'%s\'. Reason=%s"", listener, transition, condition.getReason());\n                return condition;\n            }\n            else if (!condition.continueProcessing())\n            {\n                StateLog.debug(""asked to stop eventually by listener \'%s\' for transition \'%s\'. Reason=%s"", listener, transition, condition.getReason());\n                // if *any* listener asks to stop, then set the result to stop\n                result = condition;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @return the string representation\n     */\n    @Override\n    public String toString()\n    {\n        final String newLine = String.format(""%n"");\n        final StringBuilder b = new StringBuilder();\n        for (final StateListener listener : this.listeners)\n        {\n            b.append(listener).append(newLine);\n        }\n        return String.format(""Listeners: %s"", b);\n    }\n}\n')",[284874]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_moveToClaimsReceivedByHeadOfDelivery(aaron.test.test.ClaimsNotReceivedTest)')","[7408, 10012, 23853, 29610, 35327, 48825, 51765, 67494, 77625, 90273, 93045, 107830, 118004, 132352, 135460, 152133, 163761, 179384, 182744, 200833, 213221, 229694, 233222, 291331, 293173]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsPaymentRejected\n */\npublic class ClaimsPaymentRejectedTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the \'ClaimsPaymentRejected\' state\n     */\n    @Test\n    public void test_executeToClaimsPaymentRejected()\n    {\n        Assert.assertNotNull(moveToClaimsPaymentRejected());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for \'paymentRejected\' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.paymentRejected().getName();\n        Assert.assertEquals(fsm.paymentRejected(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the paymentRejected state\n     */\n    final ClaimsPaymentRejected moveToClaimsPaymentRejected()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsPaymentRejected paymentRejected = fsm.paymentRejected();\n\n        // call the method under test\n        fsm.executeToState(paymentRejected);\n\n        Assert.assertSame(paymentRejected, fsm.getCurrentState());\n        Assert.assertEquals(paymentRejected.getName(), fsm.getCurrentStateName());\n        \n        return paymentRejected;\n    }\n\n    \n    @Test\n    public void test_getPathBetweenClaimsPaymentRejectedAndClaimsReadyForPayment()\n    {\n\n        final ClaimsPaymentRejected paymentRejected = moveToClaimsPaymentRejected();\n        final ClaimsStateMachine fsm = paymentRejected.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'paymentRejected\'"", paymentRejected, fsm.getCurrentState());\n\n        final TransitionPaths paths = paymentRejected.getPaths(fsm.readyForPayment());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        paymentRejected.registerResubmitForPaymentListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'paymentRejected\'"", paymentRejected, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.readyForPayment(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'resubmitForPayment\' transition \n     */\n    @Test\n    public void test_resubmitForPayment()\n    {\n        final ClaimsPaymentRejected paymentRejected = moveToClaimsPaymentRejected();\n        final ClaimsStateMachine fsm = paymentRejected.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        paymentRejected.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        paymentRejected.resubmitForPayment();\n\n        //\n        // assert the current state is now ClaimsReadyForPayment\n        //\n        Assert.assertEquals(fsm.readyForPayment(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.readyForPayment().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsResubmitForPayment.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsResubmitForPayment.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(paymentRejected.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsPaymentRejected\' can be moved into the ClaimsReadyForPayment state\n     */\n    @Test\n    public void test_moveToClaimsReadyForPayment()\n    {\n        final ClaimsPaymentRejected paymentRejected = moveToClaimsPaymentRejected();\n        final ClaimsStateMachine fsm = paymentRejected.getStateMachine();\n        paymentRejected.getPaths(fsm.readyForPayment());\n        \n    }\n}\n')",[270095]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsSubmitToDeliveryTeam extends AbstractTransition<ClaimsNotReceived, ClaimsReceivedByDeliveryTeam>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""submit to delivery team"";\n\n    TransitionClaimsSubmitToDeliveryTeam(final ClaimsNotReceived from, final ClaimsReceivedByDeliveryTeam to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[266124]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsMarkPaymentAsComplete extends AbstractTransition<ClaimsPaymentReceived, ClaimsPaymentComplete>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""mark payment as complete"";\n\n    TransitionClaimsMarkPaymentAsComplete(final ClaimsPaymentReceived from, final ClaimsPaymentComplete to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[266763]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsRejectPayment extends AbstractTransition<ClaimsReadyForPayment, ClaimsPaymentRejected>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""reject payment"";\n\n    TransitionClaimsRejectPayment(final ClaimsReadyForPayment from, final ClaimsPaymentRejected to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[264301]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_moveToClaimsReceivedByHeadOfDelivery(aaron.test.test.ClaimsReceivedByMonitoringOfficerTest)')","[10415, 10446, 10477, 13763, 13794, 13825, 24933, 24957, 24981, 36951, 36981, 37011, 52220, 52255, 52290, 56000, 56035, 56070, 68754, 68782, 68810, 79139, 79167, 79195, 93474, 93507, 93540, 97038, 97071, 97104, 109000, 109026, 109052, 119738, 119770, 119802, 135941, 135978, 136015, 139937, 139974, 140011, 153483, 153513, 153543, 165660, 165695, 165730, 183264, 183304, 183344, 187584, 187624, 187664, 202318, 202351, 202384, 215230, 215267, 215304, 233768, 233810, 233852, 238304, 238346, 238388, 296511, 296551, 296591, 298291, 298333, 298375]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n *\n */\nclass StateNotifier\n{\n    private final List<StateListener> listeners;\n    \n    private enum TransitionType {\n        ENTER {\n            @Override\n            public TransitionGuard fire(final StateListener listener, final Transition transition)\n            {\n                return listener.onEnter(transition);\n            }\n        },\n        EXIT {\n            @Override\n            public TransitionGuard fire(final StateListener listener, final Transition transition)\n            {\n                return listener.onExit(transition);\n            }\n        };\n        \n        public abstract TransitionGuard fire(StateListener listener, Transition trans);\n    }\n\n    /**\n     */\n    StateNotifier()\n    {\n        super();\n        this.listeners = new CopyOnWriteArrayList<StateListener>();\n    }\n\n    /**\n     * @param listener the listener\n     * @return true if the listener was registered\n     */\n    public boolean registerListener(final StateListener listener)\n    {\n        if (listener == null)\n            return false;\n        return this.listeners.add(listener);\n    }\n\n    /**\n     * @param listener the listener\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterListener(final StateListener listener)\n    {\n        if (listener == null)\n            return false;\n        return this.listeners.remove(listener);\n    }\n\n\n    final TransitionGuard onBeforeTransition(final Transition transition)\n    {\n        return fireTransition(transition, TransitionType.EXIT);\n    }\n\n    final TransitionGuard onAfterTransition(final Transition transition)\n    {\n        return fireTransition(transition, TransitionType.ENTER);\n    }\n\n    final TransitionGuard fireTransition(final Transition transition, final TransitionType type)\n    {\n        TransitionGuard result = TransitionGuard.ok();\n\n        //\n        // fire general-purpose listeners\n        //\n        for (final StateListener listener : this.listeners)\n        {\n            final TransitionGuard condition = type.fire(listener, transition);\n            if (condition.stop())\n            {\n                StateLog.debug(""asked to stop immediately by listener \'%s\' for transition \'%s\'. Reason=%s"", listener, transition, condition.getReason());\n                return condition;\n            }\n            else if (!condition.continueProcessing())\n            {\n                StateLog.debug(""asked to stop eventually by listener \'%s\' for transition \'%s\'. Reason=%s"", listener, transition, condition.getReason());\n                // if *any* listener asks to stop, then set the result to stop\n                result = condition;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @return the string representation\n     */\n    @Override\n    public String toString()\n    {\n        final String newLine = String.format(""%n"");\n        final StringBuilder b = new StringBuilder();\n        for (final StateListener listener : this.listeners)\n        {\n            b.append(listener).append(newLine);\n        }\n        return String.format(""Listeners: %s"", b);\n    }\n}\n')",[261849]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_resubmitForPayment(aaron.test.test.ClaimsPaymentRejectedTest)')","[20459, 20490, 20521, 28773, 28797, 28821, 42573, 42603, 42633, 63560, 63595, 63630, 73234, 73262, 73290, 84381, 84409, 84437, 104166, 104199, 104232, 113160, 113186, 113212, 125740, 125772, 125804, 147929, 147966, 148003, 158283, 158313, 158343, 172232, 172267, 172302, 196224, 196264, 196304, 207598, 207631, 207664, 222182, 222219, 222256, 247376, 247418, 247460, 309859, 309899, 309939, 310695, 310737, 310779]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport com.google.common.base.Predicate;\n\n/**\n * A collection of useful implementations of StateListener\n */\npublic enum StateListeners \n{\n    ;//uninstantiable\n    \n    static class BlockEntryListener extends ListenerAdapter\n    {\n        private final Enum<?> reason;\n        public BlockEntryListener(final Enum<?> reason)\n        {\n            super(TransitionGuard.stopEventually(reason), TransitionGuard.ok());\n            this.reason = reason;\n        }\n        public BlockEntryListener()\n        {\n            this(null);\n        }\n\n        @Override\n        public String toString()\n        {\n            return String.format(""block entry (reason=%s)"", this.reason);\n        }\n    }\n\n    static class BlockExitListener extends ListenerAdapter\n    {\n        private final Enum<?> reason;\n        public BlockExitListener(final Enum<?> reason)\n        {\n            super(TransitionGuard.ok(), TransitionGuard.stopEventually(reason));\n            this.reason = reason;\n        }\n        public BlockExitListener()\n        {\n            this(null);\n        }\n\n        @Override\n        public String toString()\n        {\n            return String.format(""block exit (reason=%s)"", this.reason);\n        }\n    }\n\n    /**\n     */\n    public static RecordingListener recordingListener()\n    {\n        return new RecordingListener();\n    }\n\n    /**\n     * a listener which records the transitions\n     */\n    public static class RecordingListener extends ListenerAdapter\n    {\n        private final List<Transition> enterTransitions = new ArrayList<Transition>();\n        private final List<Transition> exitTransitions  = new ArrayList<Transition>();\n\n        @Override\n        public TransitionGuard onExit(final Transition transition)\n        {\n            this.exitTransitions.add(transition);\n            return TransitionGuard.ok();\n        }\n\n        @Override\n        public TransitionGuard onEnter(final Transition transition)\n        {\n            this.enterTransitions.add(transition);\n            return TransitionGuard.ok();\n        }\n\n        /**\n         * @return the exit transitions\n         */\n        public List<Transition> getExitTransitions()\n        {\n            return Collections.unmodifiableList(this.exitTransitions);\n        }\n\n        /**\n         * @return the enter transitions\n         */\n        public List<Transition> getEnterTransitions()\n        {\n            return Collections.unmodifiableList(this.enterTransitions);\n        }\n\n        @Override\n        public String toString()\n        {\n            return ""recording listener"";\n        }\n    }\n\n    /**\n     */\n    public static class EchoListener extends ListenerAdapter\n    {\n        private final PrintStream out;\n\n        public EchoListener(final PrintStream outStream)\n        {\n            if (outStream == null)\n            {\n                throw new NullPointerException();\n            }\n            this.out = outStream;\n        }\n\n        @Override\n        public TransitionGuard onEnter(final Transition transition)\n        {\n            this.out.println(String.format(""enter \'%s\' via \'%s\'"", transition.getTarget().getName(), transition.getName()));\n            return TransitionGuard.ok();\n        }\n\n        @Override\n        public TransitionGuard onExit(final Transition transition)\n        {\n            this.out.println(String.format(""exit \'%s\' via \'%s\'"", transition.getSource().getName(), transition.getName()));\n            return TransitionGuard.ok();\n        }\n        @Override\n        public String toString()\n        {\n            return ""echo listener"";\n        }\n    }\n\n    public static EchoListener echoListener(final PrintStream out)\n    {\n        return new EchoListener(out);\n    }\n\n    /**\n     * @return the registered listener\n     */\n    public static StateListener blockEntryListener()\n    {\n        return blockEntryListener(null);\n    }\n\n    /**\n     * @return the registered listener\n     */\n    public static StateListener blockEntryListener(final Enum<?> reason)\n    {\n        return new BlockEntryListener(reason);\n    }\n\n    /**\n     * @return the listener\n     */\n    public static StateListener blockExitListener()\n    {\n        return blockExitListener(null);\n    }\n\n    /**\n     * @return the listener\n     */\n    public static StateListener blockExitListener(final Enum<?> reason)\n    {\n        return new BlockExitListener(reason);\n    }\n\n    /**\n     * @param state\n     *            the state to match\n     * @return a predicate which will return true for transitions whos target state matches the given state\n     */\n    public static Predicate<Transition> targetStateEquals(final State state)\n    {\n        if (state == null)\n        {\n            throw new NullPointerException(""state cannot be null"");\n        }\n        return new Predicate<Transition>() {\n\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return value.getTarget().equals(state);\n            }\n        };\n    }\n\n    /**\n     * @param state\n     *            the state to match\n     * @return a predicate which will return true for transitions whos source state matches the given state\n     */\n    public static Predicate<Transition> sourceStateEquals(final State state)\n    {\n        if (state == null)\n        {\n            throw new NullPointerException(""state cannot be null"");\n        }\n        return new Predicate<Transition>() {\n\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return value.getSource().equals(state);\n            }\n        };\n    }\n\n    /**\n     * @param the reason\n     * @return the registered listener\n     */\n    public static StateListener blockEntry(final State state, final Enum<?> reason)\n    {\n        final StateListener listener = filter(targetStateEquals(state), blockEntryListener(reason));\n        return listener;\n    }\n\n    /**\n     * @param the reason\n     * @return the registered listener\n     */\n    public static StateListener blockExit(final State state, final Enum<?> reason)\n    {\n        final StateListener listener = filter(sourceStateEquals(state), blockExitListener(reason));\n        return listener;\n    }\n\n    /**\n     * @param filter\n     *            the filter to apply to the given listener\n     * @param listener\n     *            the listener to wrap\n     * @return the wrapped listener\n     */\n    public static ConditionalStateListener filter(final Predicate<Transition> filter, final StateListener listener)\n    {\n        return new ConditionalStateListener(filter, listener);\n    }\n\n    /**\n     * @param listeners\n     *            the listeners to treat as a single group\n     * @return the grouped listener\n     */\n    public static GroupStateListener group(final StateListener... listeners)\n    {\n        return new GroupStateListener(listeners);\n    }\n\n    /**\n     * @param listeners\n     *            the listeners to treat as a single group\n     * @return the group listener which you can turn on and off\n     */\n    public static ConditionalStateListener group(final Predicate<Transition> predicate, final StateListener... listeners)\n    {\n        return filter(predicate, group(listeners));\n    }\n }')",[284437]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsApproveForHod extends AbstractTransition<ClaimsReceivedByDeliveryTeam, ClaimsReceivedByHeadOfDelivery>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""approve for hod"";\n\n    TransitionClaimsApproveForHod(final ClaimsReceivedByDeliveryTeam from, final ClaimsReceivedByHeadOfDelivery to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[267566]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'aaron.test.test.ClaimsPaymentCompleteTest')","[896, 33985, 76373, 116572, 162194, 211564]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\n\n/**\n * A holder for \'paths\' -- chains of transitions through the state machine\n */\npublic final class TransitionPaths implements Iterable<TransitionPath>\n{\n    private final Collection<TransitionPath> paths;\n\n    TransitionPaths()\n    {\n        this.paths = new ArrayList<TransitionPath>();\n    }\n\n    boolean add(final TransitionPath path)\n    {\n        if (!this.paths.contains(path))\n        {\n            return this.paths.add(path);\n        }\n        return false;\n    }\n \n    /** \n     * @return the paths\n     */\n    public Collection<TransitionPath> getPaths()\n    {\n        return Collections.unmodifiableCollection(this.paths);\n    }\n\n    /** \n     * get the path at index i\n     */\n    public TransitionPath getPath(final int i)\n    {\n        if (i < 0 || i > getPaths().size())\n        {\n            return null;\n        }\n        int index = 0;\n        for (final TransitionPath path : getPaths())\n        {\n            if (index == i)\n                return path;\n            index++;\n        }\n        return null;\n    }\n\n    /**\n     * return the shorted path. Multiple paths may exist with the same length\n     * \n     * @return the shorted path\n     */\n    public TransitionPath getShortestPath()\n    {\n        if (getPaths().isEmpty())\n            return null;\n        return getPathsAsSortedList().get(0);\n    }\n\n    /**\n     * @return a list of paths, shortest first\n     */\n    public List<TransitionPath> getPathsAsSortedList()\n    {\n        final LinkedList<TransitionPath> pathList = new LinkedList<TransitionPath>(getPaths());\n        Collections.sort(pathList);\n        return pathList;\n    }\n\n    /**\n     * @return the number of paths available between two states\n     */\n    public int size()\n    {\n        return this.paths.size();\n    }\n    \n    /**\n     * @return true if there are no paths between the two states\n     */\n    public boolean isEmpty()\n    {\n        return size() == 0;\n    }\n\n\n    /**\n     * @return the iterator\n     */\n    @Override\n    public Iterator<TransitionPath> iterator()\n    {\n        return getPathsAsSortedList().iterator();\n    }\n\n    /**\n     * @param names the name(s) of the transition(s) to include\n     * @return a {@link TransitionPaths} object which contains a subset of this paths object which contain the transition identified by the given name \n     */\n    public final TransitionPaths getPathsWithTransitions(final String ... names)\n    {\n        return filterPaths(PathFilters.byNames(names));\n    }\n\n    /**\n     * @name the name of the transition\n     * @return a {@link TransitionPaths} object which contains a subset of this paths object which does NOT contain the transition identified by the given name \n     */\n    public final TransitionPaths getPathsAvoidingTransitions(final String ... names)\n    {\n        final Predicate<TransitionPath> filter = PathFilters.byNames(names); \n        return filterPaths(Predicates.not(filter));\n    }\n    \n    /**\n     * @param filter the filter to apply to child paths\n     * @return a new TransitionPaths object which only contains TransitionPaths which match the given filter \n     */\n    public TransitionPaths filterPaths(final Predicate<TransitionPath> filter)\n    {\n        final TransitionPaths matchingPaths = new TransitionPaths();\n        for (final TransitionPath path : this)\n        {\n            if (filter.apply(path))\n            {\n                matchingPaths.add(path);\n            }\n        }\n        return matchingPaths;\n    }\n    \n    /**\n     * @return a string representation\n     */\n    @Override\n    public String toString()\n    {\n        final String newLine = String.format(""%n"");\n        final StringBuilder b = new StringBuilder();\n        for (final Object path : this.paths)\n        {\n            b.append(path).append(newLine);\n        }\n        return b.toString();\n    }\n    \n}')",[258521]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsNotReceivedAndClaimsReceivedByDeliveryTeam(aaron.test.test.ClaimsNotReceivedTest)')","[6819, 6850, 6881, 9423, 9454, 9485, 23397, 23421, 23445, 34757, 34787, 34817, 48160, 48195, 48230, 51100, 51135, 51170, 66962, 66990, 67018, 77093, 77121, 77149, 89646, 89679, 89712, 92418, 92451, 92484, 107336, 107362, 107388, 117396, 117428, 117460, 131649, 131686, 131723, 134757, 134794, 134831, 151563, 151593, 151623, 163096, 163131, 163166, 178624, 178664, 178704, 181984, 182024, 182064, 200206, 200239, 200272, 212518, 212555, 212592, 228896, 228938, 228980, 232424, 232466, 232508, 290571, 290611, 290651, 292375, 292417, 292459]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\n\n\n/**\n * Representation of the state machine. Through a ClaimsStateMachine instance you can:\n * <ul>\n * <li>Create a new instance (see @{link createAndStart()} and @{link create()})</li>\n * <li>Access all states by their names</li>\n * <li>register and unregister listeners which will be notified of every state transition</li>\n * <li>navigate to (execute) states via transitions</li>\n * <li>retrieve state instances by their names</li>\n * </ul>\n *\n * States returned via this state machine may *only* be used in this state machine.\n * For example, this is not valid:\n * <pre>\n * ClaimsStateMachine fsmOne = ClaimsStateMachine.createAndStart();\n * ClaimsStateMachine fsmTwo = ClaimsStateMachine.createAndStart();\n * Object stateA = fsmOne.<some state>();\n * fsmTwo.executeToState(stateA); // invalid  -- cannot share state instances between state machines\n * </pre>\n */\npublic class ClaimsStateMachine\n{\n    private StateNotifier notifier;\n    private State                     currentState;\n    private final Map<String, AbstractClaimsState>  stateByName;\n\n    private ClaimsPaymentRejected claimspaymentrejected;\n    private ClaimsReadyForPayment claimsreadyforpayment;\n    private ClaimsReceivedByHeadOfDelivery claimsreceivedbyheadofdelivery;\n    private ClaimsNotReceived claimsnotreceived;\n    private ClaimsPaymentReceived claimspaymentreceived;\n    private ClaimsReceivedByDeliveryTeam claimsreceivedbydeliveryteam;\n    private ClaimsPaymentComplete claimspaymentcomplete;\n    private ClaimsStartState claimsstartstate;\n    private ClaimsReceivedByMonitoringOfficer claimsreceivedbymonitoringofficer;\n\n    /**\n     *\n     */\n    private ClaimsStateMachine()\n    {\n        super();\n        this.stateByName = new HashMap<String, AbstractClaimsState>();\n    }\n\n    /**\n     * @return a new notifier\n     */\n    final StateNotifier newNotifier()\n    {\n        return new StateNotifier();\n    }\n\n    /**\n     * state machines need to be explicitly started.\n     * This is a convenience method for returning a new state machine which is \n     * already in the start state\n     *\n     * @return the new state machine\n     */\n    public static ClaimsStateMachine createAndStart()\n    {\n        ClaimsStateMachine instance = create();\n        instance.start();\n        return instance;\n    }\n\n    /**\n     * factory method used to create state machines\n     *\n     * @return a new state machine instance\n     */\n    public static ClaimsStateMachine create()\n    {\n        final ClaimsStateMachine fsm = new ClaimsStateMachine();\n\n        fsm.notifier = fsm.newNotifier();\n        \n        //\n        // Create states\n        //\n        fsm.claimspaymentrejected = new ClaimsPaymentRejected(fsm);\n        final State oldClaimsPaymentRejectedEntry = fsm.stateByName.put(fsm.claimspaymentrejected.getName(), fsm.claimspaymentrejected);\n        assert oldClaimsPaymentRejectedEntry == null : ""duplicate state names: "" + fsm.claimspaymentrejected.getName();\n\n        fsm.claimsreadyforpayment = new ClaimsReadyForPayment(fsm);\n        final State oldClaimsReadyForPaymentEntry = fsm.stateByName.put(fsm.claimsreadyforpayment.getName(), fsm.claimsreadyforpayment);\n        assert oldClaimsReadyForPaymentEntry == null : ""duplicate state names: "" + fsm.claimsreadyforpayment.getName();\n\n        fsm.claimsreceivedbyheadofdelivery = new ClaimsReceivedByHeadOfDelivery(fsm);\n        final State oldClaimsReceivedByHeadOfDeliveryEntry = fsm.stateByName.put(fsm.claimsreceivedbyheadofdelivery.getName(), fsm.claimsreceivedbyheadofdelivery);\n        assert oldClaimsReceivedByHeadOfDeliveryEntry == null : ""duplicate state names: "" + fsm.claimsreceivedbyheadofdelivery.getName();\n\n        fsm.claimsnotreceived = new ClaimsNotReceived(fsm);\n        final State oldClaimsNotReceivedEntry = fsm.stateByName.put(fsm.claimsnotreceived.getName(), fsm.claimsnotreceived);\n        assert oldClaimsNotReceivedEntry == null : ""duplicate state names: "" + fsm.claimsnotreceived.getName();\n\n        fsm.claimspaymentreceived = new ClaimsPaymentReceived(fsm);\n        final State oldClaimsPaymentReceivedEntry = fsm.stateByName.put(fsm.claimspaymentreceived.getName(), fsm.claimspaymentreceived);\n        assert oldClaimsPaymentReceivedEntry == null : ""duplicate state names: "" + fsm.claimspaymentreceived.getName();\n\n        fsm.claimsreceivedbydeliveryteam = new ClaimsReceivedByDeliveryTeam(fsm);\n        final State oldClaimsReceivedByDeliveryTeamEntry = fsm.stateByName.put(fsm.claimsreceivedbydeliveryteam.getName(), fsm.claimsreceivedbydeliveryteam);\n        assert oldClaimsReceivedByDeliveryTeamEntry == null : ""duplicate state names: "" + fsm.claimsreceivedbydeliveryteam.getName();\n\n        fsm.claimspaymentcomplete = new ClaimsPaymentComplete(fsm);\n        final State oldClaimsPaymentCompleteEntry = fsm.stateByName.put(fsm.claimspaymentcomplete.getName(), fsm.claimspaymentcomplete);\n        assert oldClaimsPaymentCompleteEntry == null : ""duplicate state names: "" + fsm.claimspaymentcomplete.getName();\n\n        fsm.claimsstartstate = new ClaimsStartState(fsm);\n        final State oldClaimsStartStateEntry = fsm.stateByName.put(fsm.claimsstartstate.getName(), fsm.claimsstartstate);\n        assert oldClaimsStartStateEntry == null : ""duplicate state names: "" + fsm.claimsstartstate.getName();\n\n        fsm.claimsreceivedbymonitoringofficer = new ClaimsReceivedByMonitoringOfficer(fsm);\n        final State oldClaimsReceivedByMonitoringOfficerEntry = fsm.stateByName.put(fsm.claimsreceivedbymonitoringofficer.getName(), fsm.claimsreceivedbymonitoringofficer);\n        assert oldClaimsReceivedByMonitoringOfficerEntry == null : ""duplicate state names: "" + fsm.claimsreceivedbymonitoringofficer.getName();\n\n\n        //\n        // Initialise transitions\n        //\n        fsm.claimspaymentrejected.initialise();\n        fsm.claimsreadyforpayment.initialise();\n        fsm.claimsreceivedbyheadofdelivery.initialise();\n        fsm.claimsnotreceived.initialise();\n        fsm.claimspaymentreceived.initialise();\n        fsm.claimsreceivedbydeliveryteam.initialise();\n        fsm.claimspaymentcomplete.initialise();\n        fsm.claimsstartstate.initialise();\n        fsm.claimsreceivedbymonitoringofficer.initialise();\n        return fsm;\n    }\n\n    /**\n     * @return the current state\n     */\n    public State getCurrentState()\n    {\n        return this.currentState;\n    }\n    \n    /**\n     * @param goal the target state\n     * @return a TransitionPaths object from the current state to the given goal state\n     */\n    public TransitionPaths getPaths(final State goal)\n    {\n        return getCurrentState().getPaths(goal);\n    }\n\n    /**\n     * @param goal\n     *            the target state\n     * @return a TransitionPaths object from the current state to the given goal state\n     */\n    public TransitionPaths getSuccessfulPaths(final State goal)\n    {\n        final TransitionPaths allPaths = getCurrentState().getPaths(goal);\n        final TransitionPaths successfulPaths = new TransitionPaths();\n        if (allPaths != null)\n        {\n            for (final TransitionPath path : allPaths)\n            {\n                final TransitionPathResult result = executePathDryRun(path);\n                if (result != null && result.isSuccess())\n                {\n                    successfulPaths.add(path);\n                }\n            }\n        }\n        return successfulPaths;\n    }\n\n    /**\n     * @param path\n     *            the path to execute w/o affecting the current state. All registered listeners however will be notified.\n     * @return the result\n     */\n    public final TransitionPathResult executePathDryRun(final TransitionPath path)\n    {\n        final State beforeState = getCurrentState();\n        TransitionPathResult result;\n        try\n        {\n            result = path.execute();\n        }\n        finally\n        {\n            setCurrentState(beforeState);\n        }\n        return result;\n    }\n\n    /**\n     * @param path\n     *            the path to execute\n     * @return the result\n     */\n    public final TransitionPathResult executePath(final TransitionPath path)\n    {\n        return path.execute();\n    }\n\n    /**\n     * @param the given state name\n     * @return the result\n     */\n    public TransitionPathResult executeToState(final String name)\n    {   \n        final State state = getStateForName(name);\n        if (state == null)\n        {\n            throw new IllegalArgumentException(String.format(""No state exists with the name \'%s\'"", name));\n        }\n        return executeToState(state);\n    }\n\n    /**\n     * @param the given state name\n     * @return the result\n     */\n    public TransitionPathResult executeToStateDryRun(final String name)\n    {   \n        final State state = getStateForName(name);\n        if (state == null)\n        {\n            throw new IllegalArgumentException(String.format(""No state exists with the name \'%s\'"", name));\n        }\n        return executeToStateDryRun(state);\n    }\n    \n    /**\n     * After calling, the state will be reset its current state see {@link #executeToState(State)}\n     * \n     * @param to\n     *            the goal state\n     * @return the result of executing to the given state via the shorted available path\n     */\n    public TransitionPathResult executeToStateDryRun(final State to)\n    {\n        final State beforeState = getCurrentState();\n        TransitionPathResult result;\n        try\n        {\n            result = executeToState(to);\n        }\n        finally\n        {\n            setCurrentState(beforeState);\n        }\n        return result;\n    }\n\n\n    /**\n     * jump to the given state via the shortest \'path\'.\n     * \n     * @param to\n     *            the goal state\n     * @return the result of trying to move to the given state via the shortest available path, or null if no path was found. If the state machine was already in the given state it returns false. If the state\n     *         machine has now moved into the given state it returns true.\n     */\n    public TransitionPathResult executeToState(final State to)\n    {\n        if (to == getCurrentState())\n        {\n            return TransitionPathResult.fail(TransitionGuard.Reasons.ALREADY_IN_TARGET_STATE);\n        }\n\n        final TransitionPath path = getShortestSuccessfulPath(to);\n        \n        if (path != null)\n        {\n            return path.execute();\n        }\n\n        return TransitionPathResult.fail(TransitionGuard.Reasons.TARGET_STATE_UNREACHABLE);\n    }\n\n    /**\n     * @param to\n     *            the target (goal) state\n     * @return the first path available which can transition to the given state\n     */\n    public TransitionPath getShortestSuccessfulPath(final State to)\n    {\n        final State beforeState = getCurrentState();\n        TransitionPath path;\n        try\n        {\n            path = getShortestSuccessfulPathInternal(to);\n        }\n        finally\n        {\n            setCurrentState(beforeState);\n        }\n\n        return path;\n    }\n\n    private TransitionPath getShortestSuccessfulPathInternal(final State to)\n    {\n        final TransitionPaths paths = getPaths(to);\n        boolean success = false;\n        final State beforeState = getCurrentState();\n        for (final TransitionPath path : paths)\n        {\n            StateLog.debug(""trying "" + path);\n            success = executeToStateInternal(path, to);\n            if (success)\n            {\n                return path;\n            }\n            setCurrentState(beforeState);\n        }\n        return null;\n    }\n\n    /**\n     * jump to the given state via the path of transitions\n     * \n     * @return true if this call had any effect\n     */\n    private boolean executeToStateInternal(final TransitionPath path, final State to)\n    {\n        if (to == getCurrentState())\n        {\n            return false;\n        }\n        if (path == null)\n        {\n            throw new IllegalStateException(String.format(""can\'t get to \'%s\' from \'%s\'"", getCurrentStateName(), to.getName()));\n        }\n        path.execute();\n        return to == getCurrentState();\n    }\n\n    /**\n     * @return the name of the current state\n     */\n    public String getCurrentStateName()\n    {\n        return getCurrentState() == null ? null : getCurrentState().getName();\n    }\n\n    /**\n     * @return the start state\n     * @throws IllegalStateException\n     *             if the state machine was already started\n     */\n    public ClaimsStartState start()\n    {\n        if (getCurrentState() != null && getCurrentState().equals(this.claimsstartstate))\n        {\n            throw new IllegalStateException(""already started"");\n        }\n        setCurrentState(this.claimsstartstate);\n        return this.claimsstartstate;\n    }\n\n    /**\n     * @return the ClaimsPaymentRejected state\n     */\n    public ClaimsPaymentRejected paymentRejected()\n    {\n        return this.claimspaymentrejected;\n    }    \n    /**\n     * @return the ClaimsReadyForPayment state\n     */\n    public ClaimsReadyForPayment readyForPayment()\n    {\n        return this.claimsreadyforpayment;\n    }    \n    /**\n     * @return the ClaimsReceivedByHeadOfDelivery state\n     */\n    public ClaimsReceivedByHeadOfDelivery receivedByHeadOfDelivery()\n    {\n        return this.claimsreceivedbyheadofdelivery;\n    }    \n    /**\n     * @return the ClaimsNotReceived state\n     */\n    public ClaimsNotReceived notReceived()\n    {\n        return this.claimsnotreceived;\n    }    \n    /**\n     * @return the ClaimsPaymentReceived state\n     */\n    public ClaimsPaymentReceived paymentReceived()\n    {\n        return this.claimspaymentreceived;\n    }    \n    /**\n     * @return the ClaimsReceivedByDeliveryTeam state\n     */\n    public ClaimsReceivedByDeliveryTeam receivedByDeliveryTeam()\n    {\n        return this.claimsreceivedbydeliveryteam;\n    }    \n    /**\n     * @return the ClaimsPaymentComplete state\n     */\n    public ClaimsPaymentComplete paymentComplete()\n    {\n        return this.claimspaymentcomplete;\n    }    \n    /**\n     * @return the ClaimsStartState state\n     */\n    public ClaimsStartState startState()\n    {\n        return this.claimsstartstate;\n    }    \n    /**\n     * @return the ClaimsReceivedByMonitoringOfficer state\n     */\n    public ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer()\n    {\n        return this.claimsreceivedbymonitoringofficer;\n    }    \n\n\n    /**\n     * @return a collection of all the transitions across all states\n     */\n    public Collection<Transition> getTransitions()\n    {\n        final Collection<Transition> states = new LinkedList<Transition>();\n        for (final AbstractClaimsState state : this.stateByName.values())\n        {\n            states.addAll(state.getTransitions());\n        }\n        return states;\n    }\n\n    /**\n     * @return a collection of all the names for all the transitions across all states\n     */\n    public Collection<String> getTransitionNames()\n    {\n        final Collection<String> names = new LinkedList<String>();\n        for (final AbstractClaimsState state : this.stateByName.values())\n        {\n            names.addAll(state.getTransitionNames());\n        }\n        return names;\n    }\n\n    /**\n     * @return a collection of all states for this state machine\n     */\n    public Collection<State> getStates()\n    {\n        final Collection<State> states = new LinkedList<State>();\n        for (final AbstractClaimsState state : this.stateByName.values())\n        {\n            states.add(state);\n        }\n        return states;\n    }\n\n\n    /**\n     * @return a collection of all the names of all the states for this state machine\n     */\n    public Collection<String> getStateNames()\n    {\n        return this.stateByName.keySet();\n    }\n    \n    /**\n     * @param name the name of the state\n     * @return the state for the given name\n     */\n    public State getStateForName(final String name)\n    {\n        if (name == null)\n        {\n            throw new NullPointerException(""Invalid argument: null state name"");\n        }\n        return this.stateByName.get(name);\n    }\n\n    /**\n     * @param name\n     *            the name of the transition\n     * @return the transition for the given name\n     */\n    public Transition getTransitionForName(final String name)\n    {\n        for (final AbstractClaimsState state : this.stateByName.values())\n        {\n            final Transition transition = state.getTransitionForName(name);\n            if (transition != null)\n            {\n                return transition;\n            }\n        }\n        return null;\n    }\n    \n    final void setCurrentState(State newState)\n    {\n        this.currentState = newState;\n    }\n\n\n    /**\n     * @param listeners\n     */\n    public void registerListeners(final StateListener... listeners)\n    {\n        for (final StateListener listener : listeners)\n        {\n            registerListener(listener);\n        }\n    }\n\n    /**\n     * register and return the given listener\n     * @param listener the registered listener\n     * @return the registered listener (for chaining)\n     */\n    public <T extends StateListener> T registerListener(final T listener)\n    {\n        final boolean added = this.notifier.registerListener(listener);\n        assert added;\n        return listener;\n    }\n\n    /**\n     * unregister a listener\n     * @return true if the listener was successfully unregistered\n     */\n    public boolean unregisterListener(final StateListener listener)\n    {\n        return this.notifier.unregisterListener(listener);\n    }\n\n    final TransitionGuard onBeforeTransition(final Transition transition)\n    {\n        return this.notifier.onBeforeTransition(transition);\n    }\n\n    final TransitionGuard onAfterTransition(final Transition transition)\n    {\n        return this.notifier.onAfterTransition(transition);\n    }\n\n    /**\n     * drops your entire database.\n     * Either that or just represents the state machine as a string. \n     * Take your chances.\n     */\n    @Override\n    public String toString()\n    {\n        final String newLine = String.format(""%n"");\n        final StringBuilder builder = new StringBuilder(""ClaimsStateMachine"").append(newLine);\n        builder.append(""\\t"").append(this.notifier).append(newLine);\n        builder.append(""Current State:"");\n        builder.append(this.currentState).append(newLine);\n        builder.append(this.claimspaymentrejected).append(newLine);\n        builder.append(this.claimsreadyforpayment).append(newLine);\n        builder.append(this.claimsreceivedbyheadofdelivery).append(newLine);\n        builder.append(this.claimsnotreceived).append(newLine);\n        builder.append(this.claimspaymentreceived).append(newLine);\n        builder.append(this.claimsreceivedbydeliveryteam).append(newLine);\n        builder.append(this.claimspaymentcomplete).append(newLine);\n        builder.append(this.claimsstartstate).append(newLine);\n        builder.append(this.claimsreceivedbymonitoringofficer).append(newLine);\n        return builder.toString();\n    }\n}\n')",[254348]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\n/**\n * represents the state in a state machine\n */\npublic interface State extends NamedObject\n{\n    /**\n     * Return a unique name for this state.\n     * \n     * A state may need to be persisted, a common way to do this is \n     * to persist an enumeration of state values.\n     *   \n     * @return the unique name of this state\n     */\n    @Override\n    public String getName();\n    \n    /**\n     * allow callbacks to register their interest\n     * @param listener the listener to register\n     * @return true if the listener was registered successfully\n     */\n    <T extends StateListener> T registerListener(final T listener);\n\n    /**\n     * allow callbacks (listeners) to unregister their interest\n     * @param listener the listener to unregister\n     * @return true if the listener was unregistered successfully\n     */\n    boolean unregisterListener(final StateListener listener);\n    \n    /**\n     * @return an object representing all paths to the given state from this state\n     */\n    TransitionPaths getPaths(final State to);\n}\n')",[254740]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport java.util.Collection;\n\n/**\n * Transition represents a transition between two states \n */\npublic interface Transition extends NamedObject\n{\n    /**\n     * General failure reasons for transitions\n     */\n    enum Reasons\n    {\n        /** \n         * The current state of the state machine does not match the source state of the transition\n         */\n        INVALID_SOURCE_STATE;\n    }\n\n    /** \n     * execute the transition\n     * @return the new state\n     */\n    Collection<Enum<?>> execute();\n     \n    /**\n     * @return the source state\n     */\n    State getSource();\n     \n    /**\n     * @return the target state\n     */\n    State getTarget();\n\n    /**\n     * @param listener\n     * @return the registered listener\n     */\n    <T extends TransitionListener> T registerListener(final T listener);\n\n    /**\n     * @param listener\n     * @return true if the listener was removed successfully\n     */\n    boolean unregisterListener(final TransitionListener listener);\n}\n')",[262071]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_rejectToMo(aaron.test.test.ClaimsReceivedByDeliveryTeamTest)')","[15499, 15530, 15561, 18103, 18134, 18165, 27045, 27069, 27093, 39865, 39895, 39925, 57960, 57995, 58030, 60900, 60935, 60970, 71218, 71246, 71274, 81857, 81885, 81913, 98886, 98919, 98952, 101658, 101691, 101724, 111288, 111314, 111340, 122848, 122880, 122912, 142009, 142046, 142083, 145117, 145154, 145191, 156123, 156153, 156183, 169064, 169099, 169134, 189824, 189864, 189904, 193184, 193224, 193264, 205222, 205255, 205288, 218830, 218867, 218904, 240656, 240698, 240740, 244184, 244226, 244268, 303411, 303451, 303491, 304735, 304777, 304819]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_executeToClaimsReceivedByDeliveryTeam(aaron.test.test.ClaimsReceivedByDeliveryTeamTest)')","[15251, 15282, 15313, 17855, 17886, 17917, 26853, 26877, 26901, 39625, 39655, 39685, 57680, 57715, 57750, 60620, 60655, 60690, 70994, 71022, 71050, 81633, 81661, 81689, 98622, 98655, 98688, 101394, 101427, 101460, 111080, 111106, 111132, 122592, 122624, 122656, 141713, 141750, 141787, 144821, 144858, 144895, 155883, 155913, 155943, 168784, 168819, 168854, 189504, 189544, 189584, 192864, 192904, 192944, 204958, 204991, 205024, 218534, 218571, 218608, 240320, 240362, 240404, 243848, 243890, 243932, 303091, 303131, 303171, 304399, 304441, 304483]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_generateFile(com.porpoise.fsm.generator.StateMachineGeneratorTest)')","[569, 4308, 4928, 22125, 29132, 32619, 32882, 45325, 46025, 65478, 75101, 75346, 86973, 87633, 105958, 115112, 115393, 128652, 129392, 149973, 160593, 160901, 175384, 176184, 198457, 209869, 210195, 225494, 226334, 251808, 252130]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\npublic interface NamedObject\n{\n    /**\n     * @return a name for the object\n     */\n    public String getName();\n}\n')",[277789]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsRejectToParticipant extends AbstractTransition<ClaimsReceivedByMonitoringOfficer, ClaimsNotReceived>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""reject to participant"";\n\n    TransitionClaimsRejectToParticipant(final ClaimsReceivedByMonitoringOfficer from, final ClaimsNotReceived to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[269276]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\binterface (\\w+).*', 'package aaron.test;\n\n/**\n * if you use google collections, refactor to use that instead \n */\npublic enum StateLog\n{\n    ;// uninstantiable\n\n    public static String error(final String format, final Object... args)\n    {\n        final String log = ""_error:"" + String.format(format, args);\n        System.out.println(log);\n        return log;\n    }\n\n    public static String info(final String format, final Object... args)\n    {\n        final String log = ""_info:"" + String.format(format, args);\n        System.out.println(log);\n        return log;\n    }\n\n    public static String debug(final String format, final Object... args)\n    {\n        final String log = ""_debug:"" + String.format(format, args);\n        System.out.println(log);\n        return log;\n    }\n    \n    public static String trace(final String format, final Object... args)\n    {\n        return ""_trace:"" + String.format(format, args);\n    }\n}\n')",[254862]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\n/**\n *\n */\npublic class TransitionClaimsSubmitToHeadOfDelivery extends AbstractTransition<ClaimsNotReceived, ClaimsReceivedByHeadOfDelivery>\n{\n    /**\n     * the transition name\n     */\n    public final static String NAME = ""submit to head of delivery"";\n\n    TransitionClaimsSubmitToHeadOfDelivery(final ClaimsNotReceived from, final ClaimsReceivedByHeadOfDelivery to) \n    {\n        super(from, to);\n    }\n    \n    /**\n     * @return the name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[266336]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_removeTransition(com.porpoise.fsm.model.StateTest)')","[3099, 3130, 3161, 4215, 4246, 4277, 21957, 21981, 22005, 32135, 32165, 32195, 43960, 43995, 44030, 45220, 45255, 45290, 65282, 65310, 65338, 74651, 74679, 74707, 85686, 85719, 85752, 86874, 86907, 86940, 105776, 105802, 105828, 114594, 114626, 114658, 127209, 127246, 127283, 128541, 128578, 128615, 149763, 149793, 149823, 160024, 160059, 160094, 173824, 173864, 173904, 175264, 175304, 175344, 198226, 198259, 198292, 209266, 209303, 209340, 223856, 223898, 223940, 225368, 225410, 225452, 250930, 250970, 251010, 251262, 251304, 251346]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class TestStartState extends AbstractTestState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""start-state"";\n\n    \n    /**\n     * @param fsm\n     */\n    TestStartState(final TestStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        return allTransitions;    \n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[286847]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsReceivedByMonitoringOfficer\n */\npublic class ClaimsReceivedByMonitoringOfficerTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the \'ClaimsReceivedByMonitoringOfficer\' state\n     */\n    @Test\n    public void test_executeToClaimsReceivedByMonitoringOfficer()\n    {\n        Assert.assertNotNull(moveToClaimsReceivedByMonitoringOfficer());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for \'receivedByMonitoringOfficer\' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.receivedByMonitoringOfficer().getName();\n        Assert.assertEquals(fsm.receivedByMonitoringOfficer(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the receivedByMonitoringOfficer state\n     */\n    final ClaimsReceivedByMonitoringOfficer moveToClaimsReceivedByMonitoringOfficer()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = fsm.receivedByMonitoringOfficer();\n\n        // call the method under test\n        fsm.executeToState(receivedByMonitoringOfficer);\n\n        Assert.assertSame(receivedByMonitoringOfficer, fsm.getCurrentState());\n        Assert.assertEquals(receivedByMonitoringOfficer.getName(), fsm.getCurrentStateName());\n        \n        return receivedByMonitoringOfficer;\n    }\n\n    \n    @Test\n    public void test_getPathBetweenClaimsReceivedByMonitoringOfficerAndClaimsReceivedByDeliveryTeam()\n    {\n\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'receivedByMonitoringOfficer\'"", receivedByMonitoringOfficer, fsm.getCurrentState());\n\n        final TransitionPaths paths = receivedByMonitoringOfficer.getPaths(fsm.receivedByDeliveryTeam());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        receivedByMonitoringOfficer.registerApproveForDeliveryTeamListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'receivedByMonitoringOfficer\'"", receivedByMonitoringOfficer, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.receivedByDeliveryTeam(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'approveForDeliveryTeam\' transition \n     */\n    @Test\n    public void test_approveForDeliveryTeam()\n    {\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        receivedByMonitoringOfficer.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        receivedByMonitoringOfficer.approveForDeliveryTeam();\n\n        //\n        // assert the current state is now ClaimsReceivedByDeliveryTeam\n        //\n        Assert.assertEquals(fsm.receivedByDeliveryTeam(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.receivedByDeliveryTeam().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsApproveForDeliveryTeam.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsApproveForDeliveryTeam.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(receivedByMonitoringOfficer.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReceivedByMonitoringOfficer\' can be moved into the ClaimsReceivedByDeliveryTeam state\n     */\n    @Test\n    public void test_moveToClaimsReceivedByDeliveryTeam()\n    {\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n        receivedByMonitoringOfficer.getPaths(fsm.receivedByDeliveryTeam());\n        \n    }\n    \n    @Test\n    public void test_getPathBetweenClaimsReceivedByMonitoringOfficerAndClaimsReceivedByHeadOfDelivery()\n    {\n\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'receivedByMonitoringOfficer\'"", receivedByMonitoringOfficer, fsm.getCurrentState());\n\n        final TransitionPaths paths = receivedByMonitoringOfficer.getPaths(fsm.receivedByHeadOfDelivery());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        receivedByMonitoringOfficer.registerApproveForHeadOfDeliveryListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'receivedByMonitoringOfficer\'"", receivedByMonitoringOfficer, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'approveForHeadOfDelivery\' transition \n     */\n    @Test\n    public void test_approveForHeadOfDelivery()\n    {\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        receivedByMonitoringOfficer.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        receivedByMonitoringOfficer.approveForHeadOfDelivery();\n\n        //\n        // assert the current state is now ClaimsReceivedByHeadOfDelivery\n        //\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsApproveForHeadOfDelivery.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsApproveForHeadOfDelivery.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(receivedByMonitoringOfficer.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReceivedByMonitoringOfficer\' can be moved into the ClaimsReceivedByHeadOfDelivery state\n     */\n    @Test\n    public void test_moveToClaimsReceivedByHeadOfDelivery()\n    {\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n        receivedByMonitoringOfficer.getPaths(fsm.receivedByHeadOfDelivery());\n        \n    }\n    \n    @Test\n    public void test_getPathBetweenClaimsReceivedByMonitoringOfficerAndClaimsNotReceived()\n    {\n\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'receivedByMonitoringOfficer\'"", receivedByMonitoringOfficer, fsm.getCurrentState());\n\n        final TransitionPaths paths = receivedByMonitoringOfficer.getPaths(fsm.notReceived());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        receivedByMonitoringOfficer.registerRejectToParticipantListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'receivedByMonitoringOfficer\'"", receivedByMonitoringOfficer, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.notReceived(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'rejectToParticipant\' transition \n     */\n    @Test\n    public void test_rejectToParticipant()\n    {\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        receivedByMonitoringOfficer.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        receivedByMonitoringOfficer.rejectToParticipant();\n\n        //\n        // assert the current state is now ClaimsNotReceived\n        //\n        Assert.assertEquals(fsm.notReceived(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.notReceived().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsRejectToParticipant.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsRejectToParticipant.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(receivedByMonitoringOfficer.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReceivedByMonitoringOfficer\' can be moved into the ClaimsNotReceived state\n     */\n    @Test\n    public void test_moveToClaimsNotReceived()\n    {\n        final ClaimsReceivedByMonitoringOfficer receivedByMonitoringOfficer = moveToClaimsReceivedByMonitoringOfficer();\n        final ClaimsStateMachine fsm = receivedByMonitoringOfficer.getStateMachine();\n        receivedByMonitoringOfficer.getPaths(fsm.notReceived());\n        \n    }\n}\n')",[275405]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_generate(com.porpoise.fsm.generator.StateMachineGeneratorTest)')","[4432, 5052, 22221, 29173, 32739, 45465, 46165, 65590, 75213, 87105, 87765, 106062, 115240, 128800, 129540, 150093, 160733, 175544, 176344, 198589, 210017, 225662, 226502, 251968, 252298]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_moveToClaimsReadyForPayment(aaron.test.test.ClaimsPaymentRejectedTest)')","[20056, 28461, 30778, 42183, 63105, 72870, 84017, 103737, 112822, 125324, 147448, 157893, 171777, 195704, 207169, 221701, 246830, 309339, 310149]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsReceivedByHeadOfDelivery\n */\npublic class ClaimsReceivedByHeadOfDeliveryTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the \'ClaimsReceivedByHeadOfDelivery\' state\n     */\n    @Test\n    public void test_executeToClaimsReceivedByHeadOfDelivery()\n    {\n        Assert.assertNotNull(moveToClaimsReceivedByHeadOfDelivery());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for \'receivedByHeadOfDelivery\' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.receivedByHeadOfDelivery().getName();\n        Assert.assertEquals(fsm.receivedByHeadOfDelivery(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the receivedByHeadOfDelivery state\n     */\n    final ClaimsReceivedByHeadOfDelivery moveToClaimsReceivedByHeadOfDelivery()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsReceivedByHeadOfDelivery receivedByHeadOfDelivery = fsm.receivedByHeadOfDelivery();\n\n        // call the method under test\n        fsm.executeToState(receivedByHeadOfDelivery);\n\n        Assert.assertSame(receivedByHeadOfDelivery, fsm.getCurrentState());\n        Assert.assertEquals(receivedByHeadOfDelivery.getName(), fsm.getCurrentStateName());\n        \n        return receivedByHeadOfDelivery;\n    }\n\n    \n    @Test\n    public void test_getPathBetweenClaimsReceivedByHeadOfDeliveryAndClaimsReceivedByDeliveryTeam()\n    {\n\n        final ClaimsReceivedByHeadOfDelivery receivedByHeadOfDelivery = moveToClaimsReceivedByHeadOfDelivery();\n        final ClaimsStateMachine fsm = receivedByHeadOfDelivery.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'receivedByHeadOfDelivery\'"", receivedByHeadOfDelivery, fsm.getCurrentState());\n\n        final TransitionPaths paths = receivedByHeadOfDelivery.getPaths(fsm.receivedByDeliveryTeam());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        receivedByHeadOfDelivery.registerRejectToDeliveryTeamListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'receivedByHeadOfDelivery\'"", receivedByHeadOfDelivery, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.receivedByDeliveryTeam(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'rejectToDeliveryTeam\' transition \n     */\n    @Test\n    public void test_rejectToDeliveryTeam()\n    {\n        final ClaimsReceivedByHeadOfDelivery receivedByHeadOfDelivery = moveToClaimsReceivedByHeadOfDelivery();\n        final ClaimsStateMachine fsm = receivedByHeadOfDelivery.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        receivedByHeadOfDelivery.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        receivedByHeadOfDelivery.rejectToDeliveryTeam();\n\n        //\n        // assert the current state is now ClaimsReceivedByDeliveryTeam\n        //\n        Assert.assertEquals(fsm.receivedByDeliveryTeam(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.receivedByDeliveryTeam().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsRejectToDeliveryTeam.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsRejectToDeliveryTeam.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(receivedByHeadOfDelivery.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReceivedByHeadOfDelivery\' can be moved into the ClaimsReceivedByDeliveryTeam state\n     */\n    @Test\n    public void test_moveToClaimsReceivedByDeliveryTeam()\n    {\n        final ClaimsReceivedByHeadOfDelivery receivedByHeadOfDelivery = moveToClaimsReceivedByHeadOfDelivery();\n        final ClaimsStateMachine fsm = receivedByHeadOfDelivery.getStateMachine();\n        receivedByHeadOfDelivery.getPaths(fsm.receivedByDeliveryTeam());\n        \n    }\n    \n    @Test\n    public void test_getPathBetweenClaimsReceivedByHeadOfDeliveryAndClaimsReadyForPayment()\n    {\n\n        final ClaimsReceivedByHeadOfDelivery receivedByHeadOfDelivery = moveToClaimsReceivedByHeadOfDelivery();\n        final ClaimsStateMachine fsm = receivedByHeadOfDelivery.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'receivedByHeadOfDelivery\'"", receivedByHeadOfDelivery, fsm.getCurrentState());\n\n        final TransitionPaths paths = receivedByHeadOfDelivery.getPaths(fsm.readyForPayment());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        receivedByHeadOfDelivery.registerMarkAsReadyForPaymentListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'receivedByHeadOfDelivery\'"", receivedByHeadOfDelivery, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.readyForPayment(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'markAsReadyForPayment\' transition \n     */\n    @Test\n    public void test_markAsReadyForPayment()\n    {\n        final ClaimsReceivedByHeadOfDelivery receivedByHeadOfDelivery = moveToClaimsReceivedByHeadOfDelivery();\n        final ClaimsStateMachine fsm = receivedByHeadOfDelivery.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        receivedByHeadOfDelivery.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        receivedByHeadOfDelivery.markAsReadyForPayment();\n\n        //\n        // assert the current state is now ClaimsReadyForPayment\n        //\n        Assert.assertEquals(fsm.readyForPayment(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.readyForPayment().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsMarkAsReadyForPayment.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsMarkAsReadyForPayment.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(receivedByHeadOfDelivery.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReceivedByHeadOfDelivery\' can be moved into the ClaimsReadyForPayment state\n     */\n    @Test\n    public void test_moveToClaimsReadyForPayment()\n    {\n        final ClaimsReceivedByHeadOfDelivery receivedByHeadOfDelivery = moveToClaimsReceivedByHeadOfDelivery();\n        final ClaimsStateMachine fsm = receivedByHeadOfDelivery.getStateMachine();\n        receivedByHeadOfDelivery.getPaths(fsm.readyForPayment());\n        \n    }\n}\n')",[271203]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.HashSet;\n\n/**\n * A TransitionPath represents a chain of transitions from one state to another\n */\npublic final class TransitionPath implements Comparable<TransitionPath>\n{\n    private final List<PathEntry> path;\n    private final Set<String>     uniqueTransitionNames;\n\n    TransitionPath(final State startState)\n    {\n        this(Arrays.asList(new PathEntry[] { new PathEntry(startState) }));\n    }\n\n    private TransitionPath(final List<PathEntry> states)\n    {\n        this.path = new ArrayList<PathEntry>(states);\n        this.uniqueTransitionNames = new HashSet<String>();\n        for (final PathEntry pe : states)\n        {\n            if (pe.getTransition() != null)\n            {\n                this.uniqueTransitionNames.add(pe.getTransition().getName());\n            }\n        }\n    }\n\n    /**\n     * add a unique transition to the given target\n     * @param target\n     * @param trans\n     * @return true if this method invocation has altered the TransitionPath, false otherwise\n     */\n    boolean add(final State target, final Transition trans)\n    {\n        final PathEntry entry = new PathEntry(target, trans);\n        if (this.path.contains(entry))\n        {\n            return false;\n        }\n        this.uniqueTransitionNames.add(trans.getName());\n        return this.path.add(entry);\n    }\n\n    public TransitionPath clonePath()\n    {\n        return new TransitionPath(this.path);\n    }\n\n    @Override\n    public String toString()\n    {\n        final StringBuilder b = new StringBuilder(""path: "");\n        for (final PathEntry s : this.path)\n        {\n            b.append(s);\n        }\n        return b.toString();\n    }\n\n    @Override\n    public int hashCode()\n    {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((this.path == null) ? 0 : this.path.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(final Object obj)\n    {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        final TransitionPath other = (TransitionPath) obj;\n        if (this.path == null)\n        {\n            if (other.path != null)\n                return false;\n        }\n        else if (!this.path.equals(other.path))\n            return false;\n        return true;\n    }\n\n    /**\n     * execute this path on\'t state machine\n     * \n     * @return true if the path executed all transition successfully\n     */\n    final public TransitionPathResult execute()\n    {\n        for (final PathEntry entry : this.path)\n        {\n            final Collection<Enum<?>> reasons = entry.execute();\n            if (!reasons.isEmpty())\n            {\n                return TransitionPathResult.fail(entry, reasons);\n            }\n        }\n        return TransitionPathResult.success();\n    }\n\n    /**\n     * @return the length of this path\n     */\n    public int size()\n    {\n        return this.path.size();\n    }\n\n    /**\n     * @return the result of the comparison\n     */\n    @Override\n    public int compareTo(final TransitionPath o)\n    {\n        return Integer.valueOf(size()).compareTo(Integer.valueOf(o.size()));\n    }\n\n\n    /**\n     * @return true if the path contains the transition with the given name\n     */\n    public boolean containsTransition(final String name)\n    {\n        return this.uniqueTransitionNames.contains(name);\n    }\n}\n')",[259890]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getStateForName(aaron.test.test.ClaimsPaymentReceivedTest)')","[1856, 19188, 20552, 27885, 30612, 41326, 41949, 62125, 63665, 72198, 83218, 83799, 102813, 104265, 112198, 124409, 125074, 146412, 148040, 157173, 170775, 171503, 194584, 196344, 206377, 220641, 221411, 245654, 247502, 307445, 308247]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n *\n */\nabstract class AbstractTransition<SOURCE extends AbstractClaimsState, TARGET extends AbstractClaimsState> implements Transition\n{\n    private final SOURCE sourceState;\n    private final TARGET targetState;\n    \n    private Collection<TransitionListener> listeners;\n\n    AbstractTransition(final SOURCE from, final TARGET to)\n    {\n        if (from == null) \n        {\n            throw new NullPointerException(""source state cannot be null"");\n        }\n        if (to == null) \n        {\n            throw new NullPointerException(""target state cannot be null"");\n        }\n        if (from.getStateMachine() != to.getStateMachine())\n        {\n            throw new NullPointerException(""source and target states are for different state machines"");\n        }\n        this.sourceState = from;\n        this.targetState = to;\n        this.listeners = new CopyOnWriteArrayList<TransitionListener>();\n    }\n\n    public SOURCE getSource()\n    {\n        return this.sourceState;\n    }\n    \n    public TARGET getTarget()\n    {\n        return this.targetState;\n    }\n\n    /**\n     *  hook for subclasses\n     */\n    protected void executeInternal()\n    {\n    // no-op\n    }\n\n    /**\n     * Execute the transition, returning a collection of reasons why the transition could not execute should the transition fail.\n     * Should the transition succeed, an empty collection is returned.\n     * @return a collection of reasons why the transition could not execute should the transition fail\n     */\n    public final Collection<Enum<?>> execute()\n    {\n        if (getSource() != getStateMachine().getCurrentState())\n        {\n            StateLog.error(""Illegal transition \'%s\' called. Current state was expected to be \'%s\' but was \'%s\'"", getName(), getSource().getName(),\n                    getStateMachine().getCurrentStateName());\n            return Arrays.asList(new Enum<?>[] { Reasons.INVALID_SOURCE_STATE });\n        }\n\n        //\n        // process general listeners\n        //\n        final TransitionGuard generalBeforeResult = getStateMachine().onBeforeTransition(this);\n        if (generalBeforeResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop before transition. Reason=%s"", getName(), generalBeforeResult.getReason());\n            return generalBeforeResult.getReasons();\n        }\n\n        //\n        // process source handlers\n        //\n        final TransitionGuard specificBeforeResult = getSource().onExit(this);\n        if (specificBeforeResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop exiting the state. Reason=%s"", getName(), specificBeforeResult.getReason());\n            return specificBeforeResult.getReasons();\n        }\n\n        //\n        // perform any subclass processing\n        //\n        executeInternal();\n\n        //\n        // process specific target entrance handlers\n        //\n        final TransitionGuard specificAfterResult = getSource().onEnter(this);\n        if (specificAfterResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop entering state. Reason=%s"", getName(), specificAfterResult.getReason());\n            return specificAfterResult.getReasons();\n        }\n\n        //\n        // notify the direct transition listeners that the transition is taking place\n        //\n        final TransitionGuard transGuardResult = notifyListeners();\n        if (transGuardResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop by a transaction listener. Reason=%s"", getName(), transGuardResult.getReason());\n            return transGuardResult.getReasons();\n        }\n\n        //\n        // process general target entrance handlers\n        //\n        final TransitionGuard generalAfterResult = getStateMachine().onAfterTransition(this);\n        if (generalAfterResult.stop())\n        {\n            StateLog.debug(""transition \'%s\' asked to stop by a transaction listener. Reason=%s"", getName(), generalAfterResult.getReason());\n            return generalAfterResult.getReasons();\n        }\n\n        //\n        // success! Or is it? Anybody think we should stop?\n        //\n        final Collection<Enum<?>> reasons = TransitionGuard.filterReasons(generalBeforeResult,//\n                specificBeforeResult,//\n                specificAfterResult,//\n                transGuardResult,//\n                generalAfterResult);\n\n        if (reasons.isEmpty())\n        {\n            StateLog.debug(""transition \'%s\' proceeding to state \'%s\'"", getName(), getTarget().getName());\n            getStateMachine().setCurrentState(getTarget());\n        }\n        else\n        {\n            StateLog.debug(""transition \'%s\' returning without proceeding to \'%s\', staying in \'%s\' due to: %s"", getName(), getTarget()\n                    .getName(), getStateMachine().getCurrentState().getName(), reasons);\n        }\n\n        return reasons;\n    }\n\n    ClaimsStateMachine getStateMachine()\n    {\n        return getSource().getStateMachine();\n    }\n    \n    private TransitionGuard notifyListeners()\n    {\n        TransitionGuard result = TransitionGuard.ok(); \n        for (final TransitionListener listener : this.listeners)\n        {\n            final TransitionGuard listenerResult = listener.onTransition(this);\n            if (listenerResult.stop())\n            {\n                return listenerResult;\n            }\n            else if (!listenerResult.continueProcessing())\n            {\n                result = listenerResult; \n            }\n        }\n        return result;\n    }\n    \n    /**\n     * @param listener the listener to add\n     * @return true if the listener was added successfully\n     */\n    @Override\n    public <T extends TransitionListener> T registerListener(final T listener)\n    {\n        if (listener == null)\n        {\n            return null;\n        }\n        final boolean success =  this.listeners.add(listener);\n        assert success;\n        return listener;\n    }\n\n    /**\n     * @param listener the listener to remove\n     * @reutrn true if the listener was removed successfully\n     */\n    @Override\n    public boolean unregisterListener(final TransitionListener listener)\n    {\n        if (listener == null)\n        {\n            return false;\n        }\n        return this.listeners.remove(listener);\n    }\n    \n    /**\n     * @return the string value for this transition\n     */\n    @Override\n    public String toString()\n    {\n        return String.format(""%s [%d]: %s --> %s"", getName(), Integer.valueOf(this.listeners.size()), getSource().getName(), getTarget()\n                .getName());\n    }\n}\n')",[262847]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_getPathBetweenClaimsNotReceivedAndClaimsReceivedByDeliveryTeam(aaron.test.test.ClaimsNotReceivedTest)')","[6788, 9392, 23373, 29505, 34727, 48125, 51065, 66934, 77065, 89613, 92385, 107310, 117364, 131612, 134720, 151533, 163061, 178584, 181944, 200173, 212481, 228854, 232382, 290531, 292333]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_executeToClaimsPaymentReceived(aaron.test.test.ClaimsPaymentReceivedTest)')","[19343, 19374, 19405, 20707, 20738, 20769, 28005, 28029, 28053, 41476, 41506, 41536, 62300, 62335, 62370, 63840, 63875, 63910, 72338, 72366, 72394, 83358, 83386, 83414, 102978, 103011, 103044, 104430, 104463, 104496, 112328, 112354, 112380, 124569, 124601, 124633, 146597, 146634, 146671, 148225, 148262, 148299, 157323, 157353, 157383, 170950, 170985, 171020, 194784, 194824, 194864, 196544, 196584, 196624, 206542, 206575, 206608, 220826, 220863, 220900, 245864, 245906, 245948, 247712, 247754, 247796, 307645, 307685, 307725, 308457, 308499, 308541]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package aaron.test;\n\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\n\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Set;\nimport java.util.HashSet;\n\n/**\n * A TransitionPath represents a chain of transitions from one state to another\n */\nenum PathFilters\n{\n    ; // uninstantiable\n\n    /**\n     * @return a TransitionPath filter which returns \'true\' when a path contains a transition\n     * with the given name\n     */\n    public static final Predicate<TransitionPath> byName(final String name)\n    {\n        return new Predicate<TransitionPath>() {\n            public boolean apply(final TransitionPath path) {\n                return path.containsTransition(name);\n            }\n        };\n    }\n\n    /**\n     * @return a TransitionPath filter which returns \'true\' when a path contains a transition with one of the given names\n     */\n     @SuppressWarnings(""unchecked"")\n    public static final Predicate<TransitionPath> byNames(final String ... names)\n    {\n        final Set<String> uniqueNames = new HashSet<String>(Arrays.asList(names));\n        final Collection<Predicate<TransitionPath>> filters = new ArrayList<Predicate<TransitionPath>>(uniqueNames.size());\n        for (final String name : uniqueNames)\n        {\n            if (name != null)\n            {\n                filters.add(byName(name));\n            }\n        }\n        Predicate<TransitionPath>[] filtersArray = new Predicate[filters.size()];\n        filtersArray = filters.toArray(filtersArray);\n        return Predicates.or(filtersArray);\n    }\n}\n')",[258937]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsNotReceived extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""Not Received"";\n\n    private TransitionClaimsSubmitToMonitoringOfficer submitToMonitoringOfficer; \n    private TransitionClaimsSubmitToDeliveryTeam submitToDeliveryTeam; \n    private TransitionClaimsSubmitToHeadOfDelivery submitToHeadOfDelivery; \n    \n    /**\n     * @param fsm\n     */\n    ClaimsNotReceived(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        // Transition submit to monitoring officer\n        this.submitToMonitoringOfficer = new TransitionClaimsSubmitToMonitoringOfficer(this, getStateMachine().receivedByMonitoringOfficer());\n        allTransitions.add(this.submitToMonitoringOfficer); \n\n        // Transition submit to delivery team\n        this.submitToDeliveryTeam = new TransitionClaimsSubmitToDeliveryTeam(this, getStateMachine().receivedByDeliveryTeam());\n        allTransitions.add(this.submitToDeliveryTeam); \n\n        // Transition submit to head of delivery\n        this.submitToHeadOfDelivery = new TransitionClaimsSubmitToHeadOfDelivery(this, getStateMachine().receivedByHeadOfDelivery());\n        allTransitions.add(this.submitToHeadOfDelivery); \n\n        return allTransitions;    \n    }\n    \n    /**\n     * execute the submit to monitoring officer transition\n     * @return true if the transition was successful\n     */\n    public boolean submitToMonitoringOfficer() {\n        this.submitToMonitoringOfficer.execute();\n        return this.submitToMonitoringOfficer.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerSubmitToMonitoringOfficerListener(final T listener)\n    {\n        return this.submitToMonitoringOfficer.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterSubmitToMonitoringOfficerListener(final TransitionListener listener)\n    {\n        return this.submitToMonitoringOfficer.unregisterListener(listener);\n    }\n    \n    /**\n     * execute the submit to delivery team transition\n     * @return true if the transition was successful\n     */\n    public boolean submitToDeliveryTeam() {\n        this.submitToDeliveryTeam.execute();\n        return this.submitToDeliveryTeam.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerSubmitToDeliveryTeamListener(final T listener)\n    {\n        return this.submitToDeliveryTeam.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterSubmitToDeliveryTeamListener(final TransitionListener listener)\n    {\n        return this.submitToDeliveryTeam.unregisterListener(listener);\n    }\n    \n    /**\n     * execute the submit to head of delivery transition\n     * @return true if the transition was successful\n     */\n    public boolean submitToHeadOfDelivery() {\n        this.submitToHeadOfDelivery.execute();\n        return this.submitToHeadOfDelivery.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerSubmitToHeadOfDeliveryListener(final T listener)\n    {\n        return this.submitToHeadOfDelivery.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterSubmitToHeadOfDeliveryListener(final TransitionListener listener)\n    {\n        return this.submitToHeadOfDelivery.unregisterListener(listener);\n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[265497]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n\n/**\n *\n */\npublic class ClaimsReceivedByDeliveryTeam extends AbstractClaimsState \n{\n    /**\n     * the state name\n     */\n    public static final String NAME = ""Received By Delivery Team"";\n\n    private TransitionClaimsRejectToMo rejectToMo; \n    private TransitionClaimsApproveForHod approveForHod; \n    \n    /**\n     * @param fsm\n     */\n    ClaimsReceivedByDeliveryTeam(final ClaimsStateMachine fsm)\n    {\n        super(fsm);\n    }\n\n    @Override\n    Collection<Transition> initialiseTransitions()\n    {\n         final List<Transition> allTransitions = new ArrayList<Transition>();\n\n        // Transition reject to mo\n        this.rejectToMo = new TransitionClaimsRejectToMo(this, getStateMachine().receivedByMonitoringOfficer());\n        allTransitions.add(this.rejectToMo); \n\n        // Transition approve for hod\n        this.approveForHod = new TransitionClaimsApproveForHod(this, getStateMachine().receivedByHeadOfDelivery());\n        allTransitions.add(this.approveForHod); \n\n        return allTransitions;    \n    }\n    \n    /**\n     * execute the reject to mo transition\n     * @return true if the transition was successful\n     */\n    public boolean rejectToMo() {\n        this.rejectToMo.execute();\n        return this.rejectToMo.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerRejectToMoListener(final T listener)\n    {\n        return this.rejectToMo.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterRejectToMoListener(final TransitionListener listener)\n    {\n        return this.rejectToMo.unregisterListener(listener);\n    }\n    \n    /**\n     * execute the approve for hod transition\n     * @return true if the transition was successful\n     */\n    public boolean approveForHod() {\n        this.approveForHod.execute();\n        return this.approveForHod.getTarget() == getStateMachine().getCurrentState();\n    }\n\n\n    /**\n     * @param <T>\n     *            the listener type\n     * @param listener\n     *            the transition listener\n     * @return the registered listener\n     */\n    public <T extends TransitionListener> T registerApproveForHodListener(final T listener)\n    {\n        return this.approveForHod.registerListener(listener);\n    }\n\n    /**\n     * @param listener\n     *            the transition listener to unregister\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterApproveForHodListener(final TransitionListener listener)\n    {\n        return this.approveForHod.unregisterListener(listener);\n    }\n    \n\n    /**\n     * @return the state name\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n}\n')",[267248]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'aaron.test.test.ClaimsPaymentCompleteTest')","[293323, 293346, 293370, 293393]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\n\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Set;\nimport java.util.HashSet;\n\n/**\n * A TransitionPath represents a chain of transitions from one state to another\n */\nenum PathFilters\n{\n    ; // uninstantiable\n\n    /**\n     * @return a TransitionPath filter which returns \'true\' when a path contains a transition\n     * with the given name\n     */\n    public static final Predicate<TransitionPath> byName(final String name)\n    {\n        return new Predicate<TransitionPath>() {\n            public boolean apply(final TransitionPath path) {\n                return path.containsTransition(name);\n            }\n        };\n    }\n\n    /**\n     * @return a TransitionPath filter which returns \'true\' when a path contains a transition with one of the given names\n     */\n     @SuppressWarnings(""unchecked"")\n    public static final Predicate<TransitionPath> byNames(final String ... names)\n    {\n        final Set<String> uniqueNames = new HashSet<String>(Arrays.asList(names));\n        final Collection<Predicate<TransitionPath>> filters = new ArrayList<Predicate<TransitionPath>>(uniqueNames.size());\n        for (final String name : uniqueNames)\n        {\n            if (name != null)\n            {\n                filters.add(byName(name));\n            }\n        }\n        Predicate<TransitionPath>[] filtersArray = new Predicate[filters.size()];\n        filtersArray = filters.toArray(filtersArray);\n        return Predicates.or(filtersArray);\n    }\n}\n')",[282238]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', ""package p.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport p.*;\nimport p.TransitionGuard.Reasons;\nimport p.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for TestStartState\n */\npublic class TestStartStateTest extends AbstractTestTest\n{\n    /**\n     * test the state machine can move into the 'TestStartState' state\n     */\n    @Test\n    public void test_executeToTestStartState()\n    {\n        Assert.assertNotNull(moveToTestStartState());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for 'startState' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final TestStateMachine fsm = newStateMachine();\n        final String name =fsm.startState().getName();\n        Assert.assertEquals(fsm.startState(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the startState state\n     */\n    final TestStartState moveToTestStartState()\n    {\n        final TestStateMachine fsm = newStateMachine();\n        final TestStartState startState = fsm.startState();\n\n        // call the method under test\n        fsm.executeToState(startState);\n\n        Assert.assertSame(startState, fsm.getCurrentState());\n        Assert.assertEquals(startState.getName(), fsm.getCurrentStateName());\n        \n        return startState;\n    }\n\n}\n"")",[287291]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_executeToClaimsStartState(aaron.test.test.ClaimsStartStateTest)')","[17080, 18816, 27501, 30508, 40572, 59745, 61705, 71750, 82516, 100569, 102417, 111782, 123603, 143896, 145968, 156693, 169891, 191864, 194104, 205849, 219705, 242798, 245150, 305609, 306427]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'com.porpoise.fsm.model.StartStateTest')","[56, 77, 30986, 73445, 73580, 113367, 158510, 158680, 207844]"
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_asPropertyName(com.porpoise.fsm.generator.context.ContextTest)')","[5300, 6044, 22605, 29297, 33493, 46445, 47285, 66038, 75915, 88029, 88821, 106478, 116046, 129836, 130724, 150573, 161617, 176664, 177624, 199117, 210953, 226838, 227846, 288391, 288721]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package aaron.test.test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport aaron.test.*;\nimport aaron.test.TransitionGuard.Reasons;\nimport aaron.test.StateListeners.RecordingListener;\nimport org.junit.*;\n\nimport com.google.common.base.Predicate;\n\n/**\n * tests for ClaimsReadyForPayment\n */\npublic class ClaimsReadyForPaymentTest extends AbstractClaimsTest\n{\n    /**\n     * test the state machine can move into the \'ClaimsReadyForPayment\' state\n     */\n    @Test\n    public void test_executeToClaimsReadyForPayment()\n    {\n        Assert.assertNotNull(moveToClaimsReadyForPayment());\n    }\n\n    /**\n     * test the state machine retrieves the correct when given the state name for \'readyForPayment\' \n     */\n    @Test\n    public void test_getStateForName()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final String name =fsm.readyForPayment().getName();\n        Assert.assertEquals(fsm.readyForPayment(), fsm.getStateForName(name));\n    }\n\n    /**\n     * @return a state machine instance in the readyForPayment state\n     */\n    final ClaimsReadyForPayment moveToClaimsReadyForPayment()\n    {\n        final ClaimsStateMachine fsm = newStateMachine();\n        final ClaimsReadyForPayment readyForPayment = fsm.readyForPayment();\n\n        // call the method under test\n        fsm.executeToState(readyForPayment);\n\n        Assert.assertSame(readyForPayment, fsm.getCurrentState());\n        Assert.assertEquals(readyForPayment.getName(), fsm.getCurrentStateName());\n        \n        return readyForPayment;\n    }\n\n    \n    @Test\n    public void test_getPathBetweenClaimsReadyForPaymentAndClaimsPaymentRejected()\n    {\n\n        final ClaimsReadyForPayment readyForPayment = moveToClaimsReadyForPayment();\n        final ClaimsStateMachine fsm = readyForPayment.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'readyForPayment\'"", readyForPayment, fsm.getCurrentState());\n\n        final TransitionPaths paths = readyForPayment.getPaths(fsm.paymentRejected());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        readyForPayment.registerRejectPaymentListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'readyForPayment\'"", readyForPayment, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.paymentRejected(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'rejectPayment\' transition \n     */\n    @Test\n    public void test_rejectPayment()\n    {\n        final ClaimsReadyForPayment readyForPayment = moveToClaimsReadyForPayment();\n        final ClaimsStateMachine fsm = readyForPayment.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        readyForPayment.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        readyForPayment.rejectPayment();\n\n        //\n        // assert the current state is now ClaimsPaymentRejected\n        //\n        Assert.assertEquals(fsm.paymentRejected(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.paymentRejected().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsRejectPayment.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsRejectPayment.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(readyForPayment.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReadyForPayment\' can be moved into the ClaimsPaymentRejected state\n     */\n    @Test\n    public void test_moveToClaimsPaymentRejected()\n    {\n        final ClaimsReadyForPayment readyForPayment = moveToClaimsReadyForPayment();\n        final ClaimsStateMachine fsm = readyForPayment.getStateMachine();\n        readyForPayment.getPaths(fsm.paymentRejected());\n        \n    }\n    \n    @Test\n    public void test_getPathBetweenClaimsReadyForPaymentAndClaimsPaymentReceived()\n    {\n\n        final ClaimsReadyForPayment readyForPayment = moveToClaimsReadyForPayment();\n        final ClaimsStateMachine fsm = readyForPayment.getStateMachine();\n        Assert.assertEquals(""precondition failed: we be in state: \'readyForPayment\'"", readyForPayment, fsm.getCurrentState());\n\n        final TransitionPaths paths = readyForPayment.getPaths(fsm.paymentReceived());\n        Assert.assertNotNull(paths);\n\n        /**\n         * at first disallow the transition\n         */\n        final AtomicBoolean allowTransition = new AtomicBoolean(false);\n        final Predicate<Transition> logic = new Predicate<Transition>() {\n            @Override\n            public boolean apply(final Transition value)\n            {\n                return allowTransition.get();\n            }\n        };\n        final TransitionListener listener = TransitionListeners.blockOnTrue(logic,Reasons.NO_REASON_GIVEN);\n        readyForPayment.registerMarkPaymentAsReceivedListener(listener);\n\n        // call the method under test\n        final TransitionPath path = paths.getShortestPath();\n        Assert.assertFalse(path.execute().isSuccess());\n\n        Assert.assertEquals(""we should still be in the same state: \'readyForPayment\'"", readyForPayment, fsm.getCurrentState());\n\n        /**\n         * now allow the transition\n         */\n        allowTransition.set(true);\n        Assert.assertTrue(path.execute().isSuccess());\n        Assert.assertEquals(fsm.paymentReceived(), fsm.getCurrentState());\n    }\n    \n    /**\n     * test the \'markPaymentAsReceived\' transition \n     */\n    @Test\n    public void test_markPaymentAsReceived()\n    {\n        final ClaimsReadyForPayment readyForPayment = moveToClaimsReadyForPayment();\n        final ClaimsStateMachine fsm = readyForPayment.getStateMachine();\n\n        //\n        // add a generate (state-machine wide) and state-specific listener\n        //\n        final RecordingListener generalListener = fsm.registerListener(StateListeners.recordingListener());\n        final RecordingListener stateSpecificListener = StateListeners.recordingListener();\n        readyForPayment.registerListener(stateSpecificListener);\n\n        \n        // call the method under test\n        readyForPayment.markPaymentAsReceived();\n\n        //\n        // assert the current state is now ClaimsPaymentReceived\n        //\n        Assert.assertEquals(fsm.paymentReceived(), fsm.getCurrentState());\n        Assert.assertEquals(fsm.paymentReceived().getName(), fsm.getCurrentStateName());\n\n        //\n        // assert the general state listener was called\n        //\n        {\n            final List<Transition> enterTransitions = generalListener.getEnterTransitions();\n            Assert.assertEquals(1, enterTransitions.size());\n            Assert.assertEquals(TransitionClaimsMarkPaymentAsReceived.NAME, enterTransitions.get(0).getName());\n        }\n\n        //\n        // assert the specific state listener was called\n        //\n        final List<Transition> enterTransitions = stateSpecificListener.getEnterTransitions();\n        Assert.assertEquals(1, enterTransitions.size());\n        Assert.assertEquals(TransitionClaimsMarkPaymentAsReceived.NAME, enterTransitions.get(0).getName());\n        \n        // remove listeners\n        Assert.assertTrue(fsm.unregisterListener(generalListener));\n        Assert.assertTrue(readyForPayment.unregisterListener(stateSpecificListener));\n    }\n\n    /**\n     * test the \'ClaimsReadyForPayment\' can be moved into the ClaimsPaymentReceived state\n     */\n    @Test\n    public void test_moveToClaimsPaymentReceived()\n    {\n        final ClaimsReadyForPayment readyForPayment = moveToClaimsReadyForPayment();\n        final ClaimsStateMachine fsm = readyForPayment.getStateMachine();\n        readyForPayment.getPaths(fsm.paymentReceived());\n        \n    }\n}\n')",[270926]
"('Description.java', 'org.junit.runner.Description', 'parseMethod', '(.*)\\((.*)\\)', 'test_fromFile(com.porpoise.fsm.model.StateMachineTest)')","[218, 2076, 3192, 21261, 28883, 31128, 31871, 42805, 44065, 64470, 73712, 74405, 84597, 85785, 105022, 113519, 114312, 125988, 127320, 148893, 158847, 159715, 172504, 173944, 197269, 208021, 208939, 222470, 223982, 248668, 249630]"
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_moveToClaimsPaymentReceived(aaron.test.test.ClaimsReadyForPaymentTest)')","[8555, 8586, 8617, 12275, 12306, 12337, 24549, 24573, 24597, 36334, 36364, 36394, 50120, 50155, 50190, 54320, 54355, 54390, 68306, 68334, 68362, 78564, 78592, 78620, 91494, 91527, 91560, 95454, 95487, 95520, 108584, 108610, 108636, 119079, 119111, 119143, 133721, 133758, 133795, 138161, 138198, 138235, 153003, 153033, 153063, 164938, 164973, 165008, 180864, 180904, 180944, 185664, 185704, 185744, 201790, 201823, 201856, 214466, 214503, 214540, 231248, 231290, 231332, 236288, 236330, 236372, 294433, 294473, 294513, 295765, 295807, 295849]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\n\n\n/**\n * Representation of the state machine. Through a TestStateMachine instance you can:\n * <ul>\n * <li>Create a new instance (see @{link createAndStart()} and @{link create()})</li>\n * <li>Access all states by their names</li>\n * <li>register and unregister listeners which will be notified of every state transition</li>\n * <li>navigate to (execute) states via transitions</li>\n * <li>retrieve state instances by their names</li>\n * </ul>\n *\n * States returned via this state machine may *only* be used in this state machine.\n * For example, this is not valid:\n * <pre>\n * TestStateMachine fsmOne = TestStateMachine.createAndStart();\n * TestStateMachine fsmTwo = TestStateMachine.createAndStart();\n * Object stateA = fsmOne.<some state>();\n * fsmTwo.executeToState(stateA); // invalid  -- cannot share state instances between state machines\n * </pre>\n */\npublic class TestStateMachine\n{\n    private StateNotifier notifier;\n    private State                     currentState;\n    private final Map<String, AbstractTestState>  stateByName;\n\n    private TestStartState teststartstate;\n\n    /**\n     *\n     */\n    private TestStateMachine()\n    {\n        super();\n        this.stateByName = new HashMap<String, AbstractTestState>();\n    }\n\n    /**\n     * @return a new notifier\n     */\n    final StateNotifier newNotifier()\n    {\n        return new StateNotifier();\n    }\n\n    /**\n     * state machines need to be explicitly started.\n     * This is a convenience method for returning a new state machine which is \n     * already in the start state\n     *\n     * @return the new state machine\n     */\n    public static TestStateMachine createAndStart()\n    {\n        TestStateMachine instance = create();\n        instance.start();\n        return instance;\n    }\n\n    /**\n     * factory method used to create state machines\n     *\n     * @return a new state machine instance\n     */\n    public static TestStateMachine create()\n    {\n        final TestStateMachine fsm = new TestStateMachine();\n\n        fsm.notifier = fsm.newNotifier();\n        \n        //\n        // Create states\n        //\n        fsm.teststartstate = new TestStartState(fsm);\n        final State oldTestStartStateEntry = fsm.stateByName.put(fsm.teststartstate.getName(), fsm.teststartstate);\n        assert oldTestStartStateEntry == null : ""duplicate state names: "" + fsm.teststartstate.getName();\n\n\n        //\n        // Initialise transitions\n        //\n        fsm.teststartstate.initialise();\n        return fsm;\n    }\n\n    /**\n     * @return the current state\n     */\n    public State getCurrentState()\n    {\n        return this.currentState;\n    }\n    \n    /**\n     * @param goal the target state\n     * @return a TransitionPaths object from the current state to the given goal state\n     */\n    public TransitionPaths getPaths(final State goal)\n    {\n        return getCurrentState().getPaths(goal);\n    }\n\n    /**\n     * @param goal\n     *            the target state\n     * @return a TransitionPaths object from the current state to the given goal state\n     */\n    public TransitionPaths getSuccessfulPaths(final State goal)\n    {\n        final TransitionPaths allPaths = getCurrentState().getPaths(goal);\n        final TransitionPaths successfulPaths = new TransitionPaths();\n        if (allPaths != null)\n        {\n            for (final TransitionPath path : allPaths)\n            {\n                final TransitionPathResult result = executePathDryRun(path);\n                if (result != null && result.isSuccess())\n                {\n                    successfulPaths.add(path);\n                }\n            }\n        }\n        return successfulPaths;\n    }\n\n    /**\n     * @param path\n     *            the path to execute w/o affecting the current state. All registered listeners however will be notified.\n     * @return the result\n     */\n    public final TransitionPathResult executePathDryRun(final TransitionPath path)\n    {\n        final State beforeState = getCurrentState();\n        TransitionPathResult result;\n        try\n        {\n            result = path.execute();\n        }\n        finally\n        {\n            setCurrentState(beforeState);\n        }\n        return result;\n    }\n\n    /**\n     * @param path\n     *            the path to execute\n     * @return the result\n     */\n    public final TransitionPathResult executePath(final TransitionPath path)\n    {\n        return path.execute();\n    }\n\n    /**\n     * @param the given state name\n     * @return the result\n     */\n    public TransitionPathResult executeToState(final String name)\n    {   \n        final State state = getStateForName(name);\n        if (state == null)\n        {\n            throw new IllegalArgumentException(String.format(""No state exists with the name \'%s\'"", name));\n        }\n        return executeToState(state);\n    }\n\n    /**\n     * @param the given state name\n     * @return the result\n     */\n    public TransitionPathResult executeToStateDryRun(final String name)\n    {   \n        final State state = getStateForName(name);\n        if (state == null)\n        {\n            throw new IllegalArgumentException(String.format(""No state exists with the name \'%s\'"", name));\n        }\n        return executeToStateDryRun(state);\n    }\n    \n    /**\n     * After calling, the state will be reset its current state see {@link #executeToState(State)}\n     * \n     * @param to\n     *            the goal state\n     * @return the result of executing to the given state via the shorted available path\n     */\n    public TransitionPathResult executeToStateDryRun(final State to)\n    {\n        final State beforeState = getCurrentState();\n        TransitionPathResult result;\n        try\n        {\n            result = executeToState(to);\n        }\n        finally\n        {\n            setCurrentState(beforeState);\n        }\n        return result;\n    }\n\n\n    /**\n     * jump to the given state via the shortest \'path\'.\n     * \n     * @param to\n     *            the goal state\n     * @return the result of trying to move to the given state via the shortest available path, or null if no path was found. If the state machine was already in the given state it returns false. If the state\n     *         machine has now moved into the given state it returns true.\n     */\n    public TransitionPathResult executeToState(final State to)\n    {\n        if (to == getCurrentState())\n        {\n            return TransitionPathResult.fail(TransitionGuard.Reasons.ALREADY_IN_TARGET_STATE);\n        }\n\n        final TransitionPath path = getShortestSuccessfulPath(to);\n        \n        if (path != null)\n        {\n            return path.execute();\n        }\n\n        return TransitionPathResult.fail(TransitionGuard.Reasons.TARGET_STATE_UNREACHABLE);\n    }\n\n    /**\n     * @param to\n     *            the target (goal) state\n     * @return the first path available which can transition to the given state\n     */\n    public TransitionPath getShortestSuccessfulPath(final State to)\n    {\n        final State beforeState = getCurrentState();\n        TransitionPath path;\n        try\n        {\n            path = getShortestSuccessfulPathInternal(to);\n        }\n        finally\n        {\n            setCurrentState(beforeState);\n        }\n\n        return path;\n    }\n\n    private TransitionPath getShortestSuccessfulPathInternal(final State to)\n    {\n        final TransitionPaths paths = getPaths(to);\n        boolean success = false;\n        final State beforeState = getCurrentState();\n        for (final TransitionPath path : paths)\n        {\n            StateLog.debug(""trying "" + path);\n            success = executeToStateInternal(path, to);\n            if (success)\n            {\n                return path;\n            }\n            setCurrentState(beforeState);\n        }\n        return null;\n    }\n\n    /**\n     * jump to the given state via the path of transitions\n     * \n     * @return true if this call had any effect\n     */\n    private boolean executeToStateInternal(final TransitionPath path, final State to)\n    {\n        if (to == getCurrentState())\n        {\n            return false;\n        }\n        if (path == null)\n        {\n            throw new IllegalStateException(String.format(""can\'t get to \'%s\' from \'%s\'"", getCurrentStateName(), to.getName()));\n        }\n        path.execute();\n        return to == getCurrentState();\n    }\n\n    /**\n     * @return the name of the current state\n     */\n    public String getCurrentStateName()\n    {\n        return getCurrentState() == null ? null : getCurrentState().getName();\n    }\n\n    /**\n     * @return the start state\n     * @throws IllegalStateException\n     *             if the state machine was already started\n     */\n    public TestStartState start()\n    {\n        if (getCurrentState() != null && getCurrentState().equals(this.teststartstate))\n        {\n            throw new IllegalStateException(""already started"");\n        }\n        setCurrentState(this.teststartstate);\n        return this.teststartstate;\n    }\n\n    /**\n     * @return the TestStartState state\n     */\n    public TestStartState startState()\n    {\n        return this.teststartstate;\n    }    \n\n\n    /**\n     * @return a collection of all the transitions across all states\n     */\n    public Collection<Transition> getTransitions()\n    {\n        final Collection<Transition> states = new LinkedList<Transition>();\n        for (final AbstractTestState state : this.stateByName.values())\n        {\n            states.addAll(state.getTransitions());\n        }\n        return states;\n    }\n\n    /**\n     * @return a collection of all the names for all the transitions across all states\n     */\n    public Collection<String> getTransitionNames()\n    {\n        final Collection<String> names = new LinkedList<String>();\n        for (final AbstractTestState state : this.stateByName.values())\n        {\n            names.addAll(state.getTransitionNames());\n        }\n        return names;\n    }\n\n    /**\n     * @return a collection of all states for this state machine\n     */\n    public Collection<State> getStates()\n    {\n        final Collection<State> states = new LinkedList<State>();\n        for (final AbstractTestState state : this.stateByName.values())\n        {\n            states.add(state);\n        }\n        return states;\n    }\n\n\n    /**\n     * @return a collection of all the names of all the states for this state machine\n     */\n    public Collection<String> getStateNames()\n    {\n        return this.stateByName.keySet();\n    }\n    \n    /**\n     * @param name the name of the state\n     * @return the state for the given name\n     */\n    public State getStateForName(final String name)\n    {\n        if (name == null)\n        {\n            throw new NullPointerException(""Invalid argument: null state name"");\n        }\n        return this.stateByName.get(name);\n    }\n\n    /**\n     * @param name\n     *            the name of the transition\n     * @return the transition for the given name\n     */\n    public Transition getTransitionForName(final String name)\n    {\n        for (final AbstractTestState state : this.stateByName.values())\n        {\n            final Transition transition = state.getTransitionForName(name);\n            if (transition != null)\n            {\n                return transition;\n            }\n        }\n        return null;\n    }\n    \n    final void setCurrentState(State newState)\n    {\n        this.currentState = newState;\n    }\n\n\n    /**\n     * @param listeners\n     */\n    public void registerListeners(final StateListener... listeners)\n    {\n        for (final StateListener listener : listeners)\n        {\n            registerListener(listener);\n        }\n    }\n\n    /**\n     * register and return the given listener\n     * @param listener the registered listener\n     * @return the registered listener (for chaining)\n     */\n    public <T extends StateListener> T registerListener(final T listener)\n    {\n        final boolean added = this.notifier.registerListener(listener);\n        assert added;\n        return listener;\n    }\n\n    /**\n     * unregister a listener\n     * @return true if the listener was successfully unregistered\n     */\n    public boolean unregisterListener(final StateListener listener)\n    {\n        return this.notifier.unregisterListener(listener);\n    }\n\n    final TransitionGuard onBeforeTransition(final Transition transition)\n    {\n        return this.notifier.onBeforeTransition(transition);\n    }\n\n    final TransitionGuard onAfterTransition(final Transition transition)\n    {\n        return this.notifier.onAfterTransition(transition);\n    }\n\n    /**\n     * drops your entire database.\n     * Either that or just represents the state machine as a string. \n     * Take your chances.\n     */\n    @Override\n    public String toString()\n    {\n        final String newLine = String.format(""%n"");\n        final StringBuilder builder = new StringBuilder(""TestStateMachine"").append(newLine);\n        builder.append(""\\t"").append(this.notifier).append(newLine);\n        builder.append(""Current State:"");\n        builder.append(this.currentState).append(newLine);\n        builder.append(this.teststartstate).append(newLine);\n        return builder.toString();\n    }\n}\n')",[277151]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.HashMap;\n        \nabstract class AbstractTestState implements State\n{\n    private final Map<String, Transition> transitionsByName;\n\n    private final TestStateMachine stateMachine;\n    private final StateNotifier notifier;\n    \n    AbstractTestState(final TestStateMachine fsm)\n    {\n        if (fsm == null)\n        {\n            throw new NullPointerException(""state machine cannot be null"");\n        }\n        this.stateMachine = fsm;\n        this.notifier = fsm.newNotifier();\n        this.transitionsByName = new HashMap<String, Transition>();\n    }\n    \n    public TestStateMachine getStateMachine()\n    {\n        return this.stateMachine;\n    }\n\n\n    /**\n     * @param fsm\n     */\n    void initialise()\n    {\n        for(final Transition transition  : initialiseTransitions())\n        {\n            this.transitionsByName.put(transition.getName(), transition);\n        }    \n    }\n    \n    Collection<Transition> getTransitions()\n    {\n        return this.transitionsByName.values();\n    }\n\n    Collection<String> getTransitionNames()\n    {\n        return this.transitionsByName.keySet();\n    }\n    \n    final Transition getTransitionForName(final String name)\n    {\n        return this.transitionsByName.get(name);\n    }\n\n    abstract Collection<Transition> initialiseTransitions();\n\n    /**\n     * @return true if the listener was successfully registered\n     */\n    public <T extends StateListener> T registerListener(final T listener)\n    {\n        final boolean registered = this.notifier.registerListener(listener);\n        assert registered : ""listener not registered: "" + listener;\n        return listener;\n    }\n\n    public boolean unregisterListener(final StateListener listener)\n    {\n        return this.notifier.unregisterListener(listener);\n    }\n\n    final TransitionGuard onExit(final Transition transition)\n    {\n        return this.notifier.onBeforeTransition(transition);\n    }\n\n    final TransitionGuard onEnter(final Transition transition)\n    {\n        return this.notifier.onAfterTransition(transition);\n    }\n\n    /**\n     * @param the target state\n     * @return the transition paths\n     */\n    public TransitionPaths getPaths(final State toState)\n    {\n        final TransitionPaths paths = new TransitionPaths();\n        final TransitionPath path = new TransitionPath(this);\n\n        appendPathRecursive(paths, path, toState);\n\n        return paths;\n    }\n\n    private void appendPathRecursive(final TransitionPaths paths, final TransitionPath srcPath, final State goal)\n    {\n        for (final Transition transition : getTransitions())\n        {\n            final TransitionPath path = srcPath.clonePath();\n            final AbstractTestState targetState = (AbstractTestState) transition.getTarget();\n\n            final boolean notRecursivePathLoop = path.add(targetState, transition);\n\n            if (notRecursivePathLoop)\n            {\n                if (targetState.equals(goal))\n                {\n                   paths.add(path); \n                }\n                else\n                {\n                    targetState.appendPathRecursive(paths, path, goal);\n                }\n            }\n        }\n    }\n    \n    /**\n     *\n     */\n    @Override\n    public String toString()\n    {\n        final StringBuilder builder = new StringBuilder();\n        final String newLine = String.format(""%n"");\n        builder.append(getName()).append(newLine);\n        for (final Transition transition : getTransitions())\n        {\n            builder.append(""\\t"").append(transition).append(newLine);\n        }\n        builder.append(""\\t"").append(this.notifier).append(newLine);\n        return builder.toString();\n    }\n}\n')",[286311]
"('Description.java', 'org.junit.runner.Description', 'getClassName', '(.*)\\((.*)\\)', 'test_executeToClaimsReceivedByMonitoringOfficer(aaron.test.test.ClaimsReceivedByMonitoringOfficerTest)')","[10539, 10570, 10601, 13887, 13918, 13949, 25029, 25053, 25077, 37071, 37101, 37131, 52360, 52395, 52430, 56140, 56175, 56210, 68866, 68894, 68922, 79251, 79279, 79307, 93606, 93639, 93672, 97170, 97203, 97236, 109104, 109130, 109156, 119866, 119898, 119930, 136089, 136126, 136163, 140085, 140122, 140159, 153603, 153633, 153663, 165800, 165835, 165870, 183424, 183464, 183504, 187744, 187784, 187824, 202450, 202483, 202516, 215378, 215415, 215452, 233936, 233978, 234020, 238472, 238514, 238556, 296671, 296711, 296751, 298459, 298501, 298543]"
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\bclass (\\w+).*', 'package p;\n\n/**\n * a listener which groups other listeners\n */\npublic class GroupStateListener implements StateListener \n{\n    private final StateNotifier notifier;\n\n    /**\n     */\n    public GroupStateListener(final StateListener ... listeners)\n    {\n        this.notifier = new StateNotifier();\n        for (final StateListener listener : listeners)\n        {\n            this.notifier.registerListener(listener);\n        }\n    }\n   \n    @Override\n    public TransitionGuard onExit(final Transition transition)\n    {\n        return this.notifier.onBeforeTransition(transition);\n    }\n\n    @Override\n    public TransitionGuard onEnter(final Transition transition)\n    {\n        return this.notifier.onAfterTransition(transition);\n    }\n\n    /**\n     * @return the string representation of this listener\n     */\n    @Override\n    public String toString()\n    {\n        return String.format(""group listener {%s}"", this.notifier);\n    }\n}\n')",[279795]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*?\\benum (\\w+).*', 'package p;\n\nimport com.google.common.base.Predicate;\n\n/**\n * a listener which can be turned on and off by the given predicate\n */\npublic class ConditionalStateListener extends AbstractConditionalStateListener \n{\n    private final StateListener wrappedListener;\n\n    /**\n     * @param predicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener will be executed.\n     * @param listener\n     */\n    public ConditionalStateListener(final Predicate<Transition> predicate, final StateListener listener)\n    {\n        this(predicate, predicate, listener);\n    }\n\n    /**\n     * @param enterPredicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener\'s onEnter will be executed.\n     * @param exitPredicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener\'s onExit method will be executed.\n     * @param predicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener will be executed.\n     * @param listener\n     */\n    public ConditionalStateListener(final Predicate<Transition> enterPredicate, final Predicate<Transition> exitPredicate, final StateListener listener)\n    {\n        this(enterPredicate, exitPredicate, listener, TransitionGuard.ok(), TransitionGuard.ok());\n    }\n\n    /**\n     * @param enterPredicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener\'s onEnter will be executed.\n     * @param exitPredicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener\'s onExit method will be executed.\n     * @param predicate the predicate logic used to filter the given listener. If the predicate\'s apply method returns \'true\', then the wrapped listener will be executed.\n     * @param listener\n     * @param enterDefault the transition to return should the enter predicate filter return false\n     * @param exitDefault the transition to return should the exit predicate filter return false\n     */\n    public ConditionalStateListener(final Predicate<Transition> enterPredicate, final Predicate<Transition> exitPredicate, final StateListener listener, final TransitionGuard enterDefault, final TransitionGuard exitDefault)\n    {\n        super(enterPredicate, exitPredicate, exitDefault, exitDefault);\n        if (listener == null)\n        {\n            throw new NullPointerException(""listener cannot be null"");\n        }\n        this.wrappedListener = listener;\n    }\n   \n    /**\n     * @param transition\n     * @return the transition return value.  \n     */\n    @Override\n    protected TransitionGuard onExitInternal(final Transition transition)\n    {\n        return this.wrappedListener.onExit(transition);\n    }\n\n    /**\n     * @param transition\n     * @return the transition return value.  \n     */\n    @Override\n    protected TransitionGuard onEnterInternal(final Transition transition)\n    {\n        return this.wrappedListener.onEnter(transition);\n    }\n}\n')",[279633]
"('FilenameHelper.java', 'com.porpoise.fsm.generator.FilenameHelper', 'parse', '.*\\bpackage\\s+(.*?);.*', 'package p;\n\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n *\n */\nclass StateNotifier\n{\n    private final List<StateListener> listeners;\n    \n    private enum TransitionType {\n        ENTER {\n            @Override\n            public TransitionGuard fire(final StateListener listener, final Transition transition)\n            {\n                return listener.onEnter(transition);\n            }\n        },\n        EXIT {\n            @Override\n            public TransitionGuard fire(final StateListener listener, final Transition transition)\n            {\n                return listener.onExit(transition);\n            }\n        };\n        \n        public abstract TransitionGuard fire(StateListener listener, Transition trans);\n    }\n\n    /**\n     */\n    StateNotifier()\n    {\n        super();\n        this.listeners = new CopyOnWriteArrayList<StateListener>();\n    }\n\n    /**\n     * @param listener the listener\n     * @return true if the listener was registered\n     */\n    public boolean registerListener(final StateListener listener)\n    {\n        if (listener == null)\n            return false;\n        return this.listeners.add(listener);\n    }\n\n    /**\n     * @param listener the listener\n     * @return true if the listener was unregistered\n     */\n    public boolean unregisterListener(final StateListener listener)\n    {\n        if (listener == null)\n            return false;\n        return this.listeners.remove(listener);\n    }\n\n\n    final TransitionGuard onBeforeTransition(final Transition transition)\n    {\n        return fireTransition(transition, TransitionType.EXIT);\n    }\n\n    final TransitionGuard onAfterTransition(final Transition transition)\n    {\n        return fireTransition(transition, TransitionType.ENTER);\n    }\n\n    final TransitionGuard fireTransition(final Transition transition, final TransitionType type)\n    {\n        TransitionGuard result = TransitionGuard.ok();\n\n        //\n        // fire general-purpose listeners\n        //\n        for (final StateListener listener : this.listeners)\n        {\n            final TransitionGuard condition = type.fire(listener, transition);\n            if (condition.stop())\n            {\n                StateLog.debug(""asked to stop immediately by listener \'%s\' for transition \'%s\'. Reason=%s"", listener, transition, condition.getReason());\n                return condition;\n            }\n            else if (!condition.continueProcessing())\n            {\n                StateLog.debug(""asked to stop eventually by listener \'%s\' for transition \'%s\'. Reason=%s"", listener, transition, condition.getReason());\n                // if *any* listener asks to stop, then set the result to stop\n                result = condition;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @return the string representation\n     */\n    @Override\n    public String toString()\n    {\n        final String newLine = String.format(""%n"");\n        final StringBuilder b = new StringBuilder();\n        for (final StateListener listener : this.listeners)\n        {\n            b.append(listener).append(newLine);\n        }\n        return String.format(""Listeners: %s"", b);\n    }\n}\n')",[285150]
